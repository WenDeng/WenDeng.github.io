<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解netfilter的核心原理与实现</title>
      <link href="/2019/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3netfilter%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3netfilter%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Iptables和Netfilter的关系"><a href="#1、Iptables和Netfilter的关系" class="headerlink" title="1、Iptables和Netfilter的关系"></a>1、Iptables和Netfilter的关系</h3><p>iptables是用户用来管理和配置防火墙规则的一种策略，但是实际解析规则并按照规则实施产生作用的是Netfilter。</p><p>iptables与协议栈内有包过滤功能的hook交互来完成工作，这些内核hook构成了netfilter框架。每个进入网络系统的包（接收和发送）在经过协议栈的时候都会触发这些hook，程序可以通过<strong>注册hook函数</strong>的方式在一些关键路径上处理网络流量。iptables相关的内核模块在这些hook注册了处理函数，因此可以通过iptables规则来使得网络流量符合防火墙规则。</p><h3 id="2、Netfilter-Hooks"><a href="#2、Netfilter-Hooks" class="headerlink" title="2、Netfilter Hooks"></a>2、Netfilter Hooks</h3><p>netfilter提供了5个关于IPv4的hook点，数据包经过协议栈时会触发内核模块注册在这里的处理函数。触发哪个hook取决于包的方向（接收还是接收）、包的目的地址、以及包在上一个hook点是被丢弃还accept等等。</p><p>下面几个hook是内核协议栈已经定义好的：</p><ul><li>NF_IP_PRE_ROUTING: 接收到的包进入协议栈立即触发此个hook（刚刚进行完版本号，校验和等检测），在进行任何路由判断之前</li><li>NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此hook</li><li>NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此hook</li><li>NF_IP_LOCAL_OUT：本机产生的准备发送的包，在进入协议栈后立即触发此hook</li><li>NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由的判断之后，将触发此hook</li></ul><p>注册处理函数时必须提供优先级，以便hook触发能按照优先级高低调用处理函数，这使得多个模块可以在同一个hook点注册，并且有确定的处理顺序，内核模块会依次被调用，每次返回一个结果给netfilter框架，提示该对这包做什么操作。</p><h3 id="3、Hooks和Iptables-table-and-chain的关系"><a href="#3、Hooks和Iptables-table-and-chain的关系" class="headerlink" title="3、Hooks和Iptables table and chain的关系"></a>3、Hooks和Iptables table and chain的关系</h3><p>Iptable使用table来组织规则，分为以下5类table：</p><ul><li>Filter Table：是最常用的table之一，用于判断是否允许一个包通过。</li><li>NAT Table: 用于实现网络地址转换规则。当包进入协议栈的时候，这些规则决定是否以及如何修改包的源/目的地址，以改变包被 路由时的行为。nat table通常用于将包路由到无法直接访问的网络。</li><li>Mangle Table: 用于修改包的IP头。如可以修改包的TTL，增加或减少包可以经过的跳数。还可以对包打只在内核内有效的“标记”，后续的table或工具处理的时候可以用到这些标记。标记不会修改包本身，只是在包的内核表示上做标记。</li><li>Raw Table：其功能非常有限，其唯一目的就是提供一个让包绕过连接跟踪的框架。</li><li>Security Table：作用是给包打上SELinux标记，以此影响SELinux 或其他可以解读 SELinux 安全上下文的系统处理包的行为。这些标记可以基于单个包，也可以基于连接。</li></ul><p>在每个table内部，规则被进一步组织成chain，内置的chain是由内置的hook触发的。chain基本上能决定规则何时被匹配。内置的chain名字和netfilter hook名字是一一对应的：</p><ul><li>PREROUTING: 由 NF_IP_PRE_ROUTING hook触发 ——————&gt; raw,mangle,nat(目的)</li><li>INPUT: 由 NF_IP_LOCAL_IN hook触发 ——————&gt; mangle,filter,security,nat(源)</li><li>FORWARD: 由 NF_IP_FORWARD hook触发 ——————&gt; mangle,filter,security</li><li>OUTPUT: 由 NF_IP_LOCAL_OUT hook触发 ——————&gt; raw,mangle,nat,filter,security,nat(源)</li><li>POSTROUTING: 由 NF_IP_POST_ROUTING hook触发 ——————&gt; mangle，nat(源)</li></ul><p>chain使管理员可以控制在包的传输路径上哪个点应用策略。因为每个table有多个chain，因此一个 table可以在处理过程中的多个地方施加影响。特定类型的规则只在协议栈的特定点有意义，因此并不是每个table都会在内核的每个hook注册chain。可以看出raw table只有两个链prerouting和output，分别在对应的hook点发挥作用。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/1.jpg?raw=true" alt="image"></p><h3 id="4、从IP协议栈入手"><a href="#4、从IP协议栈入手" class="headerlink" title="4、从IP协议栈入手"></a>4、从IP协议栈入手</h3><p>要想理解Netfilter的工作原理，必须从对Linux IP报文处理流程的分析开始，Netfilter正是将自己紧密地构建在这一流程之中的。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/2.jpg?raw=true" alt="image"></p><h4 id="4-1-接收中断"><a href="#4-1-接收中断" class="headerlink" title="4.1 接收中断"></a>4.1 接收中断</h4><p>如果网卡收到一个和自己MAC地址匹配或链路层广播的以太网帧，它就会产生一个中断。此网卡的驱动程序会处理此中断做入下处理：</p><ul><li>从DMA/PIO或其他地方得到分组数据，写到内存里去；</li><li>接着，会分配一个新的套接字缓冲区skb，并调用与协议无关的、网络设备均支持的通用网络接收处理函数netif_rx(skb)。netif_rx()函数让内核准备进一步处理skb。</li><li>然后，skb会进入到达队列以便CPU处理（对于多核CPU而言，每个CPU维护一个队列）。如果FIFO队列已满，就会丢弃此分组。在skb排队后，调用__cpu_raise_softirq()标记NET_RX_SOFTIRQ 软中断，等待 CPU 执行。</li><li>至此， netif_rx() 函数调用结束，返回调用者状况信息（成功还是失败等）。此时，中断上下文进程完成任务，数据分组继续被上层协议栈处理。</li></ul><p>流程：网卡收到一帧————&gt;引发中断————&gt;cpu调用相应的中断处理函数（指向此网卡驱动中的相应的处理函数）（把此packet读到ram中）————&gt;呼叫netif_rx函数来打上timestamp，并把此skb放入到cpu设置的队列中————&gt;标记软中断（__cpu_raise_softirq）————&gt;中断完成。 </p><h4 id="4-2-softirq"><a href="#4-2-softirq" class="headerlink" title="4.2 softirq"></a>4.2 softirq</h4><p>内核2.4以后，整个协议栈不再使用bottom half，而是被软中断softirq取代。软中断 softirq优势明显，可以同时在多个CPU上执行；而bottom half一次只能在一个CPU上执行，即在多个CPU执行时严格保持串行。</p><p>整个softirq机制的设计与实现中自始自终都贯彻了一个思想：“谁触发，谁执行 ”，也即触发软中断的那个CPU负责执行它所触发的软中断，而且每个CPU都由它自己的软中断触发与控制机制。这个设计思想也使得softirq机制充分利用了SMP系统的性能和特点。</p><h4 id="4-3-NET-RX-SOFTIRQ-网络接收软中断"><a href="#4-3-NET-RX-SOFTIRQ-网络接收软中断" class="headerlink" title="4.3 NET_RX_SOFTIRQ 网络接收软中断"></a>4.3 NET_RX_SOFTIRQ 网络接收软中断</h4><p>这一阶段会根据协议的不同来处理数据分组。 CPU开始处理软中断do_softirq()，接着 net_rx_action() 处理前面标记的NET_RX_SOFTIRQ ，把出对列的skb送入相应列表处理（根据协议不同到不同的列表）。比如，IP分组交给 ip_rcv()处理， ARP分组交给arp_rcv()处理等。</p><h4 id="4-4-处理IPv4分组"><a href="#4-4-处理IPv4分组" class="headerlink" title="4.4 处理IPv4分组"></a>4.4 处理IPv4分组</h4><p>下面讲讲数据包到达网络层后所做的处理，整理流程如下图，从图中可以看到netfilter起作用的5个hooks。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/3.jpg?raw=true" alt="image"></p><h5 id="4-4-1-上述处理的详细过程如下："><a href="#4-4-1-上述处理的详细过程如下：" class="headerlink" title="4.4.1 上述处理的详细过程如下："></a>4.4.1 上述处理的详细过程如下：</h5><ul><li>ip_rcv()函数验证IP分组，比如目的地址是否本机地址，校验和是否正确等。若正确，<strong>则交给netfilter的NF_IP_PRE_ROUTING钩子</strong>,否则丢弃。</li><li>到了ip_rcv_finish()函数，数据包就要根据skb结构的目的或路由信息各奔东西了。<strong>ip_local_deliver</strong>()处理到本机的数据分组、<strong>ip_forward</strong>()处理需要转发的数据分组、<strong>ip_mr_input</strong>()转发组播数据包。如果是转发的数据包，还需要找出出口设备和下一跳。ip_rcv_finish()函数最后执行dst_input()，决定数据包的下一步的处理。</li></ul><h5 id="4-4-2-转发数据包"><a href="#4-4-2-转发数据包" class="headerlink" title="4.4.2 转发数据包"></a>4.4.2 转发数据包</h5><p>转发数据包的主要流程如下：</p><ul><li>处理IP头选项。如果需要的话，会记录本地IP地址和时间戳；</li><li>确认分组可以被转发；</li><li>将TTL减一，如果TTL为0 ，则丢弃分组；</li><li>根据 MTU 大小和路由信息，对数据分组进行分片，如果需要的话；</li><li>将数据分组送往外出设备。</li></ul><p>如果由于某种原因，数据分组不能被转发，那么就回应 ICMP 消息来说明不能转发的原因。在对转发的分组进行各种检查无误后，执行 ip_forward_finish ，准备发送。然后执行dst_output(skb) 。无论是转发的分组，还是本地产生的分组，都要经过dst_output(skb) 到达目的主机。 IP 头在此时已经完成就绪。dst_output(skb) 函数要执行虚函数 output（单播的话为ip_output ，多播为ip_mc_output）。最后，ip_finish_output 进入邻居子系统。</p><h5 id="4-4-3-数据包本地处理"><a href="#4-4-3-数据包本地处理" class="headerlink" title="4.4.3 数据包本地处理"></a>4.4.3 数据包本地处理</h5><p>数据包交给netfilter的IP_LOCAL_INPUT钩子,作相应处理，然后交给上层比如TCP进行下一步处理。TCP的处理过程如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/5.jpg?raw=true" alt="image"></p><p>ip_queue_xmit检查socket结构体中是否含有路由信息，如果没有则执行 ip_route_output_flow查找，并存储到sk数据结构中。如果找不到，则丢弃数据包。</p><p>数据最终到达驱动层，然后网卡再将数据发送出去。</p><h3 id="5、Netfilter-hook深入"><a href="#5、Netfilter-hook深入" class="headerlink" title="5、Netfilter hook深入"></a>5、Netfilter hook深入</h3><p>Netfilter的主要工作其实将iptable对应的规则转换成对应nf_hoo_ops变量，然后进行注册从而发挥作用，接下来我们看一下具体过程。</p><h4 id="5-1-注册和注销Netfilter-hook"><a href="#5-1-注册和注销Netfilter-hook" class="headerlink" title="5.1 注册和注销Netfilter hook"></a>5.1 注册和注销Netfilter hook</h4><p>注册一个hook函数是围绕nf_hook_ops数据结构的一个非常简单的操作，nf_hook_ops数据结构在linux/netfilter.h中定义，该数据结构的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span>                    </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>  </span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn *hook;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>   </span><br><span class="line">        <span class="keyword">u_int8_t</span> pf;    </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum;</span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>该数据结构中的list成员用于维护Netfilter hook的列表，并且不是用户在注册hook时需要关心的重点。</li><li>hook成员是一个指向nf_hookfn类型的函数的指针，该函数是这个hook被调用时执行的函数。nf_hookfn同样在linux/netfilter.h中定义。</li><li>pf这个成员用于指定协议族。有效的协议族在linux/socket.h中列出，但对于IPv4我们希望使用协议族PF_INET。</li><li>hooknum这个成员用于指定安装的这个函数对应的具体的hook类型，其值为NF_IP_PRE_ROUTING等。</li><li>priority这个成员用于指定在执行的顺序中，这个hook函数应当在被放在什么地方。对于IPv4，可用的值在linux/netfilter_ipv4.h的 nf_ip_hook_priorities 枚举中定义。出于示范的目的，在后面的模块中我们将使用NF_IP_PRI_FIRST。</li></ul><p>注册一个Netfilter hook需要调用nf_register_hook()函数，以及用到一个nf_hook_ops数据结构。nf_register_hook()函数以一个nf_hook_ops数据结构的地址作为参数并且返回一个整型的值。以下提供的是一个示例代码，该示例代码简单的注册了一个丢弃所有到达的数据包的函数。该代码同时展示了Netfilter的返回值如何被解析。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"xsc"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">nfho</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hook_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct net_device *in,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct net_device *out,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> (*okfn)(struct sk_buff *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NF_DROP;<span class="comment">//丢弃所有数据包</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kexec_test_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"kexec test start ...\n"</span>);</span><br><span class="line"> </span><br><span class="line">    nfho.hook = hook_func;</span><br><span class="line">    nfho.owner = <span class="literal">NULL</span>;</span><br><span class="line">    nfho.pf = PF_INET;</span><br><span class="line">    nfho.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">    nfho.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    </span><br><span class="line">    nf_register_hook(&amp;nfho);<span class="comment">// 注册一个钩子函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kexec_test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"kexec test exit ...\n"</span>);</span><br><span class="line">    nf_unregister_hook(&amp;nfho); <span class="comment">//注销钩子函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kexec_test_init); <span class="comment">//初始化</span></span><br><span class="line">module_exit(kexec_test_exit); <span class="comment">//退出处理</span></span><br></pre></td></tr></table></figure></p><h4 id="5-2-hook函数实现"><a href="#5-2-hook函数实现" class="headerlink" title="5.2 hook函数实现"></a>5.2 hook函数实现</h4><p>hook函数原型在linux/netfilter.h中给出，如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int nf_hookfn(unsigned int hooknum,</span><br><span class="line">                               struct sk_buff *skb,</span><br><span class="line">                               <span class="keyword">const</span> struct net_device *<span class="keyword">in</span>,</span><br><span class="line">                               <span class="keyword">const</span> struct net_device *<span class="keyword">out</span>,</span><br><span class="line">                               int <span class="comment">(*okfn)(struct sk_buff *)</span>);</span><br></pre></td></tr></table></figure></p><ul><li>skb之后的两个参数是指向net_device数据结构的指针，net_device数据结构被Linux内核用于描述所有类型的网络接口。这两个参数中的第一个in，用于描述数据包到达的接口，毫无疑问，参数out用于描述数据包离开的接口。必须明白，在通常情况下，这两个参数中将只有一个被提供。例如：参数in只用于NF_IP_PRE_ROUTING和NF_IP_LOCAL_IN hook，参数out只用于NF_IP_LOCAL_OUT和NF_IP_POST_ROUTING hook。</li><li>sk_buff数据结构中最有用的部分可能就是那三个描述传输层包头（例如：UDP, TCP, ICMP, SPX）、网络层包头（例如：IPv4/6, IPX, RAW）以及链路层包头（例如：以太网或者RAW）的联合(union)了。这三个联合的名字分别是h、nh以及mac。这些联合包含了几个结构，依赖于具体的数据包中使用的协议。</li><li>传递给hook函数的最后一个参数是一个命名为okfn函数指针，该函数以一个sk_buff数据结构作为它唯一的参数，并且返回一个整型的值。</li></ul><h4 id="5-3-Netfilter报过滤技术实现"><a href="#5-3-Netfilter报过滤技术实现" class="headerlink" title="5.3 Netfilter报过滤技术实现"></a>5.3 Netfilter报过滤技术实现</h4><p>介绍几种过滤技术的实现：</p><ul><li><strong>基于接口进行过滤</strong>:使用相应的net_device数据结构的name这个成员，你就可以根据数据包的源接口和目的接口来选择是否丢弃它。如果想丢弃所有到达接口eth0的数据包，你需要做的仅仅是将in-&gt;name 的值与”eth0”做比较，如果名字匹配，那么hook函数简单的返回NF_DROP即可，数据包会被自动销毁。</li><li><strong>基于地址进行过滤</strong>:基于数据包的源或目的IP地址进行过滤也同样可以实现， 获取一个数据包的IP头通过使用sk_buff数据结构中的网络层包头来完成。这个头位于一个联合中，可以通过sk_buff-&gt;nh.iph这样的方式来访问。如果数据包的源地址与我们设定的丢弃数据包的地址匹配，那么该数据包将被丢弃。</li><li><strong>基于TCP端口进行过滤</strong>:获取一个TCP头的指针是一件简单的事情,而可以分配一个tcphdr数据结构(在linux/tcp.h中定义)的指针，并将它指向我们的数据包中IP头之后的数据。如下代码：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int check_tcp_packet(<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span></span> *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span></span> *sk = skb_copy(skb, <span class="number">1</span>);  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span></span> *tcph = NULL;  </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span></span> *iph = NULL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span></span> *ip;  </span><br><span class="line">    __be16 dport;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!skb)  </span><br><span class="line"><span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">    ip = ip_hdr(sk);                                               </span><br><span class="line">    iph = ip_hdr(skb);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;protocol == IPPROTO_TCP)       <span class="comment">// TCP 协议</span></span><br><span class="line">    &#123;           </span><br><span class="line">        tcph = (void *) iph + iph-&gt;ihl * <span class="number">4</span>;  <span class="comment">// TCP 包头  </span></span><br><span class="line">        dport = tcph-&gt;dest;                  <span class="comment">// 目标端口  </span></span><br><span class="line">        <span class="keyword">if</span>(ntohs(dport) == <span class="number">25</span> )</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> NF_DROP;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、下一步延伸"><a href="#6、下一步延伸" class="headerlink" title="6、下一步延伸"></a>6、下一步延伸</h3><p>更多更深的内容需要进一步学习linux内核，这里就不再细述了，关于Netfilter的hook攻击技术以及libpcap的通信隐藏等都挺有意思的，有时间不妨深入去实践一下。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>1.<a href="https://arthurchiao.github.io/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">https://arthurchiao.github.io/blog/deep-dive-into-iptables-and-netfilter-arch-zh/</a><br>2.<a href="https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html</a><br>3.<a href="https://blog.csdn.net/cheng_fangang/article/details/8966242" target="_blank" rel="noopener">https://blog.csdn.net/cheng_fangang/article/details/8966242</a><br>4.<a href="https://blog.csdn.net/XscKernel/article/details/8186679" target="_blank" rel="noopener">https://blog.csdn.net/XscKernel/article/details/8186679</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Iptabls </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对象</title>
      <link href="/2019/05/16/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/05/16/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote><p>看完《深度探索c++对象模型》，心中对c++编译器在编译期间所做的处理有了更深入的认识，我想，除了对编译器本身有深入认识的作者之外，应该很少有人对c++的对象模型有这么深的认识。能接触了这本书，是我们的幸运，是作者让我们有机会能一窥其貌，感谢作者。</p></blockquote><blockquote><p>其实第一遍读这本书，我的收获还不算多，这可能是我对c++的使用还不够多的缘故，但通过这本书，我以后使用c++的时候，就会心里有更多的底气，也会有更多需要注意的地方，在经过更多的实践之后，我一定还会回来拜读这本书的。</p></blockquote><blockquote><p>现在，我想就本书所学到的的知识做一些总结。   </p></blockquote><hr><p>参考书籍及链接：     《深度探索c++对象模型》    </p><hr><h2 id="一、关于对象"><a href="#一、关于对象" class="headerlink" title="一、关于对象"></a>一、关于对象</h2><h4 id="1-C-在加入封装后-只含有数据成员和普通成员函数）的布局成本增加了多少？"><a href="#1-C-在加入封装后-只含有数据成员和普通成员函数）的布局成本增加了多少？" class="headerlink" title="1. C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？"></a>1. C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？</h4><p>答案是并没有增加布局成本。就像C struct一样，memeber functions虽然含在class的声明之内，却不出现在object中。每一个non-inline member function只会诞生一个函数实体。至于每一个“拥有零个或一个定义的” inline function则会在其每一个使用者(模块)身上产生一个函数实体。</p><h4 id="2-C-在布局以及存取时间上主要的额外负担是由virtual引起的，包括："><a href="#2-C-在布局以及存取时间上主要的额外负担是由virtual引起的，包括：" class="headerlink" title="2. C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括："></a>2. C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括：</h4><ul><li>virtual funciton机制，用以支持一个有效率的“执行期绑定”</li><li>virtual base class，用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体”</li></ul><h2 id="二、C-对象模式-The-C-Object-Model"><a href="#二、C-对象模式-The-C-Object-Model" class="headerlink" title="二、C++ 对象模式(The C++ Object Model)"></a>二、C++ 对象模式(The C++ Object Model)</h2><h4 id="1-在C-中，有两种class-data-members：static-和-nonstatic，以及三种class-member-functions：static、nonstatic和virtual。"><a href="#1-在C-中，有两种class-data-members：static-和-nonstatic，以及三种class-member-functions：static、nonstatic和virtual。" class="headerlink" title="1. 在C++中，有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。"></a>1. 在C++中，有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。</h4><h4 id="2-C-对象模型中，nonstatic-data-members被配置于每一个class-object之内。"><a href="#2-C-对象模型中，nonstatic-data-members被配置于每一个class-object之内。" class="headerlink" title="2. C++对象模型中，nonstatic data members被配置于每一个class object之内。"></a>2. C++对象模型中，nonstatic data members被配置于每一个class object之内。</h4><p>static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual function则以两个步骤支持之：</p><ul><li><ol><li>每个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为virtual table(vtbl)</li></ol></li><li><ol start="2"><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object(用以支持runtime type identification, RTTI)也经由virtual table被指出来，通常放在表格的第一个slot处。  </li></ol></li></ul><p>这个模型的主要优点在于它的空间和存取时间的效率。<br>主要缺点是：如果应用程序代码未曾改变，但所用到的class objects的nonstatic data members有所修改(有可能是增加、移除或更改)，那么应用程序代码同样得重新编译。</p><h4 id="3-继承关系可以指定为虚拟-virtual，也就是共享的意思-："><a href="#3-继承关系可以指定为虚拟-virtual，也就是共享的意思-：" class="headerlink" title="3.继承关系可以指定为虚拟(virtual，也就是共享的意思)："></a>3.继承关系可以指定为虚拟(virtual，也就是共享的意思)：</h4><p>在虚拟继承的情况下，base class不管在继承链中被派生(derived)多少次，永远只会存在一个实例(称为subobject)。</p><h2 id="三、关键词带来的差异"><a href="#三、关键词带来的差异" class="headerlink" title="三、关键词带来的差异"></a>三、关键词带来的差异</h2><h4 id="1-什么时候一个人应该在c-程序中以struct取代class"><a href="#1-什么时候一个人应该在c-程序中以struct取代class" class="headerlink" title="1.什么时候一个人应该在c++程序中以struct取代class?"></a>1.什么时候一个人应该在c++程序中以struct取代class?</h4><p>答案之一是当他让人感觉比较好的时候。单独来看，关键词本身并不提供任何差异，c++编译器对二者都提供了相同支持，我们可以认为支持struct只是为了方便将c程序迁移到c++中。<br>88</p><h4 id="2-那为什么我们要引入class关键词？"><a href="#2-那为什么我们要引入class关键词？" class="headerlink" title="2.那为什么我们要引入class关键词？"></a>2.那为什么我们要引入class关键词？</h4><p>这是因为引入的不只是class这个关键词，更多的是它所支持的封装和继承的哲学。</p><h4 id="3-怎么在c-中用好struct？"><a href="#3-怎么在c-中用好struct？" class="headerlink" title="3.怎么在c++中用好struct？"></a>3.怎么在c++中用好struct？</h4><p>将struct和class组合起来，组合，而非继承，才是把c和c++结合在一起的唯一可行的方法。另外，当你要传递“一个复杂的class object的全部或部分”到某个c函数去时，struct声明可以将数据封装起来，并保证拥有与c兼容的空间布局。</p><h2 id="四、对象的差异"><a href="#四、对象的差异" class="headerlink" title="四、对象的差异"></a>四、对象的差异</h2><h4 id="1-C-程序设计模型直接支持三种程序设计典范（programming-paradigms）："><a href="#1-C-程序设计模型直接支持三种程序设计典范（programming-paradigms）：" class="headerlink" title="1. C++程序设计模型直接支持三种程序设计典范（programming paradigms）："></a>1. C++程序设计模型直接支持三种程序设计典范（programming paradigms）：</h4><ul><li>程序模型：数据和函数分开。 </li><li>抽象数据类型模型：数据和函数一起封装以来提供。</li><li>面向对象模型：可通过一个抽象的base class封装起来，用以提供共同接口，需要付出的就是额外的间接性。<blockquote><p>虽然你可以直接或间接处理继承体系中的一个base class object,但只有通过pointer或reference的间接处理，才支持OO程序设计所需的多态性质。<strong>c++通过class的pointers和reference来支持多态，这种程序设计风格就称为面向对象</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Liberary_materials thing1<span class="comment">;//基类</span></span><br><span class="line">Book book<span class="comment">;//派生类</span></span><br><span class="line"><span class="attribute">thing1</span>=book<span class="comment">;</span></span><br><span class="line">thing1.check_in()<span class="comment">;//这种情况下，调用的是基类的check_in()</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Liberary_materials <span class="meta">&amp;thing2=book</span></span><br><span class="line">thing2.check_in();<span class="comment">//这种情况下调用的才是book的check_in()</span></span><br></pre></td></tr></table></figure><h4 id="2-C-以下列方法支持多态："><a href="#2-C-以下列方法支持多态：" class="headerlink" title="2. C++以下列方法支持多态："></a>2. C++以下列方法支持多态：</h4><ul><li><ol><li>经由一组隐式的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape *ps=<span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>经由virtual function机制<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ps</span>-&gt;</span>rotate();</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>经由dynamic_cast和typeid运算符<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(<span class="built_in">circle</span> *pc=<span class="keyword">dynamic_cast</span>&lt;<span class="built_in">circle</span> *&gt;(ps))...</span><br></pre></td></tr></table></figure></li></ol></li></ul><blockquote><p><strong>多态的主要用途是经由一个共同的接口来影响类型的封装</strong>，这个接口通常被定义在一个抽象的base class中。这个共享接口是以virtual function机制引发的，它可以在执行期根据object的真正类型解析出到底是哪一个函数实体被调用。</p></blockquote><h4 id="3-需要多少内存才能表现一个class-object"><a href="#3-需要多少内存才能表现一个class-object" class="headerlink" title="3. 需要多少内存才能表现一个class object?"></a>3. 需要多少内存才能表现一个class object?</h4><ul><li>其nonstatic data members的总和大小</li><li>加上任何由于aliginment的需求而填补上去的空间(可能存在于members之间，也可能存在于集合体边界),aliginement就是将数值调整到某数的倍数，如在32位的计算机上为4。</li><li>加上为了支持virtual而由内部产生的任何额外负担</li></ul><h4 id="4-一个指针-引用-，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的-一个机器字-。"><a href="#4-一个指针-引用-，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的-一个机器字-。" class="headerlink" title="4. 一个指针(引用)，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的(一个机器字)。"></a>4. 一个指针(引用)，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的(一个机器字)。</h4><p>例如：一个指向ZooAnimal的指针是如何地与一个指向整数得指针或一个指向template Array的指针有所不同的呢？<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal *px<span class="comment">;</span></span><br><span class="line">int *pi<span class="comment">;</span></span><br><span class="line">Array&lt;string&gt; *pta<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>以内存需求的观点来说，没有什么不同！它们三个都需要足够的内存来放置一个机器地址(通常是个word)。<strong>“指向不同类型的各指针”间的差异，既不在其指针表示法不同，也不在其内容(代表一个地址)不同，而是在其所寻址出来的object类型不同</strong>，也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小。</p><h4 id="5-转型-cast-其实是一种编译器指令。"><a href="#5-转型-cast-其实是一种编译器指令。" class="headerlink" title="5.转型(cast)其实是一种编译器指令。"></a>5.转型(cast)其实是一种编译器指令。</h4><p>大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存大大小和其内容”的<strong>解释方式</strong>。</p><blockquote><p>如一个类型为void *的指针只能够持有一个地址，但不能 通过它操作所指object。</p></blockquote><h4 id="6-一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）"><a href="#6-一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）" class="headerlink" title="6.一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）"></a>6.一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）</h4><p>二者都指向基类对象的第一个byte,其间的差别是，派生类指针涵盖的地址包含整个派生类对象，而一个基类指针所涵盖的地址只包含派生类对象的基类子对象部分。</p><blockquote><p>但基类指针可以通过virtual机制访问派生类对象的函数。</p></blockquote><h4 id="7-当一个base-class-object被直接初始化为-或被指定为-一个derived-class-object时。"><a href="#7-当一个base-class-object被直接初始化为-或被指定为-一个derived-class-object时。" class="headerlink" title="7.当一个base class object被直接初始化为(或被指定为)一个derived class object时。"></a>7.当一个base class object被直接初始化为(或被指定为)一个derived class object时。</h4><p>derived object就会被切割(sliced)以塞入较小的base type内存中，derived type将没有留下任何蛛丝马迹。多态于是不再呈现，而一个严格的编译器可以在编译器解析一个“通过此object而触发的virtual function调用操作”，因而回避virtual机制。如果virtual function被定义为inline，则更有效率上的大收获。</p><h4 id="8-C-也支持具体的ADT程序风格，如今被称为object-based-OB-。"><a href="#8-C-也支持具体的ADT程序风格，如今被称为object-based-OB-。" class="headerlink" title="8.C++也支持具体的ADT程序风格，如今被称为object-based(OB)。"></a>8.C++也支持具体的ADT程序风格，如今被称为object-based(OB)。</h4><p>一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象构建起来时不需要设置virtual机制。空间紧凑是因为每一个class object不需要负担传统上为了支持virtual机制儿需要的额外负荷。不过，<strong>OB设计比较没有弹性。</strong><br>在弹性（OO）和（OB）之间常常存在着取舍。一个人能够有效选择其一之前，必须先清楚了解两者的行为和应用领域的需求。</p>]]></content>
      
      
      <categories>
          
          <category> C\+\+基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C\+\+基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近刚开始学习git，总结一下git的各个命令，方便以后查阅。<br>学习环境：windows10<br> <strong>参考链接：</strong></p><blockquote><ul><li>Pro Git（中文版）<a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">http://git.oschina.net/progit/</a></li><li>沉浸式学 Git<a href="http://igit.linuxtoy.org/contents.html" target="_blank" rel="noopener">http://igit.linuxtoy.org/contents.html</a></li></ul></blockquote><h2 id="1-git的安装及初始配置"><a href="#1-git的安装及初始配置" class="headerlink" title="1. git的安装及初始配置"></a><strong>1. git的安装及初始配置</strong></h2><h3 id="1-1-git-安装"><a href="#1-1-git-安装" class="headerlink" title="1.1 git 安装"></a><strong>1.1 git 安装</strong></h3><p>&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： <a href="http://msysgit.github.com/" target="_blank" rel="noopener">http://msysgit.github.com/</a>   </p><h3 id="1-2-git-初始化配置"><a href="#1-2-git-初始化配置" class="headerlink" title="1.2 git 初始化配置"></a><strong>1.2 git 初始化配置</strong></h3><p>&emsp; &emsp; 1.2.1&emsp;配置用户名和户邮箱：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   git<span class="built_in"> config </span>--global user.name <span class="string">"deng wen"</span> </span><br><span class="line">git<span class="built_in"> config </span>--global user.email 156XXXXXXX@163.com</span><br></pre></td></tr></table></figure></p><p>&emsp; &emsp; 1.2.2&emsp;查看初始配置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--list</span><br></pre></td></tr></table></figure></p><h2 id="2-git的基础命令"><a href="#2-git的基础命令" class="headerlink" title="2.git的基础命令"></a><strong>2.git的基础命令</strong></h2><h3 id="2-1-新建仓库"><a href="#2-1-新建仓库" class="headerlink" title="2.1 新建仓库"></a><strong>2.1 新建仓库</strong></h3><p>&emsp; Git 新建项目仓库的方法有两种。分别为：<br>&emsp; &emsp;  2.1.1&emsp; 第一种：在现存的目录下，用如下命令得到一个.git仓库目录，资源对应添加到其中：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure></p><p>&emsp; &emsp;  2.1.2&emsp; 第二种：从已有的 Git 仓库克隆出一个新的镜像仓库来。[URL]       如：<a href="http://uestclab307.kmdns.net:808/dengwen/SAIC_SecMonitor.git，mygitname可省略：" target="_blank" rel="noopener">http://uestclab307.kmdns.net:808/dengwen/SAIC_SecMonitor.git，mygitname可省略：</a><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">[URL</span>] mygitname</span><br></pre></td></tr></table></figure></p><h3 id="2-2-文件基本处理"><a href="#2-2-文件基本处理" class="headerlink" title="2.2 文件基本处理"></a><strong>2.2 文件基本处理</strong></h3><p>&emsp; &emsp;  2.2.1&emsp;检查当前文件状态：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    git status</span><br><span class="line">``` </span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 将新文件或更新文件加入跟踪：</span><br></pre></td></tr></table></figure></p><pre><code>git add  filenamegit add  —A //将所有新文件一次加入跟踪git checkout -- filename // 对所做的更改进行忽略git reset HEAD filename //撤销加入跟踪的文件 </code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.3</span><span class="variable">&amp;emsp</span>; 文件提交：</span><br></pre></td></tr></table></figure><pre><code>git commit  —m  &quot;your comment&quot; //-m表示注释git commit --amend //撤销刚做的提交git commit  —a  //所有跟踪文件一次提交</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.4</span><span class="variable">&amp;emsp</span>; 删除文件：</span><br></pre></td></tr></table></figure><pre><code>git rm --cached filename //跟踪目录删除、本地不删除git rm -f filename //跟踪目录、本地目录皆删除：</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.5</span><span class="variable">&amp;emsp</span>; 在仓库中移动文件：</span><br></pre></td></tr></table></figure><pre><code>git mv file_from file_to</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.6</span><span class="variable">&amp;emsp</span>; 查看提交历史，- -pretty按固定格式显示,--graph 选项用 ASCII 字符串形象地展示了每个提交所在的分支及其分化衍合情况：</span><br></pre></td></tr></table></figure><pre><code>git loggit log --pretty=format:&quot;%h - %an, %ar : %s&quot;git log --pretty=format:&quot;%h %s&quot; --graph</code></pre><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;**选项 说明**</span><br><span class="line"><span class="tag">    %<span class="selector-tag">H</span></span> 提交对象（commit）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">h</span></span> 提交对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">T</span></span> 树对象（tree）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">t</span></span> 树对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">P</span></span> 父对象（parent）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">p</span></span> 父对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">an</span></span> 作者（author）的名字</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ae</span></span> 作者的电子邮件地址</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ad</span></span> 作者修订日期（可以用 -date= 选项定制格式）</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ar</span></span> 作者修订日期，按多久以前的方式显示</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cn</span></span> 提交者(committer)的名字</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ce</span></span> 提交者的电子邮件地址</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cd</span></span> 提交日期</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cr</span></span> 提交日期，按多久以前的方式显示</span><br><span class="line"><span class="tag">    %<span class="selector-tag">s</span></span> 提交说明</span><br><span class="line">    </span><br><span class="line">### **2.3 远程仓库的使用**</span><br><span class="line"> &amp;emsp; &amp;emsp;  2.3.1&amp;emsp; 查看当前的远程库,-v 选项显示对应的克隆地址：</span><br></pre></td></tr></table></figure><pre><code>git remote //查看当前仓库对应的远程库,一般为origingit remote -v //查看当前仓库对应的远程库及相应地址</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.3</span><span class="number">.2</span><span class="variable">&amp;emsp</span>;远程仓库处理：</span><br></pre></td></tr></table></figure><pre><code>git remote add yourname [url] //yourname是你的本地仓库名，相当于赋值yourname为URLgit fetch yourname  //从远程仓库抓取数据到本地，到如果要查看需要合并到当前分支git remote show [remote-name] //查看远程仓库信息，如显示了有哪些远端分支还没有同步到本地等git remote rename old-name new-name //重命名git remote rm paul //删除</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **2.4 标签**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.4</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 新建标签：</span><br></pre></td></tr></table></figure><pre><code>git tag //查看已有标签git tag -a yourtagname -m &apos;your comment&apos; //打标签git show yourtagname //查看版本信息 git tag -a yourtagname hist //后期加标签,hist表校验和</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.4</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 标签远程共享：</span><br></pre></td></tr></table></figure><pre><code>git push origin yourtagname //推送标签git push origin --tags //推送所有标签</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **2.5 Git 命令别名**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.5</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 简写git命令：</span><br></pre></td></tr></table></figure><pre><code>git config --global alias.shortname gitcommandname eg: git config --global alias.unstage &apos;reset HEAD&apos;    git unstage filename //撤销加入跟踪的文件 </code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **<span class="number">3.</span>git分支处理**</span><br><span class="line">### **<span class="number">3.1</span> Git 查看分支**</span><br><span class="line"> &amp;emsp; &amp;emsp;  <span class="number">3.1</span><span class="number">.1</span>&amp;emsp; 查看分支：</span><br></pre></td></tr></table></figure><pre><code>git branch git branch -a //查看所有分支，包括远程分支git branch -v //查看分支最后一个提交对象的信息git branch --merged/--no--merge //查看已经（或尚未）合并的分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **3.2 Git 分支切换、合并和删除**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 切换分支：</span><br></pre></td></tr></table></figure><pre><code>git branch branchname  //在当前分支下创建分支git checkout branchname //切换到已有的分支git checkout -b &apos;branchname&apos; //创建分支并切换</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 合并分支：</span><br></pre></td></tr></table></figure><pre><code>git merge branchname //将分支合并到当前分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.3</span><span class="variable">&amp;emsp</span>; 删除分支：</span><br></pre></td></tr></table></figure><pre><code>git branch -d branchname  //删除分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **3.3 Git 远程分支处理**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.1</span><span class="variable">&amp;emsp</span>;跟踪远程分支：</span><br></pre></td></tr></table></figure><pre><code>git checkout -b [分支名] [远程仓库名]/[分支名]  //跟踪分支是一种和某个远程分支有直接联系的本地分支git pull  //新建跟踪分支后用该命令直接将远程分支合并进来git push  //将本地跟踪分支推送到远程分支git push --set-upstream [远程仓库名] [分支名]  //将当前的分支设置为跟踪某个远程分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.2</span><span class="variable">&amp;emsp</span>;抓取和合并远程分支：</span><br></pre></td></tr></table></figure><pre><code>git fetch origin  //同步远程origin/master数据到本地，指针移到它最新的位置上。git merge origin/remotename  //将远程分支的内容合并到当前分支，用于远程分支已同步而又不能直接访问时。</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.3</span><span class="variable">&amp;emsp</span>;推送分支和删除远程分支：</span><br></pre></td></tr></table></figure><pre><code>git push origin name1:name2  //把本地分支name1推送到远程分支name2中，如果远程仓库没有这个分支，会生成这样一个新的分支。用这种方式可以远程创建分支。  git push origin name //将本地分支推到远程同名分支。git push origin :remotename //把空白远程远程分支，即删除远程分支。</code></pre><p><code>`</code></p><p><br><br><br></p><p><strong><em>这些就是基本的git命令，更多待进一步学习</em></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93%E5%B4%A9%E6%BA%83%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/"/>
      <url>/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93%E5%B4%A9%E6%BA%83%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="解决git仓库崩溃问题"><a href="#解决git仓库崩溃问题" class="headerlink" title="解决git仓库崩溃问题"></a>解决git仓库崩溃问题</h1><hr><blockquote><p>不知道是不是虚拟机的问题，最近修改代码后git仓库总崩溃，导致的结果就是很多时候自己刚修改的代码不得不放弃，最近找到一种比较好的解决方式，链接如下：<a href="https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty" target="_blank" rel="noopener">https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty</a></p></blockquote><h3 id="1-git仓库崩溃表现"><a href="#1-git仓库崩溃表现" class="headerlink" title="1.git仓库崩溃表现"></a>1.git仓库崩溃表现</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dengwen@ubuntu:~/project_DW/selog$ git status</span><br><span class="line"><span class="keyword">error: </span>object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is empty</span><br><span class="line"><span class="keyword">error: </span>object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is empty</span><br><span class="line">fatal: loose object a9761932a220991b0490c2715f218f814d39b876 (stored in .git/objects/a9/761932a220991b0490c2715f218f814d39b876) is corrupt</span><br></pre></td></tr></table></figure><h3 id="2-常规解决方案"><a href="#2-常规解决方案" class="headerlink" title="2.常规解决方案"></a>2.常规解决方案</h3><p>git仓库崩溃后，常规的解决方案是在其他目录git clone之前版本的项目，然后将<br>当前版本的项目拷贝过去进行覆盖，再进行提交，但是这样做的结果就是可能会丢失部分git commit信息，除此之外基本没什么问题。</p><h3 id="3-推荐方法"><a href="#3-推荐方法" class="headerlink" title="3.推荐方法"></a>3.推荐方法</h3><p>这种方法的好处在于可以恢复git log信息，同时也不用重新clone项目、切换分支、替换等操作，相对来说，git管理的完整度和效率会更高，具体步骤如下：</p><ul><li><p>（1）删除全部空文件: <strong>注意在.git目录下进行</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="title">@ubuntu</span>:~/project_DW/selog/.git$ find . -<span class="keyword">type</span> f -empty -delete -print</span><br><span class="line">./objects/<span class="number">0</span>d/e<span class="number">32</span>d<span class="number">3</span>b<span class="number">8</span>d<span class="number">0399414</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">8</span>fc<span class="number">47</span>a<span class="number">56069e9821615</span>a</span><br><span class="line">./objects/<span class="number">14</span>/<span class="number">540</span>f<span class="number">9</span>dda<span class="number">3</span><span class="keyword">c</span><span class="number">30044e2</span>dbe<span class="number">4629</span>d<span class="number">22</span><span class="keyword">c</span><span class="number">715145</span>f<span class="number">212</span></span><br><span class="line">./objects/<span class="number">19</span>/b<span class="number">98</span><span class="keyword">c</span><span class="number">74</span>bc<span class="number">6</span><span class="keyword">c</span><span class="number">2e372887</span>af<span class="number">410301</span>a<span class="number">0</span>a<span class="number">80495725</span><span class="keyword">c</span></span><br><span class="line">./objects/<span class="number">55</span>/<span class="number">14</span>f<span class="number">9022e0</span>e<span class="number">39</span>a<span class="number">29</span>d<span class="number">0e25</span>cdf<span class="number">15</span>cecac<span class="number">1</span>f<span class="number">2</span>f<span class="number">479</span><span class="keyword">c</span></span><br><span class="line">./objects/<span class="number">84</span>/<span class="number">0103</span>bdd<span class="number">9538473</span>baab<span class="number">19520</span>eda<span class="number">11</span>b<span class="number">88</span>b<span class="number">40</span><span class="keyword">c</span><span class="number">953</span></span><br><span class="line">./FETCH_HEAD</span><br></pre></td></tr></table></figure></li><li><p>（2）获取最后两条reflog：注意自己要恢复的分支，此处为develop</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>tail -n <span class="number">2</span> .git/logs/refs/heads/develop</span><br><span class="line"><span class="number">41867</span>ca4ab8d60979e804ee7f4640a2e9231d96b f815821a9c4e4833be898dace675916f3cad0124 dengwen &lt;<span class="number">15680482464</span><span class="variable">@163</span>.com&gt; <span class="number">1539335482</span> +080<span class="number">0</span>        <span class="symbol">commit:</span> add manage</span><br></pre></td></tr></table></figure></li><li><p>（3）恢复对应的日志<br>由上一步我们知道最新的日志节点为f815821a9c4e4833be898dace675916f3cad0124，我们可以查看这个节点的信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>git show f815821a9c4e4833be898dace675916f3cad0124</span><br><span class="line">commit f815821a9c4e4833be898dace675916f3cad0124</span><br><span class="line"><span class="symbol">Author:</span> dengwen &lt;<span class="number">15680482464</span><span class="variable">@163</span>.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Fri Oct <span class="number">12</span> <span class="number">17</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">22</span> <span class="number">2018</span> +080<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    add manage</span><br></pre></td></tr></table></figure></li></ul><p>接下来要做的就是恢复日志,同样，需要注意分支和日志节点。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>git update-ref develop f815821a9c4e4833be898dace675916f3cad0124</span><br></pre></td></tr></table></figure></p><ul><li>（4）提交最新的git log<br>执行上述步骤后，用git status可以查看仓库的状态了，也就意味着git仓库恢复成功了。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E4%B9%8B%E7%94%9F%E6%88%90ssh%20key/"/>
      <url>/2019/05/16/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%8E%B7/git%E4%B9%8B%E7%94%9F%E6%88%90ssh%20key/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-中的SSH-key的生成"><a href="#Git-中的SSH-key的生成" class="headerlink" title="Git 中的SSH key的生成"></a><strong>Git 中的SSH key的生成</strong></h2><h4 id="1-1-emsp-安装git："><a href="#1-1-emsp-安装git：" class="headerlink" title="1.1&emsp;安装git："></a>1.1&emsp;安装git：</h4><p>&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： <a href="http://msysgit.github.com/" target="_blank" rel="noopener">http://msysgit.github.com/</a> </p><h4 id="1-2-emsp-查看是否经有SSH-key："><a href="#1-2-emsp-查看是否经有SSH-key：" class="headerlink" title="1.2&emsp;查看是否经有SSH key："></a>1.2&emsp;查看是否经有SSH key：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa<span class="selector-class">.pub</span> <span class="comment">//git bash中输入这个命令</span></span><br></pre></td></tr></table></figure><h4 id="1-3-emsp-生成SSH-key："><a href="#1-3-emsp-生成SSH-key：" class="headerlink" title="1.3&emsp;生成SSH key："></a>1.3&emsp;生成SSH key：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your.email@example.com"</span> -<span class="selector-tag">b</span> <span class="number">4096</span> <span class="comment">//git bash中输入这个命令，修改对应的邮箱</span></span><br></pre></td></tr></table></figure><p>  <strong><em>如果已经存在SSH key,则直接复制即可，否则需要重新生成。</em></strong><br>  <strong><em>生成SSH key时需要设置对应的文件存放路径和密码，为了方便，直接回车默认即可。</em></strong>   </p><h4 id="1-3-emsp-查看生成的SSH-key，复制到git中即可："><a href="#1-3-emsp-查看生成的SSH-key，复制到git中即可：" class="headerlink" title="1.3&emsp;查看生成的SSH key，复制到git中即可："></a>1.3&emsp;查看生成的SSH key，复制到git中即可：</h4>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xclip -sel <span class="keyword">clip</span> &lt; ~/.ssh/id_rsa.pub <span class="comment">//GNU/Linux (requires the xclip package)</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub | <span class="keyword">clip</span> <span class="comment">//Git Bash on Windows / Windows PowerShell</span></span><br><span class="line">type %userprofile%\.ssh\id_rsa.pub | <span class="keyword">clip</span> <span class="comment">//Windows Command Line</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/1.%E4%BF%9D%E5%8D%AB%E6%96%B9%E6%A1%88/"/>
      <url>/2019/05/16/1.%E4%BF%9D%E5%8D%AB%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="保卫方案"><a href="#保卫方案" class="headerlink" title="保卫方案"></a>保卫方案</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/e1967ae812ea42e7a3ce57ee1f83b686?tpId=85&amp;tqId=29878&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/e1967ae812ea42e7a3ce57ee1f83b686?tpId=85&amp;tqId=29878&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>输入中有多组测试数据，每一组测试数据的第一行为一个整数n(3&lt;=n&lt;=10^6),为首都周围的小山数量，第二行为n个整数，依次表示为小山的高度h（1&lt;=h&lt;=10^9）.</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>这个题想了好长时间，但是一直没想出来怎么做，参考了大神的解体思路后，总算想清楚了，原链接如下：<a href="http://www.cnblogs.com/mengmz/p/7263915.html。" target="_blank" rel="noopener">http://www.cnblogs.com/mengmz/p/7263915.html。</a></p><p>分析题目可知，对于山峰a,如果能在它的左边和右边分别找到最近且比它大的b和c，那么b能看到a，a能看到c，即整体计数对应加2。那么题目可以分为如下两种情况进行讨论：  </p><ul><li>对于数组中无重复数字出现的情况，在构成环的全部元素当中，最大值和次大值只有一边存在比它大的数，但能彼此看到，故计数值加1。除了这两个元素外，剩下的n-2个元素都能在左边和右边分别找到比它大的数，故计数值加（n-1）<em>2。即总的结果为：1+（n-2）</em>2。      </li><li>对于有重复数字出现的情况，假设有一组序列为a,a,b,b,b,c,c且a&gt;b,c&gt;b。a,b,c分别出现的次数为2,3,2，b各元素能互相看见，故b自身能构成的组合数为：c(3,2)=3<em>(3-2)/2。同时所有的b都能看到最后一个a和第一个c，所以计数值加3+3。如果用N1,N2,N3分别表示a,b,c出现的话，则总的结果为：c(N2,2)+2</em>N2;</li></ul><p>分析完两种情况后，现在我们需要求出每一个数和两边大于这个数的情况，采用单调栈来解决，具体求解过程如下: </p><ul><li>（1）读取所有数据，放入数组V，计数值count=0。</li><li>（2）新建数组P，遍历数组V，将V中的元素消除重复后放入P中，并记录下每个元素重复的次数。同时找出最大的元素max和其在P中下标max_i。</li><li>（3）创建堆栈S，然后从max_i开始遍历所有P中元素。进行如下操作：<blockquote><ul><li>若堆栈为空， 将P[i]直接压入堆栈；   </li><li>若堆栈为非空，将P[i]与栈顶元素进行比较，如果大于栈顶元素，count加上栈顶元素的组合数（重复数N,组合数为c(N,2)+N,注意此时只考虑栈顶元素和P[i]的组合数），然后弹出栈顶元素，若栈不为空，则弹出的数和栈顶数也有组合数，count加弹出数的重复数N，执行本步骤一直弹出直到P[i]小于栈顶元素；</li><li>若等于栈顶元素，栈顶元素的重复数+P[i]的重复数，继续执行；</li><li>若小于栈顶元素，直接压入；</li></ul></blockquote></li><li>(4)上个步骤结束后，得到一个递减的堆栈。依次弹出栈顶元素到temp，直到堆栈为空，count加上其组合数目,这个时候要考虑以下情况：<blockquote><ul><li>堆栈中剩余元素个数多于1,则temp的组合数为c(N,2)+N*2。   </li><li>堆栈中的剩余元素个数为1，若剩余元素的重复次数n大于1，则temp的组合数为c(N,2)+N*2（如4,4,3,3,3序列，所有的3能看到第一个4和最后一个4）；若剩余的重复次数为1，则temp的组合数为c(N,2)+N（如4,3,3,3序列）</li><li>堆栈中的剩余元素个数为0，此时temp为最大值，组合数跟其重复次数N有关,为c(N,2)；   </li></ul></blockquote></li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用结构体来保存每个山峰的高度，和重复的次数</span></span><br><span class="line">struct node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    long <span class="built_in">count</span>;</span><br><span class="line">    node(int v,int c=<span class="number">1</span>): val(v),<span class="built_in">count</span>(c)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,value,i,<span class="built_in">max</span>,max_i;</span><br><span class="line">    long <span class="built_in">count</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; mountin(n);</span><br><span class="line">    vector&lt;node&gt; mnode;<span class="comment">//去重和计数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;mountin[i];<span class="comment">//依次获取每个山峰的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node temp(mountin[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">max</span>=mountin[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//去重和寻找最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mountin[i]==temp.val)<span class="comment">//若重复</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">count</span>++;<span class="comment">//计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            mnode.push_back(temp);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span>&lt;temp.val)<span class="comment">//获取最大峰值和对应下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span>=temp.val;</span><br><span class="line">                max_i=mnode.<span class="built_in">size</span>()-<span class="number">1</span>;<span class="comment">//注意，这里获取的去重后的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp.val=mountin[i];</span><br><span class="line">            temp.<span class="built_in">count</span>=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mnode.push_back(temp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>&lt;temp.val)<span class="comment">//获取最大峰值和对应下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">max</span>=temp.val;</span><br><span class="line">        max_i=mnode.<span class="built_in">size</span>()-<span class="number">1</span>;<span class="comment">//注意，这里获取的去重后的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;node&gt; s;</span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=max_i;n&lt;mnode.<span class="built_in">size</span>();++n,i=(i+<span class="number">1</span>)%mnode.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; mnode[i].val&gt;s.top().val)</span><br><span class="line">        &#123;   <span class="comment">//数组元素大于栈顶元素的情况</span></span><br><span class="line">            temp.val=s.top().val;</span><br><span class="line">            temp.<span class="built_in">count</span>=s.top().<span class="built_in">count</span>;</span><br><span class="line">            <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+temp.<span class="built_in">count</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) <span class="built_in">count</span>+=temp.<span class="built_in">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组元素小于栈顶元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty()||mnode[i].val&lt;s.top().val) s.push(mnode[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//数组元素等于栈顶元素的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.top().<span class="built_in">count</span>+=mnode[i].<span class="built_in">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对最后的递减栈进行求解</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp.val=s.top().val;</span><br><span class="line">        temp.<span class="built_in">count</span>=s.top().<span class="built_in">count</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>)  <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>*temp.<span class="built_in">count</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//堆栈中还剩一个值的情况</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(s.top().<span class="built_in">count</span>==<span class="number">1</span>) <span class="comment">//如4，3，3，3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+temp.<span class="built_in">count</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如4,4，3，3，3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>*temp.<span class="built_in">count</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">count</span>&lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><ul><li>解题的时候还是需要学会将大问题化解之后进行分析，分情况不断讨论，然后也就能分而解之，水到渠成。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/3.%E5%AD%97%E5%85%B8%E5%BA%8F/"/>
      <url>/2019/05/16/3.%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/6c9d8d2e426c4c58bbadfdf67d591696?tpId=85&amp;&amp;tqId=29877&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6c9d8d2e426c4c58bbadfdf67d591696?tpId=85&amp;&amp;tqId=29877&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。<br>对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.<br>对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>输入仅包含两个整数n和m。<br>数据范围:<br>对于20%的数据, 1 &lt;= m &lt;= n &lt;= 5 ;<br>对于80%的数据, 1 &lt;= m &lt;= n &lt;= 10^7 ;<br>对于100%的数据, 1 &lt;= m &lt;= n &lt;= 10^18.</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>输出仅包括一行, 即所求排列中的第m个数字.</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">11 </span><span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>参考链接：<a href="https://www.nowcoder.com/questionTerminal/fc05f68c5f47438db54c6923ef23cf4a。" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/fc05f68c5f47438db54c6923ef23cf4a。</a>   </p><p>在具备字典树相关知识的基础上，不难想象如下字典树：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">10</span></span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">11</span></span><br><span class="line"><span class="number">1</span>--&gt;...</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">19</span></span><br><span class="line"><span class="number">2</span>--&gt;<span class="number">20</span></span><br><span class="line"><span class="number">2</span>--&gt;<span class="number">21</span></span><br><span class="line"><span class="number">2</span>--&gt;....</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">100</span></span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">101</span></span><br><span class="line"><span class="number">10</span>--&gt;.....</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">109</span></span><br></pre></td></tr></table></figure></p><p>由上图可知，需要计算每个节点所对应的子节点数，节点数就是上级节点<em>10，可知总的节点数= 1 + （1 </em> 10） + （1 <em> 10 </em> 10） + （1 <em> 10  </em> 10 * 10） +……，需要注意的是，节点的值必须小于等于n，所以大于n的值是必须去掉的。</p><p>具体求解过程如下: </p><ul><li>（1）记所求的第m个数为value=1，从start=value查找，end=value+1最为边界，m等于0时结束，value即为所求值。</li><li>（2）求start的子节点中值在n以内的子节点个数，记为count。</li><li>（3）比较count和m的大小：<blockquote><ul><li>若count&gt;m,则所求值在value的子节点中，value=value*10,m–；   </li><li>若count&lt;=m,则所求的值不在value的子节点中，value=value+1,m=m-count;</li><li>回到第一步继续求值</li></ul></blockquote></li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    long m,n,start,<span class="keyword">end</span>,<span class="keyword">value</span>=<span class="number">1</span>,<span class="built_in">count</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    m--;//默认把当前点算入进来</span><br><span class="line">    <span class="keyword">while</span>(m<span class="comment">!=0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        start=<span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">end</span>=<span class="keyword">value</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">count</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=n)//求出当前<span class="keyword">value</span>的子树数</span><br><span class="line">        &#123;</span><br><span class="line">            //求出当前一层，能算入的子树数目</span><br><span class="line">            <span class="built_in">count</span>+=((n+<span class="number">1</span>)&gt;<span class="keyword">end</span>?<span class="keyword">end</span>:(n+<span class="number">1</span>))-start;</span><br><span class="line">            start=start*<span class="number">10</span>;//进入下一层</span><br><span class="line">            <span class="keyword">end</span>=<span class="keyword">end</span>*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">count</span>&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            //当前<span class="keyword">value</span>的子树数目大于m，所求节点在<span class="keyword">value</span>的子树中</span><br><span class="line">            <span class="keyword">value</span>=<span class="keyword">value</span>*<span class="number">10</span>;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            //当前<span class="keyword">value</span>的子树数目小于m,进入<span class="keyword">value</span>+<span class="number">1</span>继续寻找其子树</span><br><span class="line">            m=m-<span class="built_in">count</span>;</span><br><span class="line">            <span class="keyword">value</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="keyword">value</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><ul><li>代码不长，除了具备相应知识外，能静下心来慢慢理清思路并实现也是一种能力。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/16/2.%E5%BC%82%E6%88%96/"/>
      <url>/2019/05/16/2.%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/fc05f68c5f47438db54c6923ef23cf4a?tpId=85&amp;&amp;tqId=29876&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fc05f68c5f47438db54c6923ef23cf4a?tpId=85&amp;&amp;tqId=29876&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>第一行包含两个整数n,m.<br>第二行给出n个整数A1，A2，…，An。<br>数据范围:<br>对于30%的数据，1 &lt;= n, m &lt;= 1000<br>对于100%的数据，1 &lt;= n, m, Ai &lt;= 10^5</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>输出仅包括一行，即所求的答案</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">10</span>  </span><br><span class="line"><span class="symbol">6 </span><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>参考链接：<a href="https://blog.csdn.net/qq_30507287/article/details/68947863。" target="_blank" rel="noopener">https://blog.csdn.net/qq_30507287/article/details/68947863。</a></p><p>考虑用字典树来解决该题，用示例中6、5、10来构建一颗如下字典树(虚线表示不用)：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">root--&gt;<span class="number">0</span></span><br><span class="line">root--&gt;<span class="number">1</span></span><br><span class="line"><span class="number">0</span>-.-&gt;<span class="number">00</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span>--&gt;<span class="number">01</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">01</span>--&gt;<span class="number">010</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">01</span>--&gt;<span class="number">011</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">011</span>--&gt;<span class="number">0110</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">011</span>-.-&gt;<span class="number">0111</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">010</span>-.-&gt;<span class="number">0100</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">010</span>--&gt;<span class="number">0101</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">10</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span>-.-&gt;<span class="number">11</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">10</span>-.-&gt;<span class="number">100</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">101</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">101</span>--&gt;<span class="number">1000</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">101</span>-.-&gt;<span class="number">1001</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>从已有的数据中选一个数记为a，遍历该字典树（二叉树）,求所有与a异或大于m的数的个数，分情况讨论：</p><ul><li>如果a的当前位为0，m的当前位为0，那么明显父节点的右子树的所有数与a异或都大于m；但左子树不能确定，需要继续查询。</li><li>如果a的当前位为1，m的当前位为0，那么明显父节点的左子树的所有数与a异或都大于m；但右子树不能确定，需要继续查询。</li><li>如果a的当前位为0，m的当前位为1，那么明显父节点的左子树中的数和a异或一定小于m，查询结束；右子树的数不能确定，需要继续查询。</li><li>如果a的当前位为1，m的当前位为1，那么明显父节点的右子树中的数和a异或一定小于m，查询结束；左子树的数不能确定，需要继续查询。</li></ul><p>具体求解过程如下: </p><ul><li>（1）依次读取n,m,将n个数依次放入数组并且构建对应的字典树。</li><li>（2）获取获取数组中的数，查询字典树，计算与其异或值大于m的数的个数。</li><li>（3）得到的count除2，因为如果a\^b大于m,那么b\^a也会大于m。</li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">*@bref:暴力求解，好像是可以通过<span class="number">80</span><span class="comment">%，果然暴力还是不行</span></span><br><span class="line">*</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,<span class="built_in">i</span>,<span class="built_in">j</span>,result,count=<span class="number">0</span>,*value;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    value=new int[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;value[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n<span class="number">-1</span>;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="built_in">i</span>+<span class="number">1</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            result=value[<span class="built_in">i</span>]^value[<span class="built_in">j</span>];</span><br><span class="line">            <span class="keyword">if</span>(result&gt;m) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>能通过的解法：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @bref:参考了大神们的思路，服气</span></span><br><span class="line"><span class="comment">*       了解字典树之后，理解这个题的解法就好多了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义字典树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trieTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> num;</span><br><span class="line">      trieTree *son[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      trieTree(<span class="keyword">int</span> num) </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;num=num;</span><br><span class="line">          son[<span class="number">0</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">          son[<span class="number">1</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a,trieTree *current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入每一个节点，17位所能表示的最大值位131071</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        foo=(a&gt;&gt;i)&amp;<span class="number">1</span>;<span class="comment">//获取对应的位</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[foo] == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            current-&gt;son[foo]=<span class="keyword">new</span> trieTree(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        current=current-&gt;son[foo];</span><br><span class="line">        current-&gt;num++;<span class="comment">//记数加1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询结果</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(trieTree *root,<span class="keyword">int</span> a,<span class="keyword">int</span> m,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    trieTree *current=root; </span><br><span class="line">    <span class="keyword">int</span> aDigit=(a&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mDigit=(m&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(aDigit==<span class="number">0</span> &amp;&amp; mDigit==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=(current-&gt;son[<span class="number">1</span>]==<span class="literal">nullptr</span>? <span class="number">0</span>:current-&gt;son[<span class="number">1</span>]-&gt;num);</span><br><span class="line">        <span class="keyword">int</span> q=query(current-&gt;son[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> p+q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">1</span> &amp;&amp; mDigit==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=(current-&gt;son[<span class="number">0</span>]==<span class="literal">nullptr</span>? <span class="number">0</span>:current-&gt;son[<span class="number">0</span>]-&gt;num);</span><br><span class="line">        <span class="keyword">int</span> p=query(current-&gt;son[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> p+q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">0</span> &amp;&amp; mDigit==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[<span class="number">1</span>]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(current-&gt;son[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">1</span> &amp;&amp; mDigit==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[<span class="number">0</span>]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(current-&gt;son[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,*data;</span><br><span class="line">    <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function">trieTree <span class="title">root</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    data=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        insert(data[i],&amp;root);<span class="comment">//将所有的数</span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count+=query(&amp;root,data[i],m,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><p>这种题目的第一思路是暴力求解，虽然很大概率是不行的，但不妨一试，能想出合理高效的求解方案不是每一个人都能做到的，问题的抽象能力、联想能力往往是解题的关键，常备知识，遇到问题才能直击痛点，庖丁解牛。<br><strong>在写这个题的时候，我自己实现了代码，但是感觉完全没问题，然后提交之后一直只通过80%，我后来花了将近两天的时间近乎一直在想这个题，最后突然灵光发现是用来存结果的count值是int型，而实际结果要大于int型所能表示的范围。真的服气…….我发誓以后存结果的数一定用long。</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
