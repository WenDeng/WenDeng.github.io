<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>必须掌握的面试问题系列（一）数据库（转）</title>
      <link href="/2019/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>本文主要是总结了一下常见的数据库问题，主要是对之前的知识进行回顾和复习。<br><a id="more"></a></p><h4 id="一、为什么用自增列作为主键？"><a href="#一、为什么用自增列作为主键？" class="headerlink" title="一、为什么用自增列作为主键？"></a>一、为什么用自增列作为主键？</h4><p>1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为<strong>聚集索引</strong>。如果没有显式定义主键，则InnoDB会选择第一个<strong>不包含有NULL值的唯一索引</strong>作为主键索引。</p><p>如果也没有这样的唯一索引，则InnoDB会选择<strong>内置6字节长的ROWID作为隐含的聚集索引</strong>，并随着行记录的写入而递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的。</p><p>2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>4、如果使用<strong>非自增主键</strong>（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h4 id="二、为什么使用数据索引能提高效率？"><a href="#二、为什么使用数据索引能提高效率？" class="headerlink" title="二、为什么使用数据索引能提高效率？"></a>二、为什么使用数据索引能提高效率？</h4><p>数据索引的存储是有序的，在有序的情况下，通过索引查询一个数据是无需遍历索引记录的。极端情况下，数据索引的查询效率为二分法查询效率，趋近于log2(N)。</p><h4 id="三、B-树索引和哈希索引的区别"><a href="#三、B-树索引和哈希索引的区别" class="headerlink" title="三、B+树索引和哈希索引的区别"></a>三、B+树索引和哈希索引的区别</h4><p><strong>B+树</strong>是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的。</p><p><strong>哈希索引</strong>就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的。</p><h4 id="四、哈希索引的优势："><a href="#四、哈希索引的优势：" class="headerlink" title="四、哈希索引的优势："></a>四、哈希索引的优势：</h4><p>等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p><h4 id="五、哈希索引不适用的场景："><a href="#五、哈希索引不适用的场景：" class="headerlink" title="五、哈希索引不适用的场景："></a>五、哈希索引不适用的场景：</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li></ul><p>通常，B+树索引结构适用于绝大多数场景，没有范围查询、没有排序的时候，特别适合采用哈希索引。</p><h6 id="仅等值查询"><a href="#仅等值查询" class="headerlink" title="仅等值查询"></a>仅等值查询</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'李明'</span>;</span><br></pre></td></tr></table></figure><p>而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。<strong>如果认为建立哈希索引可以提高查询效率</strong>，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</p><p>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p><p>注意：<strong>在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销</strong>。</p><p>但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</p><h4 id="六、B树和B-树的区别"><a href="#六、B树和B-树的区别" class="headerlink" title="六、B树和B+树的区别"></a>六、B树和B+树的区别</h4><p>1、B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p><p>2、B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。</p><h4 id="七、为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#七、为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="七、为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>七、为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h4><ul><li><p>（1）B+的磁盘读写代价更低。<br>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。<br>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p></li><li><p>（2）B+-tree的查询效率更加稳定。<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></li></ul><h4 id="八、MySQL联合索引"><a href="#八、MySQL联合索引" class="headerlink" title="八、MySQL联合索引"></a>八、MySQL联合索引</h4><ul><li><p>（1）联合索引是两个或更多个列上的索引。<br>对于联合索引: Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p></li><li><p>（2）利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</p></li></ul><p>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</p><h4 id="九、什么情况下应不建或少建索引？"><a href="#九、什么情况下应不建或少建索引？" class="headerlink" title="九、什么情况下应不建或少建索引？"></a>九、什么情况下应不建或少建索引？</h4><ul><li>1、表记录太少</li><li>2、经常插入、删除、修改的表</li><li>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>4、经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h4 id="十、什么是表分区？"><a href="#十、什么是表分区？" class="headerlink" title="十、什么是表分区？"></a>十、什么是表分区？</h4><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><h4 id="十一、表分区与分表的区别"><a href="#十一、表分区与分表的区别" class="headerlink" title="十一、表分区与分表的区别"></a>十一、表分区与分表的区别</h4><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p><p><strong>分表与分区的区别在于</strong>：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><h4 id="十二、表分区有什么好处？"><a href="#十二、表分区有什么好处？" class="headerlink" title="十二、表分区有什么好处？"></a>十二、表分区有什么好处？</h4><ul><li>1、存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据。</li><li>2、优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li>3、分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li><li>4、避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li></ul><h4 id="十三、分区表的限制因素"><a href="#十三、分区表的限制因素" class="headerlink" title="十三、分区表的限制因素"></a>十三、分区表的限制因素</h4><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h4 id="十四、如何判断当前MySQL是否支持分区？"><a href="#十四、如何判断当前MySQL是否支持分区？" class="headerlink" title="十四、如何判断当前MySQL是否支持分区？"></a>十四、如何判断当前MySQL是否支持分区？</h4><p>命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%partition%'</span></span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%partition%';</span><br><span class="line">+-------------------+-------+| <span class="type">Variable_name</span> | <span class="type">Value</span> |<span class="type">+-------------------+-------+| have_partitioning</span> | <span class="type">YES</span> |<span class="type">+-------------------+-------+1</span> row <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>have_partintioning 的值为YES，表示支持分区。</p><h4 id="十五、MySQL支持的分区类型有哪些？"><a href="#十五、MySQL支持的分区类型有哪些？" class="headerlink" title="十五、MySQL支持的分区类型有哪些？"></a>十五、MySQL支持的分区类型有哪些？</h4><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h4 id="十六、四种隔离级别"><a href="#十六、四种隔离级别" class="headerlink" title="十六、四种隔离级别"></a>十六、四种隔离级别</h4><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><h4 id="十七、关于MVCC，怎么实现的？MVCC有什么用？"><a href="#十七、关于MVCC，怎么实现的？MVCC有什么用？" class="headerlink" title="十七、关于MVCC，怎么实现的？MVCC有什么用？"></a>十七、关于MVCC，怎么实现的？MVCC有什么用？</h4><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) </p><blockquote><p>注：与MVCC相对的，是基于锁的并发控制LBCC，Lock-Based Concurrency Control</p></blockquote><p><strong>MVCC最大的好处</strong>：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p><p>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</p><blockquote><p>其实现主要是通过增加两个隐藏的列，用来记录修改版本号和删除版本号，版本号有数据库支持。</p></blockquote><h4 id="十八、在MVCC并发控制中，读操作可以分成两类："><a href="#十八、在MVCC并发控制中，读操作可以分成两类：" class="headerlink" title="十八、在MVCC并发控制中，读操作可以分成两类："></a>十八、在MVCC并发控制中，读操作可以分成两类：</h4><ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）。</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li></ul><h4 id="十九、行级锁定的优点："><a href="#十九、行级锁定的优点：" class="headerlink" title="十九、行级锁定的优点："></a>十九、行级锁定的优点：</h4><ul><li>1、当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>2、回滚时只有少量的更改</li><li>3、可以长时间锁定单一的行。</li></ul><h4 id="二十、行级锁定的缺点："><a href="#二十、行级锁定的缺点：" class="headerlink" title="二十、行级锁定的缺点："></a>二十、行级锁定的缺点：</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li><strong>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁</strong>。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h4 id="二十一、MySQL优化"><a href="#二十一、MySQL优化" class="headerlink" title="二十一、MySQL优化"></a>二十一、MySQL优化</h4><ul><li><p>开启查询缓存，优化查询<br>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</p><p>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</p></li><li>为搜索字段建索引</li><li><p>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR</p></li><li><p>Prepared StatementsPrepared    Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p><p>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</p></li><li>垂直分表</li><li>选择正确的存储引擎</li></ul><h4 id="二十二、key和index的区别"><a href="#二十二、key和index的区别" class="headerlink" title="二十二、key和index的区别"></a>二十二、key和index的区别</h4><p>key是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</p><p>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</p><h4 id="二十三、Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#二十三、Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="二十三、Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>二十三、Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h4><p>区别：</p><ul><li>（1）InnoDB支持事务，MyISAM不支持<br>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>（2）InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>（3）<strong>InnoDB是聚集索引</strong>，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是<strong>辅助索引</strong>需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。<br>而<strong>MyISAM是非聚集索引</strong>，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>（4）InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>（5）Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul><p>如何选择：</p><ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul><h4 id="二十四、数据库表创建注意事项"><a href="#二十四、数据库表创建注意事项" class="headerlink" title="二十四、数据库表创建注意事项"></a>二十四、数据库表创建注意事项</h4><p>（1）字段名及字段配制合理性   </p><ul><li>剔除关系不密切的字段；   </li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><p>（2）系统特殊字段处理及建成后建议</p><ul><li>添加<strong>删除标记</strong>（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><p>（3）表结构合理性配置</p><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><p>（4）其它建议</p><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础之元编程与constexpr</title>
      <link href="/2019/06/30/c++%E5%9F%BA%E7%A1%80/C++%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8Econstexpr/"/>
      <url>/2019/06/30/c++%E5%9F%BA%E7%A1%80/C++%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8Econstexpr/</url>
      
        <content type="html"><![CDATA[<p><strong>元编程</strong>（metaprogramming）是一个典型的复合词，他由前缀 meta- 和词根 programming 复合而成，有“对一个程序进行编程”的意思。换句话说，编译器先编译你的代码，得到一份新的代码，然后再编译新的代码来解决问题。</p><p>模板元编程技术，即把一些可以在编译时完成的求值计算，通过模板特化的技术绑定到具体的实例化代码上，从而减少不必要的代码量，提升代码的运行效率。</p><a id="more"></a><h2 id="一、C-的元编程"><a href="#一、C-的元编程" class="headerlink" title="一、C++的元编程"></a>一、C++的元编程</h2><h3 id="1-1-为什么要元编程呢？"><a href="#1-1-为什么要元编程呢？" class="headerlink" title="1.1 为什么要元编程呢？"></a>1.1 为什么要元编程呢？</h3><p>前面我们知道了什么是元编程，那么为什么要有这种编写技巧呢？</p><p>无外乎两点：减少重复的代码以方便后期的维护，减少重复性的工作以方便后期的优化。其本质还是在于对编码逻辑的抽象，把重复性最高的工作，用最少的代码量来完成。<strong>在编译时让编译器来展开执行，这就是元编程的目的和核心思路</strong>。</p><p>在 C++ 中，关于元编程有两个门派，一个是<strong>模板元编程</strong>，主要借助的是模板特化来实现自动化编程。另一个是常量表达式门派，主要是借助 <strong>constexpr</strong> 这一关键字来实现。两者就目前而言区别不算很大，而且基本上提到 C++ 的元编程，大家都会首先想到模板元编程，所以后面的讨论主要讲解的工具也是模板元编程，特此说明一下。</p><h3 id="1-2-元编程实例"><a href="#1-2-元编程实例" class="headerlink" title="1.2 元编程实例"></a>1.2 元编程实例</h3><p>多说无益，我们先从最简单的例子说起。</p><h4 id="1-2-1-简单的递归"><a href="#1-2-1-简单的递归" class="headerlink" title="1.2.1 简单的递归"></a>1.2.1 简单的递归</h4><p>我们先写一个简单的普通版本的递归函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="built_in">pow</span>(a, b - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-2-2-元编程实现上述递归"><a href="#1-2-2-元编程实现上述递归" class="headerlink" title="1.2.2 元编程实现上述递归"></a>1.2.2 元编程实现上述递归</h4><p>这个代码特化了两个终止条件，相对之特化一个终止条件的减少了一层递归调用，能提速不少。但是我们都知道，每递归调用一次，就要压一次函数堆栈，尤其是一但递归次数变多了，不仅仅是效率大打折扣，还有很大概率因为堆栈溢出而出错。<strong>那么元编程是怎么处理这个任务的呢？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A, <span class="keyword">int</span> B&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; result = A * Pow&lt;A, B - <span class="number">1</span>&gt;::result &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Pow</span>&lt;A, 1&gt; &#123;</span> <span class="keyword">enum</span> &#123; result = A &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Pow</span>&lt;A, 0&gt; &#123;</span> <span class="keyword">enum</span> &#123; result = <span class="number">1</span> &#125;; &#125;;</span><br></pre></td></tr></table></figure><p>和递归写法类似，我们同样特化了两个终止条件，然后用一个枚举量<strong>result</strong> 来记录结果。之所以选择枚举量，是因为枚举量是一个常量表达式的最原始的实现方法，但是现在我们有<strong>constexpr</strong>关键字了，所以也可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A, <span class="keyword">int</span> B&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = A * ConstPow&lt;A, B - <span class="number">1</span>&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span>&lt;A, 1&gt; &#123;</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = A; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span>&lt;A, 0&gt; &#123;</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure><p>这两种写法本质上是相同的。当然有人会问为什么用struct而不是用 class，事实上，C++ 的class和struct最主要的区别就是前者可以显式修饰成员的属性，而后者只有一个public属性。那么对于这份代码，结果result显然是我们要公开出去的一个成员，所以为了节省代码量，我就偷懒写成struct了。</p><h4 id="1-2-2-普通递归和元编程实现的区别"><a href="#1-2-2-普通递归和元编程实现的区别" class="headerlink" title="1.2.2 普通递归和元编程实现的区别"></a>1.2.2 普通递归和元编程实现的区别</h4><p>上述两种方式对递归的求解调用如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//普通递归实现</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Pow&lt;<span class="number">2</span>, <span class="number">4</span>&gt;::result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//元编程实现</span></span><br></pre></td></tr></table></figure></p><p>那么这两种写法在具体调用时，有什么区别呢？</p><p>区别就在于执行计算的时期不同。前者是典型的运行时展开运行时计算，也就是只有在代码真正运行的时候，才会进入函数，开始递归计算。<strong>而后者是典型的编译时展开编译时计算</strong>。实际上在编译时就会被展开写作如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">4</span>&gt;</span>::result <span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">3</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">2</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">1</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * 2 * 2</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 16</span><br></pre></td></tr></table></figure><p>所以代码中的这句<strong>cout&lt;&lt;Pow&lt;2, 4&gt;::result</strong>实际上和直接写<strong>cout&lt;&lt;16</strong>是一样的，也就是说，真正的计算任务给了编译器，而运行时只是把编译时算好的答案打印出来而已。</p><p>在这里，<code>Pow&amp;lt;&amp;gt;</code> 这份模板就被称为<strong>模板元编程技术，即把一些可以在编译时完成的求值计算，通过模板特化的技术绑定到具体的实例化代码上，从而减少不必要的代码量，提升代码的运行效率</strong>。</p><h3 id="1-3-元编程对性能的影响"><a href="#1-3-元编程对性能的影响" class="headerlink" title="1.3 元编程对性能的影响"></a>1.3 元编程对性能的影响</h3><p>这里首先要泼一盆冷水给大家，那就是天底下没有免费的好事：模板元编程在提升了代码的运行效率的同时，必然会导致编译时的效率降低，因为你把很多本来运行时的计算前置到了编译时计算，总的计算量并没有改变。所以我们反复强调的是，提升了运行效率，而非提升了整体的性能。</p><p>需要注意的是：众所周知，枚举变量，是没有地址的！是没有地址的！是没有地址的！所以是不能当做左值使用的！所以是不能当做左值使用的！所以是不能当做左值使用的！为什么要强调这个呢？</p><p>比如我们有一个函数是这样的接口void foo(const int &amp;);然后你调用了一个 foo(Pow&lt;2, 5&gt;::result);这样是不可以的。因为引用传递枚举值的时候，并不会使用任何静态内存，类似于字面量一样，所以一旦你把枚举值当左值使用了，编译器自然就会报错提醒。但是如果是<strong>常量表达式</strong>，就不会有这种问题，因为常量表达式的第一个前提是，它是变量，所以他有物理地址，所以可以foo(Pow&lt;2, 5&gt;::result);。</p><h2 id="二、试试稍复杂的模板元编程"><a href="#二、试试稍复杂的模板元编程" class="headerlink" title="二、试试稍复杂的模板元编程"></a>二、试试稍复杂的模板元编程</h2><p>最后我们实现一个稍微复杂的例子：计算两个向量的一般数学意义上的内积，即比如我们有两个三维向量a[]和b[]，其内积的定义为a[0]*b[0]+a[1]*b[1]+a[2]*b[2]。</p><p>我们先考虑最简单的模板函数的实现方式，不妨假设我们的向量是通过容器T[]储存的，那么我们可以用递归方式这样写：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T&gt; T dot_re(<span class="built_in">int</span> <span class="built_in">dim</span>, T *a, T *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dim</span> == <span class="number">1</span>) <span class="keyword">return</span> (*a) * (*b);</span><br><span class="line">    <span class="keyword">return</span> (*a) * (*b) + dot_re(<span class="built_in">dim</span> - <span class="number">1</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们试试把它改成元编程版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> DIM, <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">Dot</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">result</span><span class="params">(T *a, T *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*a) * (*b) + __Dot&lt;DIM - <span class="number">1</span>, T&gt;::result(a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">Dot</span>&lt;1, T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">result</span><span class="params">(T *a, T *b)</span> </span>&#123; <span class="keyword">return</span> (*a) * (*b); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> DIM, <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">dot_meta</span>(<span class="title">T</span> *<span class="title">a</span>, <span class="title">T</span> *<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __Dot&lt;DIM, T&gt;::result(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候可能会问，为什么命名第一种写法最简单最快，但是我们还要刻意写一份元编程版本的呢？</p><p>这是由于，现代编译器普遍都具有了针对循环和递归的优化，这种优化对于比较大规模的循环是非常值得的，但是针对于比较小的向量内积计算，可能就没有一句直接展开a[0]*b[0] + a[1]*b[1] + a[2]*b[2]更为迅速了。可能一次两次的这种计算体现不出来，但是如果是大规模的计算可能就差别很大了。为了方便，我们折腾一个 benchmark 测试一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">dot</span>(<span class="title">int</span> <span class="title">dim</span>, <span class="title">T</span> *<span class="title">a</span>, <span class="title">T</span> *<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> result = T();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">        result += a[i] * b[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">benchmark</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DOT_META_(dim, a, b) dot_meta<span class="meta-string">&lt;dim&gt;(a, b)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> TEST_CASE(id, foo) for (int i = 0; i &lt; cnt; i++)\</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)\</span><br><span class="line">    &#123;\</span><br><span class="line">        <span class="keyword">int</span> hoge = foo(<span class="number">4</span>, a.data(), b.data());\</span><br><span class="line">        sum#<span class="meta">#id += hoge * foo(4, a.data(), a.data());\</span></span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">auto</span> t#<span class="meta">#id = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> t0 = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    TEST_CASE(<span class="number">1</span>, dot)</span><br><span class="line">    TEST_CASE(<span class="number">2</span>, dot_re)</span><br><span class="line">    TEST_CASE(<span class="number">3</span>, DOT_META_)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"======== "</span> &lt;&lt; cnt &lt;&lt; <span class="string">" ========\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot():      "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t1 - t0).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot_re():   "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t2 - t1).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot_meta(): "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t3 - t2).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"(sum1 % 100, sum2 % 100, sum3 % 100)= ("</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (sum1 % <span class="number">100</span>) &lt;&lt; <span class="string">", "</span> &lt;&lt; (sum2 % <span class="number">100</span>) &lt;&lt; <span class="string">", "</span>&lt;&lt; (sum3 % <span class="number">100</span>) &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> TEST_CASE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> DOT_META_</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) benchmark(i * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在编译时加上 <code>-O2</code> 选项，直接看结果：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">======== <span class="number">1000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">4.02</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">1.99</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">0.00</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">3000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">37.87</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">15.98</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">1.99</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(16, 16, 16)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">5000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">104.75</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">43.89</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">6.99</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(48, 48, 48)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">7000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">203.42</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">87.76</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">13.96</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(-4, -4, -4)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">9000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">336.08</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">144.64</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">23.93</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(-40, -40, -40)</span></span><br></pre></td></tr></table></figure><p>可见，元编程版本的速度远远超过了前面的两种写法，而为什么递归版本的速度比循环要快呢？这是因为编译器把我们的递归版本进行了尾递归改写，然后再尾递归优化。有兴趣的可以利用g++ -S把汇编代码编译出来对比下区别。在我的电脑上，如果没有开-O2`优化，汇编的代码忠实的记录了执行时会进行递归调用。但是如果开了-O2优化之后，就会发现整个递归已经被改写成非常简洁的迭代代码。这就是最简单的尾递归优化。但是即便如此，也比不上直接展开计算的效率。当然，并不是所有时候这种展开都会很快，而这更多的细节就等到真正用到的时候再去测试吧。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11特性 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.最长回文子串与最长公共子串问题</title>
      <link href="/2019/06/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>字符串处理是常见的问题，其中又数最长回文字符串比较经典，这里总结一下。</p><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a><br><a id="more"></a></p><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure></p><h3 id="2、解法1：暴力求解"><a href="#2、解法1：暴力求解" class="headerlink" title="2、解法1：暴力求解"></a>2、解法1：暴力求解</h3><p>找你所有可能的子串，判断每一个字串是否为回文串。字串有n^2个，每一个字串都需要遍历一遍才能确定是否回文，故时间复杂度为：O( n^3)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">int</span> len = s.length(),maxlen=<span class="number">1</span>,start=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index1 = i,index2 = j;<span class="comment">//子串的两端坐标</span></span><br><span class="line">            <span class="keyword">while</span>(index1 &lt; index2 &amp;&amp; s[index1] == s[index2])<span class="comment">//依次进行匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                index1++;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index1 &gt;= index2 &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen) <span class="comment">//当前子串是回文子串</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxlen);<span class="comment">//提取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"oho"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解法2：利用最长公共字串求解"><a href="#3、解法2：利用最长公共字串求解" class="headerlink" title="3、解法2：利用最长公共字串求解"></a>3、解法2：利用最长公共字串求解</h3><p>本题可以转换为求解两个字符串的最长公共字串，对于输入字符串str，求其反转字符串rstr，求其最长公共子串即可。所以时间复杂度为求最长公共子串的时间复杂度：O(n^2),空间复杂度为O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> rev=s,ret,temp;</span><br><span class="line">        reverse(rev.begin(),rev.end());<span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">if</span>(rev==s) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;<span class="comment">//存放回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)<span class="comment">//查找s与rev的最长公共子串</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=<span class="string">""</span>;<span class="comment">//存放待验证子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp+=s[j];<span class="comment">//提取子串，每次增加一个字符</span></span><br><span class="line">                <span class="keyword">if</span>(temp.length()&lt;len)  <span class="keyword">continue</span>;<span class="comment">//子串的长度不够....</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rev.find(temp)!=<span class="number">-1</span>)<span class="comment">//在rev中找到temp</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> q=temp;<span class="comment">//q用来验证temp是否是回文子串</span></span><br><span class="line">                    reverse(q.begin(),q.end());</span><br><span class="line">                    <span class="keyword">if</span>(q==temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        len=temp.length();</span><br><span class="line">                        ret=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>如何求两个字符串的最长公共子串</strong>？一种比较合理的方式是分配一个二维数组，行和列分别对应的两个字符串的长度，对应的值表示两个字符串的字符是否相等。如果其i-1,j-1对应值大于0，则在其基础上+1。二位数组中的最大值即为最大长度。其实这也是一个动态规划问题，时间复杂度为O(n*m);</p><h3 id="4、解法3：动态规划求解"><a href="#4、解法3：动态规划求解" class="headerlink" title="4、解法3：动态规划求解"></a>4、解法3：动态规划求解</h3><p>定义dp[j][i]表示索引j到索引i的子串是否是回文串,为true时表示索引j到索引i形成的子串为回文子串，且子串起点索引为j,长度为i - j + 1。</p><p>我们知道，当只有一个字符时肯定是回文字符串，当有两个字符时，两个字符相等才能构成回文。那如果多个字符呢？其实可以递推，如果i到j回文，那么[i+1,j-1]也回文，反过来，要想[i,j]区间的字符串回文，那么str[i]需要等于str[j]并且[i+1，j-1]也回文。</p><p>对应的递推方程为：<br><img src="https://upload-images.jianshu.io/upload_images/6946981-a5f3dcc2b314fd49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/799/format/webp" alt="image"></p><p>实现代码为：(算法时间复杂度为O(N^2))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> dp[s.length()][s.length()];<span class="comment">//用一个二维数组记录状态</span></span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>,start = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); <span class="comment">//csting提供的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - j &lt; <span class="number">2</span>)  dp[j][i] = (s[i] == s[j]);</span><br><span class="line">            <span class="keyword">else</span>  dp[j][i] = (s[i] == s[j] &amp;&amp; dp[j + <span class="number">1</span>][i - <span class="number">1</span>]);<span class="comment">//递推</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[j][i] &amp;&amp; maxlen &lt; i - j + <span class="number">1</span>) <span class="comment">//找到回文子串</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = i - j + <span class="number">1</span>;</span><br><span class="line">                start = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);<span class="comment">//提取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、解法4：中心扩展法"><a href="#4、解法4：中心扩展法" class="headerlink" title="4、解法4：中心扩展法"></a>4、解法4：中心扩展法</h3><p>中心扩展就是遍历字符串，以每一个字母为中心，向两边扩展，这样来找最长的子回文串。算法复杂度为O(N^2)。</p><p>需要考虑两种情况：     </p><ul><li>长度为奇数的回文串，比如a, aba, abcba    </li><li>长度为偶数的回文串，比如aa, abba     </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line">        <span class="keyword">int</span> len = s.size(),maxlen = <span class="number">1</span>,start = <span class="number">0</span>,j,k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//求长度为奇数的回文串</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i - <span class="number">1</span>, k = i + <span class="number">1</span>;<span class="comment">//以i为中心点向两边展开</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len &amp;&amp; s[j] == s[k]) <span class="comment">//相等，则得到一个回文串</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k - j + <span class="number">1</span> &gt; maxlen)  maxlen = k - j + <span class="number">1</span>,start = j;</span><br><span class="line">                j--,k++;<span class="comment">//进一步扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//求长度为偶数的回文串</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i, k = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len &amp;&amp; s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k - j + <span class="number">1</span> &gt; maxlen)  maxlen = k - j + <span class="number">1</span>,start = j;</span><br><span class="line">                j--,k++;<span class="comment">//进一步扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用与epoll原理探究</title>
      <link href="/2019/06/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8Eepoll%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
      <url>/2019/06/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8Eepoll%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>本文在引入五种IO模型的基础上，介绍常见的三种IO multiplexing技术select、poll和epoll的用法，并总结分析三者的应用场景和优缺点0，最后详细介绍epoll高效的原因。</p><a id="more"></a><h3 id="1、五种IO模型"><a href="#1、五种IO模型" class="headerlink" title="1、五种IO模型"></a>1、五种IO模型</h3><p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p><ul><li>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</li><li>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</li><li>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，主要作用是可以避免同步非阻塞IO模型中轮询等待的问题，可达到在同一个线程内同时处理多个IO请求的目的。。</li><li>（4）信号驱动 I/O（ signal driven IO）：信号驱动IO在实际中并不常用。</li><li>（5）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</li></ul><p>需要记住的是上述<strong>前四种IO都是同步IO</strong>。对于一次read IO访问，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>同步和异步的主要区别在于谁负责拷贝数据</strong>：同步方式下由用户线程将数据拷贝到用户空间；异步方式下由内核负责将数据拷贝到用户空间，拷贝完成后会通知用户线程或者调用用户线程注册的回调函数进行后续处理。</p><p><strong>阻塞和非阻塞的主要区别在于是否需要等待完成</strong>：阻塞和非阻塞主要是针对同步方式，阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p><h3 id="2、IO-multiplexing技术"><a href="#2、IO-multiplexing技术" class="headerlink" title="2、IO multiplexing技术"></a>2、IO multiplexing技术</h3><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（读就绪或写就绪），就通知程序进行相应的读写操作。</p><p>select、poll和epoll都是Linux API提供的IO复用方式。注意<strong>select，poll，epoll本质上都是同步I/O</strong>，因为这些就绪的IO上的数据都由用户线程进行拷贝。</p><p>下面主要讲select、poll、epoll的用法。</p><h4 id="2-1-select函数"><a href="#2-1-select函数" class="headerlink" title="2.1 select函数"></a>2.1 select函数</h4><p>select系统调用函数介绍：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span>(<span class="params"><span class="keyword">int</span> maxfd,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout</span>)</span>;</span><br><span class="line"><span class="comment">//maxfd表示需要监听的套接字最大描述符+1  </span></span><br><span class="line"><span class="comment">//fd_set是一个文件描述符集合。三个参数分别表示监听读、写和异常文件描述符集合，可以设为空指针。</span></span><br><span class="line"><span class="comment">//timeout设定等待时间，timeval结构用于指定这段时间的秒数和微秒数，可以精确到微秒。</span></span><br><span class="line"><span class="comment">//返回值：有就绪描述符就返回其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset) <span class="comment">//将指定的文件描述符集清空，必须进行初始化。</span></span><br><span class="line">FD_SET(fd_set *fdset) <span class="comment">//用于在文件描述符集合中增加一个新的文件描述符。</span></span><br><span class="line">FD_CLR(fd_set *fdset) <span class="comment">//用于在文件描述符集合中删除一个文件描述符。</span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd,fd_set *fdset) <span class="comment">//用于测试指定的文件描述符是否在该集合中。</span></span><br></pre></td></tr></table></figure></p><p><strong>select运行机制</strong><br>select()的机制中提供一种fd_set的数据结构，实际上是一个long类型的数组，每一位代表一个对应的文件描述符，通过宏进行添加和删除。当调用select()时，由内核根据IO状态修改fd_set的内容，由此来返回那些就绪IO。</p><p>相比同步阻塞模型，select怎加了添加监听文件描述符以及调用select函数的额外操作，还有返回后的遍历代价。其最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p><strong>select机制的缺点：</strong>    </p><ul><li>（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。</li><li>（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。</li><li>（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。</li><li>（4）每次调用select之前都需要遍历设置监听集合，重复工作。</li></ul><h4 id="2-2-poll函数"><a href="#2-2-poll函数" class="headerlink" title="2.2 poll函数"></a>2.2 poll函数</h4><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是<strong>poll没有最大文件描述符数量的限制</strong>。也就是说，poll只解决了上面的问题3，并没有解决问题1，2的性能开销问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//nfds记录数组fds中描述符的总数量</span></span><br><span class="line"><span class="comment">//返回值表示fds集合中就绪描述符数量，返回0表示超时，返回-1表示出错；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// 需要被检测或选择的文件描述符</span></span><br><span class="line">        <span class="keyword">short</span> events;                   <span class="comment">// 对文件描述符fd上感兴趣的事件</span></span><br><span class="line">        <span class="keyword">short</span> revents;                  <span class="comment">// 文件描述符fd上当前实际发生的事件</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-epoll函数"><a href="#2-3-epoll函数" class="headerlink" title="2.3 epoll函数"></a>2.3 epoll函数</h4><p>epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select来说，<strong>epoll没有描述符个数限制</strong>，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在<strong>用户空间和内核空间只需copy一次</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//epoll_create 函数创建一个epoll句柄，参数size表明内核要监听的描述符数量，失败时返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//epoll_ctl函数用于注册要监听的事件类型，带四个参数。</span></span><br><span class="line"><span class="comment">//epfd 表示epoll句柄；op 表示fd操作类型，包括EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL三种；</span></span><br><span class="line"><span class="comment">//fd 是要监听的描述符；event 表示要监听的事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// epoll_wait函数用于等待就绪事件，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</span></span><br><span class="line"><span class="comment">// epfd是epoll句柄；events表示从内核得到的就绪事件集合；</span></span><br><span class="line"><span class="comment">// maxevents告诉内核events的大小；timeout表示等待的超时事件。</span></span><br></pre></td></tr></table></figure></p><p>可以看出上述epoll机制的好处在于：分清了频繁调用和不频繁调用的操作。例如，epoll_ctrl是不太频繁调用的，而epoll_wait是非常频繁调用的。这时，epoll_wait却几乎没有入参，这比select的效率高出一大截，而且，它也不会随着并发连接的增加使得入参越发多起来，导致内核执行效率下降。</p><h3 id="3、epoll的LE和ET"><a href="#3、epoll的LE和ET" class="headerlink" title="3、epoll的LE和ET"></a>3、epoll的LE和ET</h3><p>epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序可以通过记录IO状态，从而减少epoll_wait的调用，提高应用程序效率。</p><ul><li><strong>水平触发（LT）</strong>：默认工作模式，表示当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</li><li><strong>边缘触发（ET）</strong>： 当epoll_wait检测到事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。边缘触发只在状态由未就绪变为就绪时只通知一次。</li></ul><p>ET和LE容易走向两个极端，LT会在你不能处理读或写时不断epoll_wait返回告诉你可读可写从而浪费不必要的时间；而ET则可能会在你想读或想写时由于错过第一次时机从而获取不到对应的响应。</p><p>总而言之，一般应用场景上两者的性能不会有什么大的差距，<strong>ET的优点在于epoll_wait的调用次数会减少一些</strong>，某些场景下连接在不必要唤醒时不会被唤醒（此唤醒指epoll_wait返回）。但实际上，这不单纯是一个网络问题，而跟应用场景相关，虽然大部分开源框架都是基于ET写的，但框架追求的是纯技术问题，力求尽善尽美，与实际应用还是有区别的。</p><blockquote><p>小结：LT模式和ET模式各有优缺点，无所谓孰优孰劣。使用 LT 模式，我们可以自由决定每次收取多少字节（对于普通 socket）或何时接收连接（对于侦听 socket），但是可能会导致多次触发；使用ET模式，我们必须每次都要将数据收完（对于普通socket）或必须理解调用accept接收连接（对于侦听socket），其优点是触发次数少。</p></blockquote><blockquote><p>应用场景：</p><ul><li>(1) 读频次少，每次数据很多：如果LT和ET模式下的缓冲区足够大，那么两种模式没有区别。但是如果缓冲区比较小，那么很明显应该用LT模式，而且也方便控制读入数据的量或者甚至推迟读数据。</li><li>(2) 写数据少，但频次多：对于写，LT为了避免频繁触发epoll_wait,每次写开始和写完后向epoll注册和注销事件，如果频次多，那就不太好，即使频次少，多次调用epoll_ctrl也会带来开销。与之对应的是，ET模式在写数据情况下表现很好。</li></ul></blockquote><h3 id="4、epoll的高效原理与内核管理机制"><a href="#4、epoll的高效原理与内核管理机制" class="headerlink" title="4、epoll的高效原理与内核管理机制"></a>4、epoll的高效原理与内核管理机制</h3><p>通过前面两节的知识，我们知道epoll高效的一个原因在于ET机制的引入减少epoll_wait的调用此时，而poll相对select优势在于不用重复遍历设置监听文件描述符集合，而epoll相对poll和select的优势在于不用来回在内核和用户空间copy监听集合，能快速返回活跃IO集合。</p><p>说到epoll都夸赞它的效率和并发量，那么它好在哪里呢？<br><strong>epoll的核心数据结构在于红黑树+双向链表</strong>，首先调用epoll_create时内核帮我们在epoll文件系统里建了个file结点；除此之外在内核cache里建立红黑树用于存储以后epoll_ctl传来的socket，当有新的socket连接来时，先遍历红黑书中有没有这个socket存在，如果有就立即返回，没有就插入红黑数，然后给内核中断处理程序注册一个钩子函数，每当有事件发生时就通过钩子函数把这些文件描述符放到用来存储就绪事件的链表中。<strong>epoll_wait并不监听文件句柄，而是等待就绪链表不空or收到信号or超时这三种条件后返回</strong>。</p><p>epoll_wait返回时，会将就绪链表上的事件摘除，在LT模式下，这些就绪socke事件会再次被放回到刚刚清空的准备就绪链表，保证所有的事件都得到正确的处理。如果到timeout时间后链表中没有数据也立刻返回。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/1.png?raw=true" alt="image"></p><p>对于epoll，需要建立文件系统，包括红黑树和链表代价会比较高，同时回调机制也会在fd活跃数目较多的情况下被反复调用，效率反而不高。所以：<strong>当监测的fd数目较小，或者fd数目多且各个fd都比较活跃，建议使用select或者poll；当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</strong>，比如ngix web服务器就是使用epoll实现的。</p><h3 id="5、select、poll和epoll的应用场景"><a href="#5、select、poll和epoll的应用场景" class="headerlink" title="5、select、poll和epoll的应用场景"></a>5、select、poll和epoll的应用场景</h3><p>我们知道epoll的优势非常明显，几乎没有描述符数量的限制，并发支持完美，不会随着socket的增加而降低效率，也不用在内核空间和用户空间之间做无效的copy操作。但是是不是所有的场景都适合epoll呢？</p><blockquote><p>一个游戏服务器，tcpserver负责接收客户端的连接，dbserver负责处理数据信息，一个webserver负责处理服务器的web请求，gameserver负责游戏的逻辑处理，所有这些服务都和另外一个gateserver相连，gateserver负责服务器间的通信和转发（进程间通信），只要游戏服务器在服务状态，这些连接几乎不会断开（异常情况可能会断开），并且这些连接数量一般不会很多。</p></blockquote><blockquote><p>这种情况，gateserver是选择select还是epoll呢？很明显是select，因为每时每刻这些连接的socket都有事件发生（比如：服务期间的心跳信息，还有大型网络游戏的同步信息（一般每秒在20-30次）），最重要的是，这种场景下，并发量也不会很大。如果此时用epoll，为此所建立的文件系统，红黑书和链表对于此来说就是杀鸡用牛刀，效率反而不高。</p></blockquote><blockquote><p>但是这里的tcpserver负责大量的客户端的连接，毫无疑问epoll是首选，它接受大量的客户端连接，收到客户端的消息之后把消息转发发给select网络模型的gateserver，gateserver再转发给gameserver进行逻辑处理，最后返回给客户端就over了。</p></blockquote><p>因此在如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了。</p><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>总结上述的知识可以看出，epoll建立红黑树和链表、调用回调函数都需要开销，适用于高并发而活跃连接较少的情况。select和poll的代价在于用户空间与内核态的数据拷贝和遍历处理，适用于连接量较少但其中大多数都比较活跃的情况。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/2.png?raw=true" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 服务端编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> IO multiplexing </tag>
            
            <tag> epoll原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.二叉树问题集合</title>
      <link href="/2019/06/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/2019/06/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>二叉树是算法问题中的一个重点，主要考察逻辑思维和边界判断问题，本章主要总结几个常见的二叉树相关算法问题。</p><a id="more"></a><h3 id="1、序列化二叉树"><a href="#1、序列化二叉树" class="headerlink" title="1、序列化二叉树"></a>1、序列化二叉树</h3><h4 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><blockquote><p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h4 id="1-2-解题思路"><a href="#1-2-解题思路" class="headerlink" title="1.2 解题思路"></a>1.2 解题思路</h4><p>本题的考点在于二叉树和字符串之间的想好转换，此外需要知道二叉树的先序遍历。需要注意的是两位及两位以上的数字序列号成字符串后怎么反序列化回来，还有就是被调用的函数怎么修改指针值达到目的。</p><blockquote><p>用到的函数：to_string(int)、string.copy(dst,len,begin)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSerialize</span><span class="params">(<span class="built_in">string</span> &amp;str,TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;str+=<span class="string">"#,"</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root) str += to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">        DoSerialize(str,root-&gt;left);</span><br><span class="line">        DoSerialize(str,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">Serialize</span><span class="params">(TreeNode *root)</span> <span class="comment">//将二叉树转换为字符串</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        DoSerialize(str,root);</span><br><span class="line">        <span class="keyword">char</span> *ret=<span class="keyword">new</span> <span class="keyword">char</span>[str.length()];  </span><br><span class="line">        str.copy(ret,str.length()<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//拷贝字符串</span></span><br><span class="line">        ret[str.length()<span class="number">-1</span>]==<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoDeserialize</span><span class="params">(TreeNode **node,<span class="keyword">char</span> *str,<span class="keyword">int</span> &amp;index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'\0'</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'#'</span>)  <span class="comment">//当前节点的左节点为空，直接返回。</span></span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[index]&gt;=<span class="string">'0'</span> &amp;&amp; str[index]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value=value*<span class="number">10</span>+str[index]-<span class="string">'0'</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *node=<span class="keyword">new</span> TreeNode(value); <span class="comment">//创建节点</span></span><br><span class="line">        DoDeserialize(&amp;((*node)-&gt;left),str,++index);</span><br><span class="line">        DoDeserialize(&amp;((*node)-&gt;right),str,++index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//将字符串转换为二叉树</span></span><br><span class="line">        TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!str) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//用来记录字符串的下标</span></span><br><span class="line">        DoDeserialize(&amp;root, str, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    TreeNode *p = <span class="keyword">new</span> TreeNode(<span class="number">11</span>);</span><br><span class="line">    TreeNode *node1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *node2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node3 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode *node4 = <span class="keyword">new</span> TreeNode(<span class="number">16</span>);</span><br><span class="line">    p-&gt;left=node3;</span><br><span class="line">    p-&gt;left-&gt;left=node2;</span><br><span class="line">    p-&gt;left-&gt;left-&gt;left=node1;</span><br><span class="line">    p-&gt;right=node4;</span><br><span class="line"></span><br><span class="line">    TreeNode *ptr=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solu.Serialize(p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *q=solu.Deserialize(solu.Serialize(p));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;solu.Serialize(q)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// string str="deng";</span></span><br><span class="line">    <span class="comment">// string &amp;str1=str;</span></span><br><span class="line">    <span class="comment">// str1+=" wen";</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;str1&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.数组中的重复数</title>
      <link href="/2019/05/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0/"/>
      <url>/2019/05/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><a id="more"></a><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><blockquote><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><h4 id="（1）Hash求解（或者排序后求解）"><a href="#（1）Hash求解（或者排序后求解）" class="headerlink" title="（1）Hash求解（或者排序后求解）"></a>（1）Hash求解（或者排序后求解）</h4><p>用一个辅助数组进行计数，遍历原数组并记录每个数出现的次数，然后就可以得到重复的数。这种的解法的的时间复杂度为O(n),空间复杂度也为O(n)。实现代码如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    // numbers: an<span class="built_in"> array </span>of integers</span><br><span class="line">    // length:  the length of<span class="built_in"> array </span>numbers</span><br><span class="line">    // duplication: (Output) the duplicated number in the<span class="built_in"> array </span>number</span><br><span class="line">    // Return value:true<span class="built_in"> if </span>the input is valid,<span class="built_in"> and </span>there are some duplications in the<span class="built_in"> array </span>number; otherwise false</span><br><span class="line">    </span><br><span class="line">    bool duplicate(int numbers[],<span class="built_in"> int </span>length, int* duplication) &#123;</span><br><span class="line">       <span class="built_in"> int </span>*cnt=new int[length]; //辅助数组</span><br><span class="line">        for(int i=0;i&lt;length;i++) cnt[i]=0; //计数都为0</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[i]&gt;=length || numbers[i]&lt;0)<span class="built_in"> return </span>false;</span><br><span class="line">            if(cnt[numbers[i]]&gt;=1) //判断是否重复</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication=numbers[i];</span><br><span class="line">                delete cnt; //记得释放</span><br><span class="line">               <span class="built_in"> return </span>true;</span><br><span class="line">            &#125;</span><br><span class="line">            else cnt[numbers[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        delete cnt;//记得释放</span><br><span class="line">       <span class="built_in"> return </span>false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="（2）创新解法"><a href="#（2）创新解法" class="headerlink" title="（2）创新解法"></a>（2）创新解法</h4><p>依次遍历数组，对于坐标i，取其值m，然后判断numbers[m]是否与m相等，相等则表明对应的位置上已经有该值，返回；否则交换numbers[i]和numbers[m]，将m放到对应的位置，然后继续取numbers[i],直到numbers[i]==i,即当前位置已经被放置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span> *duplication)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span>||length&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=numbers[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt;= length || numbers[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//范围出错</span></span><br><span class="line">                <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])  <span class="comment">//对应的数已经出现过一次了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *duplication = numbers[i]; <span class="comment">//找到值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);<span class="comment">//一直换，知道换到对应的数为相应的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该种解法的<strong>时间复杂度为O(n)</strong>,虽然有两重循环，但是固定位置的数只需要放正确一次即可，无论是while循环还是for循环都来做。<strong>空间复杂度为O(1)</strong>。</p><h3 id="3、类似的题"><a href="#3、类似的题" class="headerlink" title="3、类似的题"></a>3、类似的题</h3><h4 id="3-1-长度为n-1的数组放1-n的数，求重复的数（不能修改原数组）。"><a href="#3-1-长度为n-1的数组放1-n的数，求重复的数（不能修改原数组）。" class="headerlink" title="3.1 长度为n+1的数组放1~n的数，求重复的数（不能修改原数组）。"></a>3.1 长度为n+1的数组放1~n的数，求重复的数（不能修改原数组）。</h4><p>这个题跟上一个题的数主要区别是不能修改原数组。可以用辅助数组进行求解，还可以用二分法进行求解，如取中间的数m，然后统计1~m的数的个数cnt1，统计m+1~n的数的个数cnt2。如果cnt大于m，则对应的重复的数在1~m这个区间，继续二分，直到最后一个数。</p><p>时间复杂度为O(nlogn),空间复杂度为O(1)。</p><h4 id="3-2-除了一个数外，所有两个数都出现两次的数组，找出这个数。"><a href="#3-2-除了一个数外，所有两个数都出现两次的数组，找出这个数。" class="headerlink" title="3.2 除了一个数外，所有两个数都出现两次的数组，找出这个数。"></a>3.2 除了一个数外，所有两个数都出现两次的数组，找出这个数。</h4><p>用异或可解决问题，时间复杂度为O(n)。</p><h4 id="3-3-除了两个数外，所有两个数都出现两次的数组，找出这两个数。"><a href="#3-3-除了两个数外，所有两个数都出现两次的数组，找出这两个数。" class="headerlink" title="3.3 除了两个数外，所有两个数都出现两次的数组，找出这两个数。"></a>3.3 除了两个数外，所有两个数都出现两次的数组，找出这两个数。</h4><p>还是用异或进行解决，需要注意的是这里需要求出那两个特殊的数的异或结果，然后找到其为1最低位对应的2的幂值m，遍历数组找到与m相与为1的所有数然后异或即可得结果result1，遍历数组找到与m相与为0的所有数然后异或即可得结果result2。</p><h4 id="3-4-除一个数外，其它的所有的数都出现3次，求这个数。"><a href="#3-4-除一个数外，其它的所有的数都出现3次，求这个数。" class="headerlink" title="3.4 除一个数外，其它的所有的数都出现3次，求这个数。"></a>3.4 除一个数外，其它的所有的数都出现3次，求这个数。</h4><p>这个题的解法为用一个长度为32的数组，用来统计数组中所有数对应位为1的个数。最后遍历一次处理这个数组即可得到结果。</p><p>时间复杂度为O(n),空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 虚拟内存之C程序中常见的内存相关错误</title>
      <link href="/2019/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/"/>
      <url>/2019/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>对C/C++程序员来说，管理和使用虚拟存储器可能是个困难的， 容易出错的任务。与存储器有关的错误属于那些令人惊恐的错误， 因为它们在时间和空间上， 经常是在距错误源一段距离之后才表现出来。 将错误的数据写到错误的位置， 你的程序可能在最终失败之前运行了好几个小时，且使程序中止的位置距离错误的位置已经很远啦。而避免这种噩梦的最好方法就是<strong>防范于未然。</strong></p><p>本节主要介绍《深入理解计算机系统》中介绍的 <strong>C程序中常见的内存操作有关的10种典型编程错误</strong>， 以便以后随时查看，复习。</p><a id="more"></a><h3 id="1、-间接引用无效指针"><a href="#1、-间接引用无效指针" class="headerlink" title="1、 间接引用无效指针"></a>1、 间接引用无效指针</h3><p>进程虚拟地址空间的某些地址范围可能没有映射到任何有意义的数据，如果我们试图间接引用一个指向这些地址的指针，则操作系统会以终止进程。而且，虚拟存储器的某些区域是只读的（如.text或.rodata），试图写这些区域会以保护异常中止当前进程。  </p><p>如从stdin读取一个int变量时，scanf(“%d”, &amp;val)是正确用法，若误写为scanf(“%d”,<br>val)时，val的值会被解释为一个地址，并试图向该地址写数据。在最好的情况下，进程立即异常中止。在最坏的情况下，val的值恰好对应于虚拟存储器<br>的某个合法的具有读/写权限的内存区域，于是该内存单元会被改写，而这通常会在相当长的一段时间后造成灾难性的、令人困惑的后果。</p><p>我们学习C/C++中的指针时， 指针未初始化错误也属于这类错误。</p><h3 id="2、-读未初始化的存储器-Reading-Uninitialized-Memory"><a href="#2、-读未初始化的存储器-Reading-Uninitialized-Memory" class="headerlink" title="2、 读未初始化的存储器(Reading Uninitialized Memory)"></a>2、 读未初始化的存储器(Reading Uninitialized Memory)</h3><p>C语言的malloc并不负责初始化申请到的内存区域(在C/C++中未初始化的全局变量会被初始化为0)，因此，常见的错误是假设堆存储器被初始化为0，例如：</p><p>这个程序是计算一个 n*n的矩阵（**A） 乘以 一个 n*1（*x） 的矩阵, 并返回计算结果（*y）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int  *matvec(int  **A,  int  *x,  int n)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>;</span><br><span class="line">    int  *y =  (int  *)malloc(n *  sizeof(int));  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span> ; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">0</span> ; <span class="built_in">j</span> &lt; n; <span class="built_in">j</span>++)</span><br><span class="line">    y[<span class="built_in">i</span>]  += A[<span class="built_in">i</span>][<span class="built_in">j</span>]  * x[<span class="built_in">j</span>];</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，错误地假设了y被初始化为0。<strong>正确的实现方式是显式地依次将y[i]置为0或者使用calloc分配内存</strong>。</p><h3 id="3、栈缓冲区溢出-Allowing-Stack-Buffer-Overflows"><a href="#3、栈缓冲区溢出-Allowing-Stack-Buffer-Overflows" class="headerlink" title="3、栈缓冲区溢出(Allowing Stack Buffer Overflows)"></a>3、栈缓冲区溢出(Allowing Stack Buffer Overflows)</h3><p>这个是我们熟悉的<strong>缓冲区溢出错误</strong>（buffer overflow bug）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *buf[<span class="number">64</span>];</span><br><span class="line">     gets(buf);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入超过64个字符， 上面的代码将导致栈缓冲区溢出。 可以使用 fgets 函数代替 gets函数， fget函数有第二个参数， 以限制输入串的大小。</p><h3 id="4、-误以为指针和它们指向的对象是相同大小的。-Assuming-that-Pointers-and-the-Objects-They-Point-to-Are-the-Same-Size"><a href="#4、-误以为指针和它们指向的对象是相同大小的。-Assuming-that-Pointers-and-the-Objects-They-Point-to-Are-the-Same-Size" class="headerlink" title="4、 误以为指针和它们指向的对象是相同大小的。(Assuming that Pointers and the Objects They Point to Are the Same Size)"></a>4、 误以为指针和它们指向的对象是相同大小的。(Assuming that Pointers and the Objects They Point to Are the Same Size)</h3><p>例如: 申请一个二维 n*m 的int数组空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">makeArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> i;  </span><br><span class="line">     <span class="keyword">int</span> **A = (<span class="keyword">int</span> **)Malloc(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">// 这里错误地认为int *与int两种变量类型具有相同的size  </span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">         A[i] = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> A;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码目的是创建一个由n个指针构成的数组，每个指针均指向一个包含m个int的数组，但是<strong>第五行</strong>误将<strong>sizeof(int*)</strong>写成<strong>sizeof(int)</strong>。这段代码只有在int和int*的size相同的机器上运行良好。如果在像Corei7这样的机器上运行这段代码，由于指针变量的size大于sizeof(int)，则会引发代码中的for循环写越界。因为这些字中的一个很可能是已分<br>配块的边界标记脚部，所以我们可能不会立即发现这个错误，直到进程运行很久释放这个内存块时，此时，分配器中的合并代码会戏剧性地失败，而没有任何明显的<br>原因。这是”在远处起作用”（action at distance）的一个隐秘示例，这类”在远处起作用”是与存储器有关的编程错误的典型情况。</p><h3 id="5、-造成错位错误-Making-Off-by-One-Errors"><a href="#5、-造成错位错误-Making-Off-by-One-Errors" class="headerlink" title="5、 造成错位错误(Making Off-by-One Errors)"></a>5、 造成错位错误(Making Off-by-One Errors)</h3><p>错位（Off-by-one）错误是另一种常见的覆盖错误来源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> ** <span class="title">makeArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">int</span> **A = (<span class="keyword">int</span> **)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">        A[i] = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> A;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，for循环次数不合预期，导致写越界。幸运的话，进程会立即崩溃；不幸的话，运行很长时间才抛出各种诡异问题。</p><h3 id="6、引用指针，而不是它所指向的对象-Referencing-a-Pointer-Instead-of-the-Object-It-Points-to"><a href="#6、引用指针，而不是它所指向的对象-Referencing-a-Pointer-Instead-of-the-Object-It-Points-to" class="headerlink" title="6、引用指针，而不是它所指向的对象(Referencing a Pointer Instead of the Object It Points to)"></a>6、引用指针，而不是它所指向的对象(Referencing a Pointer Instead of the Object It Points to)</h3><p>如果不注意C操作符的优先级和结合性，就会错误地操作指针，而不是指针所指向的对象。<br>比如下面的函数，其目的是删除一个有*size项的二叉堆里的第一项，然后对剩下的*size-1项重建堆：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * binheapDelete(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *<span class="built_in">size</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> *packet = binheap[<span class="number">0</span>];  </span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*<span class="built_in">size</span> - <span class="number">1</span>];  </span><br><span class="line">    *<span class="built_in">size</span>--;  <span class="comment">// 此处应该为(*size)--  </span></span><br><span class="line">    heapify(binheap, *<span class="built_in">size</span>, <span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">return</span> (packet);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，由于–和<em>优先级相同，从右向左结合，所以</em>size–其实减少的是指针自己的值，而非其指向的整数的值。因此，<strong>谨记：当你对优先级和结合性有疑问时，就应该使用括号。</strong></p><h3 id="7、误解指针运算-Misunderstanding-Pointer-Arithmetic"><a href="#7、误解指针运算-Misunderstanding-Pointer-Arithmetic" class="headerlink" title="7、误解指针运算(Misunderstanding Pointer Arithmetic)**"></a>7、误解指针运算(Misunderstanding Pointer Arithmetic)**</h3><p>在C/C++中，指针的算术操作是以它们指向的对象的大小为单位来进行的。例如下面函数的功能是扫描一个int的数组，并返回一个指针，指向val的首次出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(*p &amp;&amp; *p != val) &#123;  </span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// 此处应该为p++，否则p += 4会导致大部分元素被跳过  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、引用不存在的变量-Referenceing-Nonexistent-Variables"><a href="#8、引用不存在的变量-Referenceing-Nonexistent-Variables" class="headerlink" title="8、引用不存在的变量(Referenceing Nonexistent Variables)"></a>8、引用不存在的变量(Referenceing Nonexistent Variables)</h3><p>C/C++新手不理解栈的规则时，可能会引用不再合法的本地变量，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">stackref</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> val;  </span><br><span class="line">    <span class="keyword">return</span> &amp;val;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数返回的指针（假设为p）指向栈中的局部变量，但该变量在函数返回后随着stackref栈帧的销毁已经不再有效。也即：尽管函数返回的指针p仍然指向<br>一个合法的存储器地址，但它已经不再指向一个合法的变量了。当程序后续调用其它函数时，存储器将重用刚才销毁栈帧处的存储器区域。再后来，如果程序分配某<br>个值给*p，那么它可能实际上正在修改另一个函数栈帧中的数据，从而潜在地带来灾难性的、令人困惑的后果。</p><h3 id="9、引用空闲堆块中的数据-Referencing-Data-in-Free-Heap-Blocks"><a href="#9、引用空闲堆块中的数据-Referencing-Data-in-Free-Heap-Blocks" class="headerlink" title="9、引用空闲堆块中的数据(Referencing Data in Free Heap Blocks)"></a>9、引用空闲堆块中的数据(Referencing Data in Free Heap Blocks)</h3><p>典型的错误为：引用已经被释放了的堆块中的数据，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">heapref</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> i;  </span><br><span class="line">      <span class="keyword">int</span> *x, *y;  </span><br><span class="line">      x = (<span class="keyword">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">      <span class="comment">/*  各种操作 */</span>  </span><br><span class="line">      <span class="built_in">free</span>(x);  </span><br><span class="line">        </span><br><span class="line">      y = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">          y[i] = x[i]++;  <span class="comment">// 此处的x之前已经被释放了！  </span></span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="10、-引起内存泄露（Introducing-Memory-leaks）"><a href="#10、-引起内存泄露（Introducing-Memory-leaks）" class="headerlink" title="10、 引起内存泄露（Introducing Memory leaks）"></a>10、 引起内存泄露（Introducing Memory leaks）</h3><p>内存泄露是缓慢、隐性的杀手，当程序员忘记释放已分配块时会发生这种问题，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">     <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果leak在程序整个生命周期内只调用数次，则问题还不是很严重（但还是会浪费存储器空间），因为随着进程结束，操作系统会回收这些内存空间。但如果<br>leak()被经常调用，那就会发生严重的内存泄露，最坏的情况下，会占用整个虚拟地址空间。对于像守护进程和服务器这样的程序来说，内存泄露是严重的<br>bug，必须加以重视。</p><p>【参考资料】<br>《深入理解计算机系统》</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《TCP-IP详解卷1》第4章ARP：地址解析协议</title>
      <link href="/2019/05/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC4%E7%AB%A0ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/05/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC4%E7%AB%A0ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。一个网络如以太网可以同时被不同的网络层使用。</p><p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。<strong>设备驱动程序从不检查IP数据报中的目的IP地址</strong>。</p><p>地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。ARP（地址解析协议）和RAR P（逆地址解析协议）就是这样的两个映射协议。</p><p>ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。</p><a id="more"></a><h3 id="1、从一个实例入手"><a href="#1、从一个实例入手" class="headerlink" title="1、从一个实例入手"></a>1、从一个实例入手</h3><p>当我们敲下以下命令：ftp bsdi，实际发生的过程如下。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/41.png?raw=true" alt="image"></p><ul><li>（1）应用程序FTP客户端调用函数gethostbyname(3)把主机名（bsdi）转换成32 bit的IP地址。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/host s）。</li><li>（2）FTP客户端请求TCP用得到的IP地址建立连接。</li><li>（3）TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报。</li><li>（4）如果目的主机在本地网络上，那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。</li><li>（5）假定是一个以太网，那么发送端主机必须把32bit的IP地址变换成48bit的以太网地址。逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。</li><li>（6）ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li><li>（7）目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li><li>（8）收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</li><li>（9）发送IP数据报到目的主机。</li></ul><p>在ARP背后有一个基本概念，那就是网络接口有一个硬件地址。<strong>在硬件层次上进行的数据帧交换必须有正确的接口地址</strong>。知道主机的IP地址并不能让内核发送一帧数据给主机。<strong>内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据</strong>。ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。</p><h3 id="2、ARP高速缓存"><a href="#2、ARP高速缓存" class="headerlink" title="2、ARP高速缓存"></a>2、ARP高速缓存</h3><p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。我们可以用arp(8)命令来检查ARP高速缓存。参数-a的意思是显示高速缓存中所有的内容。</p><h3 id="3、ARP的分组格式"><a href="#3、ARP的分组格式" class="headerlink" title="3、ARP的分组格式"></a>3、ARP的分组格式</h3><p>ARP的分组格式如下（42Byte: 28字节的ARP数据,14字节的以太网帧头）：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/42.png?raw=true" alt="image"></p><ul><li>（1）以太网报头中的前两个字段是以太网的源地址和目的地址<strong>。目的地址为全1的特殊地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧</strong>。</li><li>（2）以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。</li><li>（3）硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li><li>（4）协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。<strong>它的值与包含IP数据报的以太网数据帧中的类型字段的值相同</strong>，这是有意设计的。</li><li>（5）两个1字节的字段分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li><li>（6）操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RAR P请求（值为3）和RARP应答（值为4）。这个字段必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。</li><li>（7）接下来的四个字段是发送端的硬件地址、发送端的协议地址、目的端的硬件地址和目的端的协议地址。<strong>注意，这里有一些重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址</strong>。</li></ul><p>对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。<strong>当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去</strong>。</p><h3 id="4、分析ARP实例"><a href="#4、分析ARP实例" class="headerlink" title="4、分析ARP实例"></a>4、分析ARP实例</h3><p>现在通过tcpdump获得一个TCP连接请求产生的ARP请求和应答，我们来看一下它的含义：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/43.png?raw=true" alt="image"></p><p>在第1行中，源端主机的硬件地址是0:0:c0:6f:2d:40。目的端主机的硬件地址是ff:ff:ff:ff:ff:ff，这是一个以太网广播地址。紧接着的一个输出字段是arp，表明帧类型字段的值是0x0806，说明此数据帧是一个ARP请求或回答。在每行中，单词arp或ip后面的值60指的是以太网数据帧的最小长度,可以看出需要填充。第1行中的arp who-has字段表示作为ARP请求的这个数据帧中，目的IP地址是svr4的地址，发送端的IP地址是bsdi的地址。</p><p>从第2行中可以看到，尽管ARP请求是广播的，但是ARP应答的目的地址却是bsd（0:0:c0:6f:2d:40）。</p><p>第3行是第一个请求建立连接的TCP段。它的目的硬件地址是目的主机(svr4)。</p><h3 id="5、如果ARP请求的主机不存在会发生什么？"><a href="#5、如果ARP请求的主机不存在会发生什么？" class="headerlink" title="5、如果ARP请求的主机不存在会发生什么？"></a>5、如果ARP请求的主机不存在会发生什么？</h3><p>如果查询的主机已关机或不存在会发生什么情况呢？用telnet 140.254.13.36发起连接，然后用tcpdump来查看状态，结果如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/44.png?raw=true" alt="image"></p><p>令人感兴趣的是看到多次进行ARP请求：第1次请求发生后5.5秒进行第2次请求，在24秒之后又进行第3次请求。注意，在线路上始终看不到TCP的报文段。我们能看到的是ARP请求。直到ARP回答返回时，TCP报文段才可以被发送，因为硬件地址到这时才可能知道。如果我们用过滤模式运行tcpdump命令，只查看TCP数据，那么将没有任何输出。</p><h3 id="6、ARP代理"><a href="#6、ARP代理" class="headerlink" title="6、ARP代理"></a>6、ARP代理</h3><p>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或<strong>ARP代理</strong>。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。<strong>一种攻击就是欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/45.png?raw=true" alt="image"></p><p>如图,当子网140.252.1（称作gemini）上的其他主机有一份IP数据报要传给地址为140.252.1.29的sun时，gemini比较网络号140.252和子网号1，因为它们都是相同的，所以在以太网中转发IP地址140.252.1.29的ARP请求。路由器netb识别出该IP地址属于它的一个拔号主机，于是把它的以太网接口地址140.252.1作为硬件地址来回答。主机gemini通过以太网发送IP数据报到netb，netb通过拨号SLIP链路把数据报转发到sun。这个过程对于所有140.252.1子网上的主机来说都是透明的，主机sun实际上是在路由器netb后面进行配置的。<strong>在这个过程中路由器会对arp结果进行缓存，以提高下一次查询效率</strong>。</p><p><strong>为什么在拨号SLIP链路的两端只拥有一个IP地址，而在bsdi和slip之间的两端却分别有一个IP地址</strong>？<br>这是因为NetBlazer不需要知道拨号SLIP链路每一端的IP地址，相反，它通过分组到达的串行线路接口来确定发送分组的拨号主机，因此对于连接到路由器的每个拨号主机不需要用唯一的I P地址。所有的拨号主机使用同一个IP地址140.252.1.183作为SLIP链路的目的地址。</p><p><strong>ARP代理可以把数据报传送到路由器sun上，但是子网140.252.13上的其他主机是如何处理的呢</strong>？<br>选路必须使数据报能到达其他主机。这里需要特殊处理，选路表中的表项必须在网络140.252的某个地方制定，使所有数据报的目的端要么是子网140.252.13，要么是子网上的某个主机，这样都指向路由器netb。而路由器netb知道如何把数据报传到最终的目的端，即通过路由器sun。</p><h3 id="7、免费ARP"><a href="#7、免费ARP" class="headerlink" title="7、免费ARP"></a>7、免费ARP</h3><p>我们可以看到的另一个ARP特性称作<strong>免费ARP</strong>。它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</p><p>免费ARP可以有两个方面的作用：</p><ul><li>(1) 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误消息“以太网地址：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li><li>(2) 如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li></ul><h3 id="8、arp命令"><a href="#8、arp命令" class="headerlink" title="8、arp命令"></a>8、arp命令</h3><p>arp命令及几个常用的参数如下：</p><ul><li>-a：用来显示ARP高速缓存中的所有内容。</li><li>-d：用来删除ARP高速缓存中的某一项内容。</li><li>-s：用来增加高速缓存中的内容，这个参数需要IP和对应的以太网地址。</li><li>关键字pub和-s选项一起，可以使系统起着主机ARP代理的作用。系统将回答与主机名对应的IP地址的ARP请求，并以指定的以太网地址作为应答。</li></ul><h3 id="9、小结"><a href="#9、小结" class="headerlink" title="9、小结"></a>9、小结</h3><p>在大多数的TCP/IP实现中，ARP是一个基础协议，但是它的运行对于应用程序或系统管理员来说一般是透明的。ARP高速缓存在它的运行过程中非常关键，我们可以用arp命令对高速缓存进行检查和操作。高速缓存中的每一项内容都有一个定时器，根据它来删除不完整和完整的表项。arp命令可以显示和修改ARP高速缓存中的内容。</p><p>我们介绍了ARP的一般操作，同时也介绍了一些特殊的功能：委托ARP（当路由器对来自于另一个路由器接口的ARP请求进行应答时）和免费ARP（发送自己IP地址的ARP请求，一般发生在引导过程中）。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 虚拟内存之动态内存分配与垃圾收集</title>
      <link href="/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用<strong>动态内存分配器</strong>更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种基本风格，<strong>显式分配器</strong>要求应用显式释放分配的块，而<strong>隐式分配器</strong>(<strong>也叫做垃圾收集器</strong>)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。</p><a id="more"></a><h3 id="1、malloc和free函数"><a href="#1、malloc和free函数" class="headerlink" title="1、malloc和free函数"></a>1、malloc和free函数</h3><h4 id="1-1-malloc函数"><a href="#1-1-malloc函数" class="headerlink" title="1.1 malloc函数"></a>1.1 malloc函数</h4><p>c标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">//返回：若成功则为已分配块的指针，若出错则为null.</span></span><br></pre></td></tr></table></figure></p><p>malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。如果malloc遇到问题，那么它就返回null，并设置errno。<strong>malloc不初始化它返回的内存，如果想要已初始化的内存则通过calloc分配，如果想要改变已分配块的大小则使用realloc函数</strong>。</p><h4 id="1-2-malloc的底层——sbrk函数"><a href="#1-2-malloc的底层——sbrk函数" class="headerlink" title="1.2 malloc的底层——sbrk函数"></a>1.2 malloc的底层——sbrk函数</h4><p>malloc可以通过mmap和munmap来显式分配和释放堆内存，或则还可以使用sbrk函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>; <span class="comment">//成功返回brk的旧值，出错返回-1</span></span><br></pre></td></tr></table></figure></p><p>sbrk函数通过将内核的brk(指向堆顶部)指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1并设置errno为ENOMEM。如果sbrk的参数为0，则返回的为原来的brk地址。</p><h4 id="1-3-free函数"><a href="#1-3-free函数" class="headerlink" title="1.3 free函数"></a>1.3 free函数</h4><p>程序通过调用free函数来释放已分配的堆块。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">//不返回值</span></span><br></pre></td></tr></table></figure></p><p>ptr必须指向一个已分配块的起始位置，如果不是，那么free的行为就是未定义的。</p><h3 id="2、为什么要使用动态内存"><a href="#2、为什么要使用动态内存" class="headerlink" title="2、为什么要使用动态内存"></a>2、为什么要使用动态内存</h3><p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如我们需要根据输入的n分配一个对应大小的数据来临时存储数据，这是就用动态分配比较好。</p><blockquote><p>值得注意的是，c99提供了动态的数组大小分配，可以不再需要由程序员显式分配动态空间。不过这种分配方式是否是堆上的空间就需要进一步验证了。</p></blockquote><h3 id="3、分配器的要求和目标"><a href="#3、分配器的要求和目标" class="headerlink" title="3、分配器的要求和目标"></a>3、分配器的要求和目标</h3><p>显式分配器必须在一些相当严格的约束条件下工作：</p><ul><li><strong>处理任意请求序列</strong>：一个应用可以有任意的分配请求和释放请求序列，分配器不可以假设分配和释放请求的顺序。</li><li><strong>立即响应请求</strong>：分配器必须立即响应分配请求。因此不允许分配器提高性能，从新排列或者缓冲请求。</li><li><strong>只使用堆</strong>：分配器使用的任何数据结构都保存在堆里。</li><li><strong>对齐块</strong>：比如8个字节的对齐。</li><li><strong>不修改已分配的块</strong>：分配器只能操作或者改变空闲块，不允许不能压缩已分配的块。</li></ul><p>分配器在满足上述要求的情况下，需要达到以下两个目标：</p><ul><li>(1)最大化吞吐率,单位时间完成尽可能多的请求。</li><li>(2)最大化存储器的利用率。天真的程序员经常不正确的假设虚拟存储器是一个无限的资源<strong>，事实上，一个系统中被所有进程分配的虚拟存储器的全部数量是受磁盘上交换空间的数量限制的</strong>。好的程序员知道虚拟内存是一个有限的空间，必须高效地使用。</li></ul><p>分配器设计中一个有趣的挑战就是在上述两个目标之间找到一个适当的平衡。</p><h3 id="3、碎片"><a href="#3、碎片" class="headerlink" title="3、碎片"></a>3、碎片</h3><p>造成堆的空间利用率很低的主要原因是一种被称为碎片的现象，当虽然有未使用的内存但这块内存并不能满足分配请求时，就会产生碎片。有以下两种形式的碎片：内部碎片和外部碎片。</p><ul><li><strong>内部碎片</strong>：在一个已分配块比有效载荷大时发生。比如分配器限制的最小分配至比实际请求值要大，又或者为了对齐而增加块的大小。意味着已分配但是未使用。</li><li>外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以来处理这个请求时发生。<strong>外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块</strong>。</li></ul><h3 id="4、分配器设计"><a href="#4、分配器设计" class="headerlink" title="4、分配器设计"></a>4、分配器设计</h3><p>一个分配器需要在吞吐率和利用率之间把握好平衡，必须要考虑以下几个因素：</p><ul><li>组织空闲块：如何组织</li><li>放置：怎么选择一个合适的块来放置新分配的块。</li><li>分割：新分配的块放到某个空闲块后，如何处理剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><h3 id="5、隐式空闲链表"><a href="#5、隐式空闲链表" class="headerlink" title="5、隐式空闲链表"></a>5、隐式空闲链表</h3><h4 id="5-1-组织空闲块"><a href="#5-1-组织空闲块" class="headerlink" title="5.1 组织空闲块"></a>5.1 组织空闲块</h4><p>假设用下图结构来组织堆块，并且已知采用双字对齐，头部后面的就是应用调用malloc时请求的有效载荷。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/30.jpg?raw=true" alt="image"></p><p>分配器将堆组织为下图式样的一个连续的已分配块和空闲块的序列，该序列被称为<strong>隐式空闲链表</strong>。之所以称为隐式空闲链表是因为分配需要遍历堆中所有的块，才能知道空闲块的集合。注意，<strong>图中用一个已分配而大小为的零的块来标记结束</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/31.png?raw=true" alt="image"></p><p>隐式空闲链表的有点是简单，缺点是放置开销会与已分配块和空闲块块的总数呈线性关系。</p><h4 id="5-2-放置已分配的块"><a href="#5-2-放置已分配的块" class="headerlink" title="5.2 放置已分配的块"></a>5.2 放置已分配的块</h4><p>当应用发起一个分配请求时，分配器需要从空闲链表中选择一个合适的块来满足请求。分配器的选择方式称为<strong>放置策略</strong>。常见的放置策略有以下几种：</p><ul><li><strong>首次适配</strong>：从头开始搜索空闲链表，选择第一个遇见的合适的空闲块。它的优点在于趋向于将大的空闲块保留在链表的后面，缺点是它趋向于在靠近链表前部处留下小空闲块的碎片，从而增加较大请求块的放置时间。</li><li><strong>下一次适配</strong>：每次从上一次查询结束的地方开始进行搜索，直到遇见合适的空闲块。这种策略通常比首次适配效率高，但是内存利用率则要低得多了</li><li><strong>最佳适配</strong>：检查每个空闲块，选择适合所需请求大小的最小空闲块。最佳适配的内存利用率是三种策略中最高的，但它需要对堆进行彻底的搜索。</li></ul><h4 id="5-3-分割空闲块"><a href="#5-3-分割空闲块" class="headerlink" title="5.3 分割空闲块"></a>5.3 分割空闲块</h4><p>分配器在匹配到一个合适的空闲块后，就需要决定分配这个空闲块中多少空间，可以称之为分割策略，一般有以下两种方式：</p><ul><li>（1）选择用整个空闲块，这个方式简单而且快捷，缺点是可能会造成很多内部碎片。</li><li>（2）分配器嫁给你空闲块分为两个部分，第一部分变成分配块，而剩下的那部分则组织成一个新的空闲块。</li></ul><h4 id="5-4-合并空闲块"><a href="#5-4-合并空闲块" class="headerlink" title="5.4 合并空闲块"></a>5.4 合并空闲块</h4><p>为了避免假碎片问题，分配器需要在释放一个已分配块时，除了重新标记当前块外也需要合并相邻空闲块。合并空闲块的方式称为合并策略，主要分为两种：</p><ul><li>（1）立即合并：就是在每次释放块时，就立即合并所有相邻块，这种方式可能会产生抖动（比如频繁在一个8字节的空闲块中执行3字节的分配与释放，就可能产生大量不必要的分割与合并）。</li><li>（2）推迟合并：即推迟合并空闲块的时机，比如直到某个分配请求失败才扫描整个堆，合并所有的空闲块。快速的分配器通常会选择某种形式的推迟合并。</li></ul><h4 id="5-5-合并空闲块的具体实现"><a href="#5-5-合并空闲块的具体实现" class="headerlink" title="5.5 合并空闲块的具体实现"></a>5.5 合并空闲块的具体实现</h4><p>对于向后合并，我们可以通过当前块的头部指针判断下一个块是否空闲，从而进行合并，但是如何合并前面的块呢？搜索整个链表？</p><p>Knuth提出了一种叫做<strong>边界标记</strong>的技术用于常数时间对前面的块进行合并。其实现如下图，通过在每个块的结尾处添加一个脚部，其是头部的一个副本。这样分配器就可以通过检查当前块的前一个字节的内容从而判断前一个块的起始位置和状态。</p><p>比如有一个释放当前块，其前一个块和后一块都是空闲的，此时需要将三块的大小求和然后更新前一块的头部和后一块脚部，明显能在常数时间内完成。</p><p>边界标记的一个缺陷是每一块都要保持一个头部和一个脚部，这会导致显著的内存开销。一种可能的优化方案是在已分配的块剩余部分保存脚部信息，从而减小开销。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/32.png?raw=true" alt="image"></p><h3 id="6、显式空闲链表"><a href="#6、显式空闲链表" class="headerlink" title="6、显式空闲链表"></a>6、显式空闲链表</h3><h4 id="6-1-空闲块组织"><a href="#6-1-空闲块组织" class="headerlink" title="6.1 空闲块组织"></a>6.1 空闲块组织</h4><p>其实对于通用的分配器来说，隐式空闲链表是不适合的，一种更好的方法是将空闲块组织为某种形式的显式空闲链表。</p><p>如下图，我们用一个双向链表组织空闲块，为了节省空间，我们将前驱指针pred和后继指针succ放在空闲块的主体当中。双向链表使得首次适配的时间从块总数的线性时间减少到了空闲块总数的线性时间。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/33.png?raw=true" alt="image"></p><p>在释放分配块时，有两种方式，分别为：</p><ul><li><strong>后进先出</strong>LIFO顺序维护链表：将新释放的块放在链表的开始处，加上边界标记后能快速合并完成并放置。<br>-<strong> 按照地址顺序维护链表</strong>：这种方式使得每个块的地址都小于它后继的地址。释放一个块比较麻烦，但是首次适配有更高的内存利用率。</li></ul><p>显式空闲链表的需要存储前向和后向指针，这会限制最小块的大小，从而增加内存碎片。</p><h4 id="6-2-分离的空闲链表"><a href="#6-2-分离的空闲链表" class="headerlink" title="6.2 分离的空闲链表"></a>6.2 分离的空闲链表</h4><p>为了减少分配时间，人们想出了另一种叫做<strong>分离存储</strong>的方法，主要是通过维护多个空闲链表，其中每个链表中的块有大致相等的大小。也即是分配器维护一个空闲链表数组，然后每个空闲链表中的空闲块按照大小进行升序排序。<strong>简单分离存储</strong>中采用的方式是每个空闲链中的空闲块大小一样，而<strong>分离适配</strong>方式的每个空闲链表中的块大小却不一样，这样适配时需要在空闲链表中进行匹配。</p><p>当有一个分配请求时，我们检查相应的空闲链表。如果链表非空，那么就分配其中第一块的全部。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，然后将这些块链接起来形成新的空闲链表。类型vector中的free list。</p><p>要释放一个块，分配器只需要简单地将这个块插入到相应的空闲链表的头部。</p><h3 id="7、垃圾收集"><a href="#7、垃圾收集" class="headerlink" title="7、垃圾收集"></a>7、垃圾收集</h3><p>在编写C程序时，一般只能显式地分配与释放堆中的内存（malloc()与free()），程序员不仅需要分配内存，还需要负责内存的释放。但如果能自动回收是不是更好呢？</p><p><strong>垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块</strong>。这些块被称为垃圾，自动回收堆存储的过程叫做垃圾收集。接下来讨论一种垃圾收集算法——Mark&amp;Sweep法，可以称为标记清除法。</p><h4 id="7-1-垃圾收集器垃圾组织"><a href="#7-1-垃圾收集器垃圾组织" class="headerlink" title="7.1 垃圾收集器垃圾组织"></a>7.1 垃圾收集器垃圾组织</h4><p>垃圾器将内存视为一张有向可达图，组织如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/34.png?raw=true" alt="image"></p><p>垃圾收集器一般采用以下两种（之一）的策略来判断一块堆内存是否为垃圾内存：</p><ul><li><p>引用计数器：在数据的物理空间中添加一个计数器，当有其他数据与其相关时（引用），该计数器加一，反之则减一。通过定期检查计数器的值，只要为0则认为是垃圾内存，可以释放它所占用的已分配块。使用引用计数器，实现简单直接，但缺点也很明显，它无法回收循环引用的两个对象（假设有对象A与对象B，它们2个互相引用，但实际上对象A与对象B都已经是没用的对象了）。</p></li><li><p>可达性分析：垃圾收集器将堆内存视为一张有向图，然后选出一组根节点（例如，在Java中一般为类加载器、全局变量、运行时常量池中的引用类型变量等），根节点必须是足够“活跃“的对象。然后计算从根节点集合出发的可达路径，只要从根节点出发不可达的节点，都视为垃圾内存。</p></li></ul><h4 id="7-2-Mark-amp-Sweep垃圾收集器"><a href="#7-2-Mark-amp-Sweep垃圾收集器" class="headerlink" title="7.2 Mark&amp;Sweep垃圾收集器"></a>7.2 Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。标记-清除算法实现简单，但它的效率不高，而且会产生许多内存碎片。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/35.png?raw=true" alt="image"></p><p>再介绍两种垃圾收集器进行回收的算法：</p><ul><li><p>复制：将程序所拥有的内存空间划分为大小相等的两块，每次都只使用其中的一块。当这一块的内存用完了，就把还存活着的对象复制到另一块内存上，然后将已使用过的内存空间进行清理。这种方法不必考虑内存碎片问题，但内存利用率很低。这个比例不是绝对的，像HotSpot虚拟机为了避免浪费，将内存划分为Eden空间与两个Survivor空间，每次都只使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一个Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例为8：1，只有10%的内存空间会被闲置浪费。</p></li><li><p>分代：分代算法根据对象的存活周期的不同将内存划分为多块，这样就可以对不同的年代采用不同的回收算法。一般分为新生代与老年代，新生代存放的是存活率较低的对象，可以采用复制算法；老年代存放的是存活率较高的对象，如果使用复制算法，那么内存空间会不够用，所以必须使用标记-清除或标记-整理算法。</p></li></ul><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本节主要讨论动态内存的分配与垃圾回收，主要是大概了解常见的内存管理方式。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《TCP-IP详解卷1》第3章 IP：网际协议</title>
      <link href="/2019/05/23/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC3%E7%AB%A0%20IP%EF%BC%9A%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/05/23/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC3%E7%AB%A0%20IP%EF%BC%9A%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。但是<strong>IP提供不可靠、无连接的数据报传送服务</strong>。</p><p>不可靠在于它不能保证IP数据报能成功到达目的地，仅提供最好的传输服务。IP在传输服务时出现错误(如，路由器的缓冲区用完了)，直接丢弃该数据报，然后通过ICMP消息给信源端。任何可靠性都必须由上层如TCP来提供。</p><p>无连接意味着IP不维护任何关于后续数据报的状态信息，每个数据报的处理都是独立的，可以不按顺序接收。不同的数据报都要独立地进行路由选择，可能选择不同的路线。</p><p>在本章，我们将简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。还要介绍两个有用的命令：ifconfig和netstat。<br><a id="more"></a></p><h3 id="1、IP首部"><a href="#1、IP首部" class="headerlink" title="1、IP首部"></a>1、IP首部</h3><p>IP数据报的格式如下图所示。普通的IP首部长为20个字节，除非含有选项字段。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/37.png?raw=true" alt="image"></p><p>IP的数据存储中，最高位在左边，记为0 bit；最低位在右边，记为31 bit。传输时则先0-7bit，最后24-31bit。也就是从高位到低位进行传输，这种传输顺序叫做Big endian字节序，由于TCP/IP首部的二进制整数也是这种传输顺序，因此也叫做网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</p><ul><li>(1) 目前版本协议号是4，因此IP有时也称作IPv4。</li><li>(2) 首部长度指的是首部占32bit字的数目，因此首部最长为60个字节(15*4)。普通IP数据报（没有任何选择项）字段的值是5。</li><li>(3) 服务类型(TOS):包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。现在大多数的TCP/IP实现都不支持TOS特性，</li><li>(4) 总字段长度是指整个IP数据报的长度，以字节为单位。所以IP数据报最长可达65535字节。尽管最长可传输65535字节的IP数据报，但是大多数的链路层都会对它进行分片。<strong>主机限制用户数据报长度为512字节，小于576字节</strong>。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容。</li><li>(5) 标识字段唯一的标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。<br>(6)TTL(Time to live)：生存时间字段设置了数据报可以经过的最多路由器数。通常为32或64。一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li><li>(7) 首部检验和字段是根据IP首部计算的校验和码。方法：对首部中每个16bit进行二进制反码求和。结果存在检验和字段中。</li><li>(8) 每一份IP数据报都包含源IP地址和目的IP地址。</li><li>(9) 最后一个字段是任选项，是数据报中的一个可变长的可选信息。选项字段一直都是以32bit作为界限，在必要的时候插入值为0的填充字节。</li></ul><h3 id="2、IP路由选择"><a href="#2、IP路由选择" class="headerlink" title="2、IP路由选择"></a>2、IP路由选择</h3><p>IP路由过程中，如果目的主机与源主机直接相连或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。</p><p>IP层在内存中有一个路由表。当收到一份数据报并进行发送时，都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果是，数据报就被送到由<strong>IP首部协议字段</strong>所指定的 协议模块进行处理，如果不是，则对数据包进行路由或者丢弃。</p><p>路由表中包含以下几项信息：</p><ul><li>(1) 目的IP地址；</li><li>(2) 下一站(下一跳)路由器(next-hop-router)的IP地址，或者有直接连接的网络IP地址。</li><li>(3) 标识。其中一个标识指明目的IP地址是网络地址还是主机地址，另一个标识指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li><li>(4) 为数据报的传输指定一个网络接口。</li></ul><p>IP路由选择主要完成以下功能</p><ul><li>(1) 搜索路由表，寻找能与<strong>目的IP地址</strong>完全匹配的表目；如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li><li>(2) 搜索路由表，寻找能与<strong>目的网络号</strong>相匹配的表目；如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li><li>(3) 搜索路由表，寻找<strong>默认路由表的表目</strong>。如果找到，则把报文发送给该表目指定的下一站路由器。</li></ul><p>为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模，比如Internet上的路由器有只有几千个表目，而不会是超过100万个表目。</p><p>IP数据包在路由时，需要注意以下几点：<br> (1) 数据报中的目的IP地址始终不发生任何变化。<br> (2) 每个链路层可能具有不同的数据帧首部，数据帧中的目的MAC地址始终指的是下一站结点的MAC地址。</p><h3 id="3、子网寻址"><a href="#3、子网寻址" class="headerlink" title="3、子网寻址"></a>3、子网寻址</h3><p> 现在所有的主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。样做的原因是因为A类和B类地址为主机号分配了太多的空间，事实上，在一个网络中人们并不安排这么多的主机。例如，这里有一个B类网络地址（140.252..），在剩下的16bit中，8bit用于子网号，8bit用于主机号。这样就允许25 4个子网，每个子网可以有254台主机(0或全1的主机号都是无效的，因此我们把总数减去2)。</p><p>子网对外部路由器来说隐藏了内部网络组织的细节，对于外部来说只需要一个IP地址即可，这样能极大地缩减路由表的规模，对于内部来说各个子网又互相透明，体会不到划分的存在。</p><h3 id="4、子网掩码"><a href="#4、子网掩码" class="headerlink" title="4、子网掩码"></a>4、子网掩码</h3><p> 主机在引导时进行的部分配置之一是指定主机的IP地址。除了IP地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号，而这是在引导过程中通过子网掩码来确定的。这个掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p><p> 子网掩码却经常用十六进制来表示，特别是当界限不是一个字节时，因为子网掩码是一个比特掩码。给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的地址（本子网、其他子网、其他网络）。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/38.png?raw=true" alt="image"></p><p> 如果知道本机的IP地址，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。比较时由网络号到子网号到主机号。</p><h3 id="5、特殊情况的IP地址"><a href="#5、特殊情况的IP地址" class="headerlink" title="5、特殊情况的IP地址"></a>5、特殊情况的IP地址</h3><p>下图介绍7个特殊的IP地址，在这个图中，0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/39.png?raw=true" alt="image"></p><p>表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。表中的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。</p><h3 id="6、ifconfig命令"><a href="#6、ifconfig命令" class="headerlink" title="6、ifconfig命令"></a>6、ifconfig命令</h3><p>到目前为止，我们已经讨论了链路层和IP层，现在可以介绍TCP/IP对网络接口进行配置和查询的命令了。ifconfig命令一般在引导时运行，以配置主机上的每个接口。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">root</span>@<span class="selector-tag">DESKTOP-QI6PGJM</span>:/<span class="selector-tag">mnt</span>/<span class="selector-tag">d</span>/<span class="selector-tag">wsl_workspace</span>/<span class="selector-tag">MyCode_GitHub</span># <span class="selector-tag">ifconfig</span> <span class="selector-tag">-a</span></span><br><span class="line"><span class="selector-tag">eth0</span>      <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Ethernet</span>  <span class="selector-tag">HWaddr</span> <span class="selector-tag">40</span><span class="selector-pseudo">:8d</span><span class="selector-pseudo">:5c</span><span class="selector-pseudo">:0e</span><span class="selector-pseudo">:35</span><span class="selector-pseudo">:c9</span></span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:172.16.10.38</span>  <span class="selector-tag">Bcast</span><span class="selector-pseudo">:172.16.255.255</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.255.0.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-tag">fe80</span><span class="selector-pseudo">::50d0</span><span class="selector-pseudo">:c0b7</span><span class="selector-pseudo">:e553</span><span class="selector-pseudo">:b163</span>/<span class="selector-tag">64</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Unknown</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">BROADCAST</span> <span class="selector-tag">RUNNING</span> <span class="selector-tag">MULTICAST</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">lo</span>        <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Local</span> <span class="selector-tag">Loopback</span></span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:127.0.0.1</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.0.0.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-pseudo">::1</span>/<span class="selector-tag">128</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Unknown</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">LOOPBACK</span> <span class="selector-tag">RUNNING</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)</span><br></pre></td></tr></table></figure></p><p>环回接口被认为是一个网络接口。它是一个A类地址，没有进行子网划分。</p><p>ifconfig命令一般支持TCP/IP以外的其他协议族，而且有很多参数。关于这些细节可以查看系统说明书。</p><h3 id="7、netstat命令"><a href="#7、netstat命令" class="headerlink" title="7、netstat命令"></a>7、netstat命令</h3><p>netstat命令也提供系统上的接口信息。-i参数将打印出接口信息，-n参数则打印出IP地址，而不是主机名字。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-QI6PGJM:/mnt/d/wsl_workspace/MyCode_GitHub# netstat -i</span><br><span class="line">Kernel<span class="built_in"> Interface </span>table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">eth1       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">eth2       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">lo         1500 0         0      0      0 0             0      0      0      0 LRU</span><br><span class="line"></span><br><span class="line">root@DESKTOP-QI6PGJM:/mnt/d/wsl_workspace/MyCode_GitHub# netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local<span class="built_in"> Address </span>          Foreign<span class="built_in"> Address </span>        State</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags      <span class="built_in"> Type </span>      State         I-Node   Path</span><br></pre></td></tr></table></figure><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本章开始描述了IP首部的格式，并简要讨论了首部中的各个字段。我们还介绍了IP路由选择，并指出主机的路由选择可以非常简单：如果目的主机在直接相连的网络上，那么就把数据报直接传给目的主机，否则传给默认路由器。</p><p>在进行路由选择决策时，主机和路由器都使用路由表。在表中有三种类型的路由：特定主机型、特定网络型和默认路由型。路由表中的表目具有一定的优先级。在选择路由时，主机路由优先于网络路由，最后在没有其他可选路由存在时才选择默认路由。</p><p>IP路由选择是通过逐跳来实现的。数据报在各站的传输过程中目的IP地址始终不变，但是封装和目的链路层地址在每一站都可以改变。大多数的主机和许多路由器对于非本地网络的数据报都使用默认的下一站路由器。</p><p>A类和B类地址一般都要进行子网划分。用于子网号的比特数通过子网掩码来指定子网的划分缩小了Internet路由表的规模，因为许多网络经常可以通过单个表目就可以访问了。接口和网络的有关信息通过ifconfig和netstat命令可以获得，包括接口的IP地址、子网掩码、广播地址以及MTU等。</p><p>在本章的最后，我们对Internet协议族潜在的改进建议—下一代IP进行了讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》常见问题总结</title>
      <link href="/2019/05/23/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/23/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>《STL源码剖析》在学习完了之后也总结完了，但是感觉还是有些不太明白的地方，查了一些资料，总结了一下别人面试常遇到的问题，算是复习巩固，也是为了之后的找工作准备。</p><a id="more"></a><h3 id="一、关于容器的一些问题"><a href="#一、关于容器的一些问题" class="headerlink" title="一、关于容器的一些问题"></a>一、关于容器的一些问题</h3><h4 id="1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？"><a href="#1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？" class="headerlink" title="1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？"></a>1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？</h4><ul><li>如果vector内存用完了，会以当前size大小重新申请2*size的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。</li><li><p>一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap，这样，但其实这些内存也只是放到内存池，并不能被外部使用。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">type</span>&gt; v;</span><br><span class="line"><span class="comment">//.... 这里添加许多元素给v</span></span><br><span class="line"><span class="comment">//.... 这里删除v中的许多元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">type</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"><span class="comment">//此时v的容量已经尽可能的符合其当前包含的元素数量</span></span><br><span class="line"><span class="comment">//对于string则可能像下面这样</span></span><br><span class="line"><span class="keyword">string</span>(s).<span class="built_in">swap</span>(s);</span><br></pre></td></tr></table></figure></li><li><p>关于线程安全，引用《effective stl》的第十二条：当涉及 STL容器和线程安全性时，你可以指望一个 STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望 STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。<strong>必须自己去写多线程安全措施</strong>。</p></li></ul><h4 id="2、写多读少应该用什么容器？"><a href="#2、写多读少应该用什么容器？" class="headerlink" title="2、写多读少应该用什么容器？"></a>2、写多读少应该用什么容器？</h4><p>关于容器的使用，可以总结以下几条规律：</p><ul><li>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector； </li><li>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list； </li><li>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque； </li><li>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap； </li><li>（5）如果打算查找一个元素是否存在于某集合中并且有序，唯一存在的情况使用set，不唯一存在的情况使用multiset。</li></ul><p>这里应该选用链表，链表的插入操作时常数时间复杂度，访问操作是O(n)，是最适合写多读少的容器。</p><h4 id="3、vector每次insert或erase之后，以前保存的iterator会不会失效？"><a href="#3、vector每次insert或erase之后，以前保存的iterator会不会失效？" class="headerlink" title="3、vector每次insert或erase之后，以前保存的iterator会不会失效？"></a>3、vector每次insert或erase之后，以前保存的iterator会不会失效？</h4><p>理论上会失效，理论上每次insert或者erase之后，所有的迭代器就重新计算的，所以都可以看作会失效，<strong>原则上是不能使用过期的内存</strong>，实际是否失效，需要分情况讨论：</p><p>（1）  insert时，假设insert位置在p，分两种情况：  </p><ul><li>(a) 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效</li><li>(b) 容器重新分配了内存，那么所有的迭代器都无效。</li></ul><p>（2）  erase时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置（如果之前p在尾巴上，则p指向无效尾end），p之后的迭代器都无效。</p><h4 id="4、-auto-ptr可以做vector的元素呢？为什么？"><a href="#4、-auto-ptr可以做vector的元素呢？为什么？" class="headerlink" title="4、 auto_ptr可以做vector的元素呢？为什么？"></a>4、 auto_ptr可以做vector的元素呢？为什么？</h4><p>不能。因为STL的标准容器规定它所容纳的元素必须是可以拷贝构造和可被转移赋值的。而auto_ptr不能，可以用shared_ptr智能指针代替。</p><h4 id="5、为何map和set的插入删除效率比用其他序列容器高？"><a href="#5、为何map和set的插入删除效率比用其他序列容器高？" class="headerlink" title="5、为何map和set的插入删除效率比用其他序列容器高？"></a>5、为何map和set的插入删除效率比用其他序列容器高？</h4><p>map和set容器的底层都是由RB-tree实现，各个节点间相互独立，由指针将其组织起来形成树结构。因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了；删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><h4 id="6、为何map和set不能像vector一样有个reserve函数来预分配数据？"><a href="#6、为何map和set不能像vector一样有个reserve函数来预分配数据？" class="headerlink" title="6、为何map和set不能像vector一样有个reserve函数来预分配数据？"></a>6、为何map和set不能像vector一样有个reserve函数来预分配数据？</h4><p>map和set内部存储的已经不是元素本身了，而是包含元素的节点。也就是说map内部使用的Alloc并不是map声明的时候从参数中传入的Alloc。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Alloc&gt; intmap;</span><br></pre></td></tr></table></figure></p><p>这时候在intmap中使用的allocator并不是Alloc, 而是通过了转换的Alloc，具体转换的方法时在内部通过<br>Alloc::rebind重新定义了新的节点分配器，详细的实现参看彻底学习STL中的Allocator。<br>其实你就记住一点，<strong>在map和set里面的分配器已经发生了变化，reserve方法你就不要奢望了</strong>。</p><h4 id="7、-当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？"><a href="#7、-当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？" class="headerlink" title="7、 当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？"></a>7、 当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？</h4><p>算一下就知道了，首先你得知道map和set的底层都是红黑树，红黑树的搜索近似于二分查找，二分查找呢，平均时间复杂度是O(log2n),这里简写成logn:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">log</span><span class="params">(<span class="number">10000</span>)</span></span> = <span class="number">13.3</span></span><br><span class="line"><span class="function"><span class="title">log</span><span class="params">(<span class="number">20000</span>)</span></span> = <span class="number">14.3</span></span><br></pre></td></tr></table></figure></p><p>可以看到，当数据量增大一倍的时候，搜索次数只不过多了1次,增长速度很慢。</p><h4 id="8、为何map和set中每次insert之后，以前保存的iterator不会失效？"><a href="#8、为何map和set中每次insert之后，以前保存的iterator不会失效？" class="headerlink" title="8、为何map和set中每次insert之后，以前保存的iterator不会失效？"></a>8、为何map和set中每次insert之后，以前保存的iterator不会失效？</h4><p>map和set中iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。</p><p>相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：<strong>不要使用过期的iterator</strong>。</p><h4 id="9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？"><a href="#9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？" class="headerlink" title="9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？"></a>9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？</h4><ul><li>map用红黑实现。</li><li>用红黑树的效率为O(logn)</li><li>map不可以边遍历边插入，map不像vector，它在对容器执行erase操作后不会返回后一个元素的迭代器，所以不能遍历地往后删除。</li></ul><h4 id="10、-hash-map和map的区别在哪里？"><a href="#10、-hash-map和map的区别在哪里？" class="headerlink" title="10、 hash_map和map的区别在哪里？"></a>10、 hash_map和map的区别在哪里？</h4><p>hash_map底层是散列的所以理论上操作的平均复杂度是常数时间，map底层是红黑树，理论上平均复杂度是O(logn)。</p><p>选用map还是hash_map，<strong>关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间</strong>。如果查询次数比较少看中单个效率，那么更偏向于选择map，这是因为map的每一次查询时间基本稳定，此时如果用hash_map可能会因为碰撞而导致O(N)的时间复杂度。如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。</p><h3 id="二、关于迭代器的一些问题"><a href="#二、关于迭代器的一些问题" class="headerlink" title="二、关于迭代器的一些问题"></a>二、关于迭代器的一些问题</h3><h4 id="1、-traits技术原理及应用"><a href="#1、-traits技术原理及应用" class="headerlink" title="1、 traits技术原理及应用"></a>1、 traits技术原理及应用</h4><p>traits技术原理主要为：<strong>模板参数推导机制+内嵌类型定义+模板偏特化</strong>。</p><p>在STL算法中用到迭代器时，会用到迭代器所指之物的型别，假设算法要设定返回值类型，以迭代器所指之物为型别，但是C++只支持sizeof()、并未<br>支持typeof()，即使typeid()，也只能获得型别名称，不能拿来声明变量，所以这里就要用到作为”特性萃取机“的traits技术。为了解决原生指针问题，引入了萃取层模板偏特化。</p><h3 id="三、关于算法的一些问题"><a href="#三、关于算法的一些问题" class="headerlink" title="三、关于算法的一些问题"></a>三、关于算法的一些问题</h3><h4 id="1、快排算法的枢轴位置是怎么选择的？"><a href="#1、快排算法的枢轴位置是怎么选择的？" class="headerlink" title="1、快排算法的枢轴位置是怎么选择的？"></a>1、快排算法的枢轴位置是怎么选择的？</h4><p>三点中值法，取整个序列的头、尾、中央三个位置的元素，以其中值作为枢轴。函数栈达到一定层数后会选择插入排序避免递归过多。</p><h4 id="2、简单说一下next-permutation和partition的实现？"><a href="#2、简单说一下next-permutation和partition的实现？" class="headerlink" title="2、简单说一下next_permutation和partition的实现？"></a>2、简单说一下next_permutation和partition的实现？</h4><ul><li><p>（1）next_permutation（下一个排列）<br>首先，从最尾端开始往前寻找两个相邻元素，另第一个元素为i，第二个元素为ii，且满足i&lt;ii。找到这样一组相邻元素后，再从尾端开始往前检验，找出第一个大于i的元素j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求“下一个”排列组合。</p></li><li><p>（2）partition<br>令头端迭代器first向尾部移动，尾部迭代器last向头部移动。当first所指的值大于或等于枢轴时就停下来，当last所指的值小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果first仍然在last左边，就将连着元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。如果发现两个迭代器交错了，表示整个序列已经调整完毕。</p></li></ul><h3 id="四、关于内存配置的一些问题"><a href="#四、关于内存配置的一些问题" class="headerlink" title="四、关于内存配置的一些问题"></a>四、关于内存配置的一些问题</h3><h4 id="1、stl对于小内存块请求与释放怎么处理的？"><a href="#1、stl对于小内存块请求与释放怎么处理的？" class="headerlink" title="1、stl对于小内存块请求与释放怎么处理的？"></a>1、stl对于小内存块请求与释放怎么处理的？</h4><p>STL考虑到小型内存区块的碎片问题，设计了<strong>双层级配置器</strong>，第一级配置直接使用malloc()和free()；第二级配置器则视情况采用不同的策略，当配置区大于128bytes时，直接调用第一级配置器；当配置区块小于128bytes时，便不借助第一级配置器，而使用一个memory pool来实现。究竟是使用第一级配置器还是第二级配置器，由一个宏定义来控制。<strong>SGI STL中默认使用第二级配置器</strong>。 </p><p>二级配置器会<strong>将任何小额区块的内存需求量上调至8的倍数</strong>，并且在它内部会维护16个free-list， 各自管理大小分别为8， 16，24，…，128bytes的小额区块，这样当有小额内存配置需求时，直接从对应的free list中拔出对应大小的内存(8的倍数)；当客户端归还内存时，将根据归还内存块的大小，将需要归还的内存插入到对应free list的最顶端。  </p><p>有点主要体现在：</p><ul><li>1）小对象的快速分配和释放。当一次性预先分配好一块固定大小的内存池后，对小于128字节的小块内存分配和释放的操作只是一些基本的指针操作，相比于直接调用malloc/free，开销小。  </li><li>2）避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间，而且会给OS的内存管理造成压力。  </li><li>3）尽可能最大化内存的利用率。当内存池尚有的空闲区域不足以分配所需的大小时，分配算法会将其链入到对应的空闲列表中，然后会尝试从空闲列表中寻找是否有合适大小的区域，  </li></ul><p>但是，这种内存分配器局限于STL容器中使用，并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中，而STL容器是知道它所需分配的对象大小的，比如上述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stl::<span class="built_in">vector</span> <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure></p><p>array是知道它需要分配的对象大小为sizeof(int)。一个通用的内存分配器是不需要知道待释放内存的大小的，类似于free(p)。  </p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.限制条件求和</title>
      <link href="/2019/05/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%B1%82%E5%92%8C/"/>
      <url>/2019/05/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>开一下脑洞 </p><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><a id="more"></a></p><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><h4 id="（1）常规解法"><a href="#（1）常规解法" class="headerlink" title="（1）常规解法"></a>（1）常规解法</h4><p>这个题《剑指offer》提出了四种解法，分别如下：</p><ul><li>函数指针: 指针数组指向两个函数，!!n进行下标选择      </li><li>模板： 指定参数和不指定参数</li><li>构造函数： 构造函数每次一个静态变量+k，构造n个对象</li><li>虚函数: 父子类同一个方法，分别做累加和返回0，基类对象指针数组选择对应的虚函数进行求值</li></ul><h4 id="（2）有意思的解法"><a href="#（2）有意思的解法" class="headerlink" title="（2）有意思的解法"></a>（2）有意思的解法</h4><ul><li><p>pow函数：直接用pow函数进行求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">pow</span>(n,<span class="number">2</span>)+n)&gt;&gt;<span class="number">1</span>;<span class="comment">//直接求结果n(n+1)/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>判断条件求解：通过隐式调用条件判断进行求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>)); <span class="comment">//这里隐式调用了条件判断，不为0就递归</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>等价替换：用一些等价操作来进行替换，从而实现转换操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">//等价于求n(n+1)/2 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];  <span class="comment">//等价于求n(n+1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>; <span class="comment">//等价于上述结果除2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常：用异常来作为作为结束条件</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Sum_Solution(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>(n);<span class="comment">//递归求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span>(<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>%n; <span class="comment">//n为0时出现异常</span></span><br><span class="line">            <span class="keyword">return</span> n+<span class="keyword">sum</span>(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//捕获异常并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 思维扩散 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《TCP-IP详解卷1》第2章 链路层</title>
      <link href="/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC2%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC2%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>在TCP/IP协议族中，链路层主要有三个目的：</p><ul><li>（1）为IP模块发送和接收IP数据报；   </li><li>（2）为ARP模块发送ARP请求和接收ARP应答；</li><li>（3）为RARP发送RARP请求和接收RARP应答。</li></ul><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p><p>本节我们将详细讨论以太网链路层协议，两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。对MTU（最大传输单元）进行了介绍，这个概念在本书的后面章节中将多次遇到。我们还讨论了如何为串行线路选择MTU。<br><a id="more"></a></p><h3 id="1、以太网和IEEE-802封装"><a href="#1、以太网和IEEE-802封装" class="headerlink" title="1、以太网和IEEE 802封装"></a>1、以太网和IEEE 802封装</h3><p>以太网是指数字设备公司、英特尔公司（Intel Corp）和 Xerox 公司在1982年联合公布的一个标准；<strong>它是当今TCP/IP采用的主要的局域网技术</strong>。它采用一种称作CSMA/CD的媒体接入方法，其意思是带冲突检测的载波侦听多路接入。它的速率为10Mb/s，地址为48bit。</p><p>802是IEEE（电子电气工程师协会）802委员会公布的一个稍有不同的标准集合。其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网络。</p><p>在TCP/IP世界中，<strong>以太网IP数据报的封装是在RFC894中定义的，IEEE 802网络的IP数据报封装是在RFC1042中定义的</strong>。RFC要求主机必须支持以太网格式的封装，默认也是以太网格式。下图显示了两种不同形式的封装格式：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/34.png?raw=true" alt="image"></p><p>两种帧格式都采用48 bit（6字节）的目的地址和源地址。这就是我们在本书中所称的硬件地址。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。接下来的2个字节在两种帧格式中互不相同。在802标准定义的帧格式中，长度字段是指它后续数据的字节长度，但不包括CRC检验码。CRC字段用于帧内后续字节差错的循环冗余码检验（检验和）。</p><p>在以太网帧格式中，类型字段之后就是数据；而在802帧格式中，跟随在后面的是3字节的802.2LLC和5字节的802.2SNAP。目的服务访问点DSAP和源服务访问点SSAP的值都设为0xaa。Ctrl字段的值设为3。随后的3个字节org code都置为0。</p><p><strong>802.3标准定义的帧和以太网的帧都有最小长度要求</strong>。802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充字节。</p><blockquote><p>从以太网的封装格式可以看出，我们需要一种协议来正确提取IP数据报的信息，所以引入了接下来两节将要讨论的问题。</p></blockquote><h3 id="2、SLIP：串行线路IP"><a href="#2、SLIP：串行线路IP" class="headerlink" title="2、SLIP：串行线路IP"></a>2、SLIP：串行线路IP</h3><p>SLIP的全称是Serial Line IP；它是一种在串行线路上对IP数据报进行封装的简单形式，在RFC 1055中有详细描述；<strong>SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet</strong>。</p><p>SLIP协议以以下几条规则定义帧格式：</p><blockquote><ul><li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符；</li><li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它；0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同；</li><li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它;</li></ul></blockquote><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/35.png?raw=true" alt="image"></p><p>SLIP是一种简单的帧封装方法，还有一些不得一提的缺陷,如：</p><ul><li>每一端必须知道对方的IP地址，没有办法把本端的IP地址通知给另一端；</li><li>数据帧中没有类型字段（类似于以太网中的类型字段），如果一条串行线路用于SLIP，那么它不能同时使用其他协议；</li><li>SLIP没有在数据帧中加上检验和，需要上层协议提供某种形式的CRC；</li></ul><h3 id="3、CSLIP：压缩的SLIP"><a href="#3、CSLIP：压缩的SLIP" class="headerlink" title="3、CSLIP：压缩的SLIP"></a>3、CSLIP：压缩的SLIP</h3><p>由于串行线路的速率通常较低，而且通信经常是交互式的，因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节；于是人们提出一个被称作CSLIP（即压缩SLIP）的新协议，它在RFC 1144中被详细描述；</p><p>CSLIP一般能把上面的40个字节压缩到3或5个字节来记录变化部分。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。</p><h3 id="4、PPP：点对点协议"><a href="#4、PPP：点对点协议" class="headerlink" title="4、PPP：点对点协议"></a>4、PPP：点对点协议</h3><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p><ul><li>在串行链路上封装IP数据报。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接;</li><li>建立、配置及测试数据链路的<strong>链路控制协议LCP</strong>。它允许通信双方进行协商，以确定不同的选项;</li><li>针对不同网络层协议的<strong>网络控制协议NCP</strong>体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk;例如，IP NCP允许双方商定是否对报文首部进行压缩;</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/36.png?raw=true" alt="image"></p><p>上图是PPP数据帧的格式。每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</p><p>总的来说，PPP比SLIP具有下面这些优点：</p><ul><li>(1) PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li><li>(2) 每一帧都有循环冗余检验；</li><li>(3) 通信双方可以进行IP地址的动态协商(使用NCP)；</li><li>(4) 与CSLIP类似，对TCP和IP报文首部进行压缩；</li><li>(5) 链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li></ul><blockquote><p>尽管PPP比SLIP有更多的优点，但是现在的SLIP用户仍然比PPP用户多。随着产品越来越多，产家也开始逐渐支持PPP，因此最终PPP应该取代SLIP。</p></blockquote><h3 id="5、环回接口"><a href="#5、环回接口" class="headerlink" title="5、环回接口"></a>5、环回接口</h3><p>大多数的产品都支持环回接口，以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。<strong>多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现</strong>。其主要实现原理就是将IP数据报通过内核的IP输出函数放到IP输入队列中，从而进行输入处理。</p><p>需要注意以下几个关键点：</p><ul><li>传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。</li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。</li><li>任何传给该主机IP地址的数据均送到环回接口。</li></ul><h3 id="6、最大传输单元MTU"><a href="#6、最大传输单元MTU" class="headerlink" title="6、最大传输单元MTU"></a>6、最大传输单元MTU</h3><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。<strong>链路层的这个特性称作MTU，最大传输单元</strong>。</p><p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU。</p><h3 id="7、路径MTU"><a href="#7、路径MTU" class="headerlink" title="7、路径MTU"></a>7、路径MTU</h3><p>如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作<strong>路径MTU</strong>。</p><p>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。RFC1191描述了怎么样确定MTU。</p><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本章讨论了Internet协议族中的最底层协议，链路层协议。我们比较了以太网和IEEE802.2/802.3的<strong>链路层封装格式</strong>，以及SLIP和PPP<strong>链路层协议</strong>。由于SLIP和PPP经常用于低速的链路，二者都提供了压缩不常变化的公共字段的方法。这使交互性能得到提高。</p><p>大多数的实现都提供环回接口。访问这个接口可以通过特殊的环回地址，一般为127.0.0.1。也可以通过发送IP数据报给主机所拥有的任一IP地址。当环回数据回到上层的协议栈中时，它已经过传输层和IP层完整的处理过程。</p><p>我们描述了很多链路都具有的一个重要特性，MTU，相关的一个概念是路径MTU。根据典型的串行线路MTU，对SLIP和CSLIP链路的传输时延进行了计算。本章的内容只覆盖了当今TCP/IP所采用的部分数据链路公共技术。TCP/IP成功的原因之一是它几乎能在任何数据链路技术上运行。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第7章 仿函数（函数对象）和配接器</title>
      <link href="/2019/05/22/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC7%E7%AB%A0%20%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89%E5%92%8C%E9%85%8D%E6%8E%A5%E5%99%A8/"/>
      <url>/2019/05/22/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC7%E7%AB%A0%20%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89%E5%92%8C%E9%85%8D%E6%8E%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>所谓的仿函数(functor)，是通过重载()运算符模拟函数形为的类。因此，这里需要明确两点：</p><ul><li>1 仿函数不是函数，它是个类； </li><li>2 仿函数重载了()运算符，使得它的对你可以像函数那样子调用。 </li></ul><p>《Design Patterns》一书提到23个最普及的设计模式，其中对adapter样式的定义如下：<strong>将一个class的接口转换为另一个class 的接口，使原本因接口不兼容而不能合作的classes，可以一起运作</strong>。</p><a id="more"></a><h3 id="1、仿函数"><a href="#1、仿函数" class="headerlink" title="1、仿函数"></a>1、仿函数</h3><p>仿函数是早期的命名，C++标准规定所采用的新名称是函数对象。<strong>函数对象，如其名字一样是指一种具有函数特质的对象</strong>。调用者可以像函数一样的使用这些对象，但必须重载operator()，先产生类对象的一个匿名对象，再调用相应的函数。</p><p>例如在很多STL算法中，都可以看到，我们可以将一个方法作为模板内的参数传入到算法实现中，例如sort的时候我们可以根据我们传入的自定义的compare函数来进行比较排序。解决办法是使用函数指针，或者是将这个“操作”设计为一个所谓的仿函数，再用这个仿函数生成一个对象，并用这个对象作为算法的一个参数。</p><p><strong>那为什么STL不使用函数指针而使用仿函数呢？</strong><br>这主要是因为函数指针不能满足STL对抽象性的要求，<strong>无法和STL的其他组件搭配</strong>以产生更加灵活的效果。</p><h3 id="2、仿函数的可配接性"><a href="#2、仿函数的可配接性" class="headerlink" title="2、仿函数的可配接性"></a>2、仿函数的可配接性</h3><p>仿函数灵活性的关键就在于仿函数。<br>STL仿函数应该有能力被函数适配器修饰，就像积木一样串接，然而，为了拥有配接能力，每个仿函数都必须定义自己的<strong>函数参数类型和返回值类型</strong>，就像迭代器如果要融入整个STL大家庭，也必须按照规定定义自己的5个相应的类型一样。下面主要讲解一元函数和二元函数的基本的相关设计。</p><h4 id="2-1-unary-function"><a href="#2-1-unary-function" class="headerlink" title="2.1 unary_function"></a>2.1 unary_function</h4><p>用来呈现一元函数的参数类型和返回值类型，使用者实现对应的一元仿函数时只需继承这个类并进行事项即可。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="type">class Result&gt; //基类</span></span></span><br><span class="line">Struct unary_function</span><br><span class="line">&#123;</span><br><span class="line">    Typedef Arg argument_type;</span><br><span class="line">    Typedef Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义的一元仿函数可以继承上类来获得类型定义</span></span><br><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Struct negate:<span class="keyword">public</span> unary_function&lt;T,T&gt; <span class="comment">//取反</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span> &#123;<span class="keyword">return</span> –x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-binary-function"><a href="#2-2-binary-function" class="headerlink" title="2.2 binary_function"></a>2.2 binary_function</h4><p>用来呈现二元函数的第一个参数类型、第二个参数类型和返回值类型。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="type">class Arg2</span>, <span class="type">class Result&gt;</span></span></span><br><span class="line">Struct binary_function</span><br><span class="line">&#123;</span><br><span class="line">    Typedef Arg1 first_argument_type;</span><br><span class="line">    Typedef Arg2 second_argument_type;</span><br><span class="line">    Typedef Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Struct plus: <span class="keyword">public</span> binary_function&lt;T,T,T&gt;  <span class="comment">//用法示例，加运算</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)<span class="keyword">const</span> &#123;<span class="keyword">return</span> x+y ;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="3、几种仿函数"><a href="#3、几种仿函数" class="headerlink" title="3、几种仿函数"></a>3、几种仿函数</h3><ul><li><p>算术类仿函数<br>用于算术运算，包括加法：plus<t>，减法：minus<t>，乘法：multiplies<t>，除法：divides<t>，取模：modulus<t>，取反：negate<t>。</t></t></t></t></t></t></p></li><li><p>关系类仿函数<br>用于进行关系运算，包括等于：equal_to<t>，不等于：not_equal_to<t>，大于：greater<t>，大于等于：greater_equal<t>，小于：less<t>，小于等于：less_equal<t>。</t></t></t></t></t></t></p></li><li><p>逻辑类仿函数<br>提供几种逻辑运算，包括逻辑运算and：logical_and<t>，逻辑运算or：logical_or<t>，逻辑运算not：logical_not<t>。</t></t></t></p></li><li><p>证同(identity)、选择(select)、投射(project)<br>证同用于返回本身；选择用于接受一个pair,返回第一个元素或第二个元素；投射传回第一参数，忽略第二参数或相反。</p></li></ul><p><strong>来看一下他们的运用实例</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//算术类仿函数</span></span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; plusobj;</span><br><span class="line">minus&lt;<span class="keyword">int</span>&gt; minusobj;</span><br><span class="line">multiplies&lt;<span class="keyword">int</span>&gt; mulobj;</span><br><span class="line">divides&lt;<span class="keyword">int</span>&gt; divobj;</span><br><span class="line">modulus&lt;<span class="keyword">int</span>&gt; modobj;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; negobj;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//除下面的使用方式外，还可以用临时对象调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; plusobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minusobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//-2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mulobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//15</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; divobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; modobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; negobj(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关系类仿函数，不等于：，大于：greater&lt;T&gt;，大于等于：greater_equal&lt;T&gt;，小于：less&lt;T&gt;，小于等于：less_equal&lt;T&gt;。</span></span><br><span class="line">equal_to&lt;<span class="keyword">int</span>&gt; equal_to_obj; </span><br><span class="line">not_equal_to&lt;<span class="keyword">int</span>&gt; not_equal_to_obj;</span><br><span class="line">greater&lt;<span class="keyword">int</span>&gt; greater_obj;</span><br><span class="line">greater_equal&lt;<span class="keyword">int</span>&gt; greater_equal_obj;</span><br><span class="line">less&lt;<span class="keyword">int</span>&gt; less_obj;</span><br><span class="line">less_equal&lt;<span class="keyword">int</span>&gt; less_equal_obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; equal_to_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; not_equal_to_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greater_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greater_equal_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; less_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; less_equal_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑类仿函数</span></span><br><span class="line">logical_and&lt;<span class="keyword">int</span>&gt; logical_and_obj;</span><br><span class="line">logical_or&lt;<span class="keyword">int</span>&gt; logical_or_obj;</span><br><span class="line">logical_not&lt;<span class="keyword">int</span>&gt; logical_not_obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_and_obj(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_or_obj(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_not_obj(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、配接器"><a href="#4、配接器" class="headerlink" title="4、配接器"></a>4、配接器</h3><p>配接器（Adapter）在STL组件的灵活组合运用功能上，<strong>扮演着轴承、转换器的角色</strong>，即将一个class的接口转换为另一个class的接口，使原本因接口不兼容而不能合作的classes，可以一起运作，它事实上<strong>是一种设计模式</strong>。</p><p>STL 主要提供如下三种配接器：</p><ul><li>（1）改变仿函数（functors）接口，称之为function adapter</li><li>（2）改变容器（containers）接口，称之位container adapter</li><li>（3）改变迭代器（iterators）接口者，称之为iterator adapter</li></ul><h4 id="4-1-容器配接器container-adapter"><a href="#4-1-容器配接器container-adapter" class="headerlink" title="4.1 容器配接器container adapter"></a>4.1 容器配接器container adapter</h4><p>STL 提供的两个容器queue和stack，其实都不过是一种配接器，是对deque （双端队列）接口的修饰而成就自己的容器风貌。queue和stack底层都是由deque构成的，它们封住所有deque对外接口，只开发符合对应原则的几个函数，故它们是适配器，是一个作用于容器之上的适配器。</p><p>如果按照该标准衡量其他容器的话，序列式容器的 set 和 map 其实是对其内部所维护的RB-tree接口的改造。</p><h4 id="4-2-迭代器配接器iterator-adapter"><a href="#4-2-迭代器配接器iterator-adapter" class="headerlink" title="4.2 迭代器配接器iterator adapter"></a>4.2 迭代器配接器iterator adapter</h4><p>STL提供了许多应用于迭代器身上的配接器，包括<strong>insert iterators，reverse iterators，iostream iterators</strong>。</p><p>insert iterators可以将一般迭代器的赋值操作转变为插入操作。此迭代器包括专门从尾端插入操作back_insert_iterator，专门从头端插入操作front_insert_iterator，以及可从任何位置执行插入操作的insert_iterator。因iterator adapters使用接口不是十分直观，STL提供三个相应的函数back_inserter()、front_inserter()、inserter()，从而提高使用时的便利性。</p><p>reverse iterators可以将一般迭代器的行进方向逆转，使原本应该前进的operator++变成了后退操作，使原本应该后退的operator–变成了前进操作。此操作用在“从尾端开始进行”的算法上，有很大的方便性。</p><p>iostream iterators可以将迭代器绑定到某个iostream对象身上。绑定到istream对象身上，为istream_iterator，拥有输入功能；绑定到ostream对象身上，成为ostream_iterator，拥有输出功能。此迭代器用在屏幕输出上，非常方便。</p><h4 id="4-3-functor配接器functor-adapter"><a href="#4-3-functor配接器functor-adapter" class="headerlink" title="4.3 functor配接器functor adapter"></a>4.3 functor配接器functor adapter</h4><p>functor adapters是所有配接器中数量最庞大的一个族群，其配接灵活度是后两者不能及的，可以配接、配接、再配接。其中配接操作包括系结（bind）、否定（negate）、组合（compose）、以及对一般函数或成员函数的修饰（使其成为一个仿函数）。它的价值在于，通过它们之间的绑定、组合、修饰能力，几乎可以无限制地创造出各种可能的表达式（expression），搭配STL算法一起演出。</p><p>由于仿函数就是“将function call操作符重载”的一种class，而任何算法接受一个仿函数时，总是在其演算过程中调用该仿函数的operator()，这使得不具备仿函数之形、却有真函数之实的“一般函数”和“成员函数（member functions）感到为难。<strong>如果”一般函数“和“成员函数”不能纳入复用的体系中，则STL的规划将崩落了一角</strong>。为此，STL提供了为数众多的配接器，使“一般函数”和“成员函数”得以无缝地与其他配接器或算法结合起来。</p><p>所有期望获取配接能力的组件，本身都必须是可配接的，即一元仿函数必须继承自unary_function，二元仿函数必须继承自binary_function，成员函数必须以mem_fun处理过，一般函数必须以ptr_fun处理过。</p><p><strong>一个未经ptr_fun处理过的一般函数，虽然也可以函数指针的形式传给STL算法使用，却无法拥有任何配接能力</strong>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下配接器其实就是把一个一元函数指针包起来；</span></span><br><span class="line"><span class="comment">// 当仿函数被使用时，就调用该函数指针</span></span><br><span class="line">template &lt;class <span class="variable">_Arg</span>, class <span class="variable">_Result</span>&gt;</span><br><span class="line">class pointer_to_unary_function : public unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">  <span class="variable">_Result</span> (*<span class="variable">_M_ptr</span>)(<span class="variable">_Arg</span>);     <span class="comment">// 内部成员，一个函数指针</span></span><br><span class="line">public:</span><br><span class="line">  pointer_to_unary_function() &#123;&#125;</span><br><span class="line">  <span class="comment">// 以下constructor将函数指针记录于内部成员之中</span></span><br><span class="line">  explicit pointer_to_unary_function(<span class="variable">_Result</span> (*<span class="variable">__x</span>)(<span class="variable">_Arg</span>)) : <span class="variable">_M_ptr</span>(<span class="variable">__x</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 通过函数指针执行函数</span></span><br><span class="line">  <span class="variable">_Result</span> operator()(<span class="variable">_Arg</span> <span class="variable">__x</span>) const &#123; return <span class="variable">_M_ptr</span>(<span class="variable">__x</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，使我们能够方便运用pointer_to_unary_function</span></span><br><span class="line">template &lt;class <span class="variable">_Arg</span>, class <span class="variable">_Result</span>&gt;</span><br><span class="line">inline pointer_to_unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt; ptr_fun(<span class="variable">_Result</span> (*<span class="variable">__x</span>)(<span class="variable">_Arg</span>))</span><br><span class="line">&#123;</span><br><span class="line">  return pointer_to_unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt;(<span class="variable">__x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h3><p>本节主要介绍仿函数和配接器这两种思想，二者的主要的目的都是粘合STL的另外三大组件容器、迭代器和算法，理解其意，思而用之，也必能有所收益。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《TCP-IP详解卷1》第1章 概述</title>
      <link href="/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0%20%20/"/>
      <url>/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0%20%20/</url>
      
        <content type="html"><![CDATA[<p>TCP/IP起源于60年代末美国政府资助的一个分组交换网络研究项目。到90年代已发展成为计算机之间最常应用的组网形式。它是一个真正的开放系统，因为协议族的定义及其多种实现可以不用花钱或者花很少的钱就可以公开的得到。它成为被称作”全球互联网”或”因特网”的基础，该广域网（WAN）已包含超过100万台遍布世界各地的计算机。<br><a id="more"></a></p><h3 id="1、分层"><a href="#1、分层" class="headerlink" title="1、分层"></a>1、分层</h3><p>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层协议系统，如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/28.png?raw=true" alt="image"></p><p>每一层负责不同的功能：</p><ul><li>链路层：有时也称作数据链路层或网络接口层。通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆的物理接口细节。</li><li>网络层：有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Interner组管理协议）。</li><li>运输层：主要为两台主机上的应用程序提供<strong>端到端</strong>的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</li><li>应用层：负责处理特定的应用程序细节。常见的应用程序如：Telnet远程登录、 FTP文件传输协议、SMTP简单邮件传送协议。</li></ul><h3 id="2、路由器"><a href="#2、路由器" class="headerlink" title="2、路由器"></a>2、路由器</h3><p>人们又把多个网络连在一起形成一个网络的网络，或称作互连网。一个互连网（Internet）就是一组通过相同协议族互连在一起的网络。</p><p>构成互连网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒。路由器的好处是为不同类型的物理网络提供连接：以太网，令牌环网，点对点的链接和FDDI（光纤分布式数据接口）等等。</p><p>注意，历史上这些盒子称作网关（gateway）,<strong>但现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/29.png?raw=true" alt="image"></p><p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快的把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重发，发送和接受端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p><p>任何具有多个接口的系统，英文都称作是多接口的。一个主机也可以有多个接口，但一般不称做路由器，除非它的功能只是单纯地把分组从一个接口传送到另一个接口。同样，路由器并不一定指那种在互联网中用来转发分组的特殊硬件盒。</p><p>连接网络的另一个途径是使用网桥。<strong>网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连</strong>。网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网。<strong>TCP/IP倾向于使用路由器而不是网桥来连接网络</strong>。</p><h3 id="3、TCP-IP的分层"><a href="#3、TCP-IP的分层" class="headerlink" title="3、TCP/IP的分层"></a>3、TCP/IP的分层</h3><p>在TCP/IP协议族中有很多种协议，下图是TCP/IP协议族中不同层次的协议：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/30.png?raw=true" alt="image"></p><p>TCP和UDP是两种最为著名的运输层协议，二者都是用IP作为网络层协议。</p><p>虽然TCP使用不可靠的IP服务，但它却提供一种可靠的运输层服务。UDP为应用程序发送和接受数据报。一个数据报是指从发送方传输到接收方的一个信息单元。但是与TCP不同的是，UDP是不可靠的，它不能保证数据报能安全无误的到达最终目的。</p><p>ICMP是IP协议的附属协议。IP层用它来与其它主机或路由器交换错误报文和其它重要信息。IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p><p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><h3 id="4、互联网的地址"><a href="#4、互联网的地址" class="headerlink" title="4、互联网的地址"></a>4、互联网的地址</h3><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址具有一定的结构，五类不同的互连网地址格式如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/31.png?raw=true" alt="image"></p><p>这些32位的地址通常写成4个十进制的数，其中每个整数对应一个字节。这种表示方法称作”点分十进制表示法”。</p><h4 id="4-1-A类地址"><a href="#4-1-A类地址" class="headerlink" title="4.1 A类地址"></a>4.1 A类地址</h4><ul><li>⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。   </li><li>⑵ A类地址范围：0.0.0.0 - 127.255.255.255   </li><li>⑶ A类地址中的私有地址和保留地址：              </li><li><ul><li>10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。      </li></ul></li><li><ul><li>127.X.X.X是保留地址，用做循环测试用的。</li></ul></li></ul><h4 id="4-2-B类地址"><a href="#4-2-B类地址" class="headerlink" title="4.2 B类地址"></a>4.2 B类地址</h4><ul><li>⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址,但要扣除全0和全1的主机号。 </li><li>⑵ B类地址范围：128.0.0.0 - 191.255.255.255 </li><li>⑶ B类地址的私有地址和保留地址 </li><li><ul><li>B类网络地址128.0.0.0是不指派的，所以指派的B类最小网络地址是128.1.0.0。</li></ul></li><li><ul><li>169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</li></ul></li></ul><h4 id="4-3-C类地址"><a href="#4-3-C类地址" class="headerlink" title="4.3 C类地址"></a>4.3 C类地址</h4><ul><li>⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个个字节为主机地址。另外第1个字节的前三位固定为110。 </li><li>⑵ C类地址范围：192.0.0.1—223.255.255.254。 </li><li>⑶ C类地址中的私有地址：<br>192.168.X.X是私有地址。</li></ul><h4 id="4-4-D类地址"><a href="#4-4-D类地址" class="headerlink" title="4.4 D类地址"></a>4.4 D类地址</h4><ul><li>⑴ D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110。 </li><li>⑵ D类地址范围：224.0.0.1—239.255.255.254</li></ul><h4 id="4-5-E类地址"><a href="#4-5-E类地址" class="headerlink" title="4.5 E类地址"></a>4.5 E类地址</h4><ul><li>⑴ E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110。 </li><li>⑵ E类地址范围：240.0.0.1—255.255.255.254</li></ul><p>全零0.0.0.0地址对应于当前主机。全“1”的IP地址255.255.255.255是当前子网的广播地址。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255      </p><h3 id="5、域名系统"><a href="#5、域名系统" class="headerlink" title="5、域名系统"></a>5、域名系统</h3><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机。但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p><p>任何一个应用程序都可以调用一个标准的<strong>库函数</strong>来查看给定名字的主机的IP地址。类似地，系统还提供一个逆函数—给定主机的IP地址，查看它所对应的主机名。大多数使用主机名作为参数的应用程序也可以把IP地址作为参数。</p><h3 id="6、封装"><a href="#6、封装" class="headerlink" title="6、封装"></a>6、封装</h3><p>当应用程序使用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），下图描述了数据进入协议栈时的封装过程：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/32.png?raw=true" alt="image"></p><p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段，IP传给网络接口层的数据单元称作IP数据报。通过以太网传输的比特流称作帧（Frame）。</p><p>UDP数据和TCP数据基本一致。唯一的不同是UDP传给IP的数据单元称作UDP数据报，而且UDP的首部长为8字节。</p><p>IP在首部中存入一个长度为8位的数值，称作协议域。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。TCP和UDP都用一个16位的端口号来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。<br>网络接口分别要发送和接收IP，ARP，RARP数据，因此也必须在以太网的帧首部中加入某种形式的标识，以指明生成数据的网络层协议。</p><h3 id="7、分用"><a href="#7、分用" class="headerlink" title="7、分用"></a>7、分用</h3><p>当目的主机接收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用，如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/33.png?raw=true" alt="image"></p><p>协议ICMP和IGMP定位一直是一件很棘手的事情。通常我们把它们和IP放在同一层上，因为它们是IP的附属协议。但是在这里，我们又把它们放在IP层的上面，因为ICMP和IGMP报文都被封装在IP数据报中。</p><h3 id="8、客户-服务器模型"><a href="#8、客户-服务器模型" class="headerlink" title="8、客户-服务器模型"></a>8、客户-服务器模型</h3><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供一些特定的服务。</p><p>可以将这种服务分为两种类型：重复型和并发型。重复型服务器阻塞依次完成各个服务；而并发型服务器则通过创建一个新的进程、任务或线程来处理服务，可以同时为多个客户服务。</p><h3 id="9、端口号"><a href="#9、端口号" class="headerlink" title="9、端口号"></a>9、端口号</h3><p>前面已经指出过，TCP和UDP采用16位的端口号来识别应用程序。</p><p>服务器一般都是通过知名端口号来识别的。例如FTP的端口号为21；Telnet的TCP端口号为23；TFTP的端口号为69。任何TCP/IP实现所提供的服务都用知名的1~1023之间的端口号。这些知名端口号由Internet号分配机构（IANA）来管理。</p><h3 id="10、标准化过程"><a href="#10、标准化过程" class="headerlink" title="10、标准化过程"></a>10、标准化过程</h3><p>所有关于Internet的正式标准都以RFC文档出版。另外，大量的RFC并不是正式的标准，出版只是为了提供信息。RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC1122，数字越大说明RFC的内容越新。</p><h3 id="11、互联网"><a href="#11、互联网" class="headerlink" title="11、互联网"></a>11、互联网</h3><p>internet这个词第一个字母是否大写决定了它具有不同的含义。internet意思是用一个共同的协议族把多个网络连接起来。而Internet指的是世界范围内通过TCP/IP互相通信的所有主机集合。Internet是一个internet，但internet不等于Internet。</p><h3 id="12、小结"><a href="#12、小结" class="headerlink" title="12、小结"></a>12、小结</h3><p>TCP/IP协议族分为四层：链路层，网络层，运输层，应用层，每一层各有不同的责任。在TCP/IP中，网络层和运输层之间的区别是最为关键的：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。</p><p>一个互连网是网络的网络。构建互连网的共同基石是路由器，它们在IP层把网络连在一起。第一个字母大写的Internet是指分布在世界各地的大型互连网，其中包括1万多个网络和超过100万台主机。</p><p>在一个互联网上，每个接口都用IP地址来标识。尽管用户习惯使用主机名而不是IP地址。域名系统为主机名和IP地址之间提供动态的映射。端口号用来标识互相通信的应用程序。服务器使用知名端口号，而客户使用临时设定的端口号。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.约瑟夫环问题</title>
      <link href="/2019/05/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。人都有求生的欲望，问谁是最后一个死？<br><a id="more"></a></p><h3 id="1、题目：孩子们的游戏（圆圈中最后剩下的数）"><a href="#1、题目：孩子们的游戏（圆圈中最后剩下的数）" class="headerlink" title="1、题目：孩子们的游戏（圆圈中最后剩下的数）"></a>1、题目：孩子们的游戏（圆圈中最后剩下的数）</h3><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h3 id="2、题目描述"><a href="#2、题目描述" class="headerlink" title="2、题目描述"></a>2、题目描述</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h3 id="3、解题思路"><a href="#3、解题思路" class="headerlink" title="3、解题思路"></a>3、解题思路</h3><h4 id="解法一：循环链表模拟解决"><a href="#解法一：循环链表模拟解决" class="headerlink" title="解法一：循环链表模拟解决"></a>解法一：循环链表模拟解决</h4><p>既然是一个圆圈，我们很自然就能想到用一个环形链表来进行模拟。创建一个共有n个节点的环形链表， 依次遍历链表删除节点第m个节点，然后继续遍历直到链表中只有一个节点为止。需要注意的是，每一次到达链表尾端的时候都将指针调整到指向第一个节点，从而形成环。</p><p>为了能快速实现代码，用标准模板库的std::list实现就是一个很好的选择。这种解决方案没删除一个数需要遍历m次，所以时间复杂度为O(mn),空间复杂度为O(n)。实现代码如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> LastRemaining_Solution(<span class="built_in">int</span> n, <span class="built_in">int</span> m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span> ||n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        list&lt;<span class="built_in">int</span>&gt; <span class="keyword">number</span>;</span><br><span class="line">        <span class="built_in">int</span> i,cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        for(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">number</span>.push_back(i);</span><br><span class="line">        list&lt;<span class="built_in">int</span>&gt;::iterator iter=<span class="keyword">number</span>.begin();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">number</span>.<span class="built_in">size</span>()<span class="comment">!=1)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==m-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">number</span>.erase(iter++);</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> iter++,cnt++;</span><br><span class="line">            <span class="keyword">if</span>(iter==<span class="keyword">number</span>.<span class="keyword">end</span>()) iter=<span class="keyword">number</span>.begin(); //调整</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">number</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="解法二：数学分析、寻找规律"><a href="#解法二：数学分析、寻找规律" class="headerlink" title="解法二：数学分析、寻找规律"></a>解法二：数学分析、寻找规律</h4><p>假设现在有6个人，计数为3，则：<br><strong>（1）第一次删除</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编号： <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">计数： <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以看出，第一次选中去掉第3个人，编号2。</p><p><strong>（2）第二次删除</strong><br>剩下的人从新编号：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原编号：    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">第一次编号：<span class="number">3</span> <span class="number">4</span> X <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>  =&gt;  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">计数：                      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>可以看出，第二次选中去掉新编号中的第3个人，新编号为2，同时也知道原编号为5。</p><p><strong>（3）第5（n-1）次删除</strong><br>到第5次删除的时候后，将只剩下一个数，即是我们要求的数：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原编号：    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">第一次编号：<span class="number">3</span> <span class="number">4</span> X <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line">第二次编号：<span class="number">0</span> <span class="number">1</span> X <span class="number">0</span> <span class="number">2</span> X </span><br><span class="line">第三次编号：<span class="number">1</span> <span class="number">2</span> X X <span class="number">0</span> X </span><br><span class="line">第四次编号：<span class="number">1</span> X X X <span class="number">0</span> X =&gt; <span class="number">0</span> <span class="number">1</span></span><br><span class="line">计数：                  (<span class="number">0</span>)<span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>可以看出第5次删除选中了第4次编号的第1个人，编号为0，对应的原编号为4。</p><p>从上面的关系中，我们可以看出，每一次的新编号和上次的编号之间存在映射关系：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_number=(old_number-m)%上次编号总人数    </span><br><span class="line">=&gt; old_number=(new_number+m)%上次编号总人数</span><br></pre></td></tr></table></figure></p><p><strong>由于最后只剩下一个人，其new_number明显应该为0，我们可以=&gt;其第四次编号为1=&gt;其第三次编号为1=&gt;其第二次编号为0=&gt;其第一次编号为3=&gt;原编号为0</strong>。故最后剩下的人为第1个，编号为0。</p><p>实现代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//考虑异常情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//最后剩下的数新编号为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result=(result+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 约瑟夫环问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 虚拟内存之Linux内存系统</title>
      <link href="/2019/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BLinux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BLinux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本节按照书籍实例，用一个实际系统的案例研究来总结虚拟内存的讨论，这是一个运行于Linux的Inter Core i7。需要注意的是，虽然我们说64位系统，而且处理器体系也允许64位的虚拟地址空间，但是<strong>实际上，Core i7现在只是支持48位（256TB）虚拟地址空间和52位（4PB）物理地址空间，兼容支持32位（4GB）地址空间</strong>。</p><a id="more"></a><h3 id="1、Core-i7-内存系统结构"><a href="#1、Core-i7-内存系统结构" class="headerlink" title="1、Core i7 内存系统结构"></a>1、Core i7 内存系统结构</h3><p>Core i7的内存系统的结构如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/21.png?raw=true" alt></p><p>由图可知：</p><ul><li>处理器包括4个核、所有核共享L3高速缓存和DDR3内存控制器。</li><li>每个核包含一个层次结构的TLB、一个层次结构的指令高速缓存，以及一组快速的点到点链路，这种QuickPath技术用于与其他核和外部I/O桥直接通信。</li><li>TLB是虚拟寻址的，四路组相联。L1、L2和L3都是物理寻址，分别位8、8和16路组相联。</li><li>Linux使用的是4KB的页。</li></ul><h3 id="2、Core-i7-地址翻译过程"><a href="#2、Core-i7-地址翻译过程" class="headerlink" title="2、Core i7 地址翻译过程"></a>2、Core i7 地址翻译过程</h3><p>翻译过程如图9-22：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/22.png?raw=true" alt></p><p>由图可知Core i7的地址翻译采用了TLB、高速缓存、多级页表等机制，需要注意的是：</p><ul><li>Core i7采用四级页表层次结构。同时每个进程都有它自己的页表层次结构。</li><li>进程运行时，虽然允许页表换进换出，但是与分配了的页相关联的页表都是驻留在内存中的。</li><li><strong>CR3控制器</strong>指向第一级页表的起始地址，<strong>CR3的值是每个进程上下文的一部分，每次上下文切换时，CR3的值都会被恢复</strong>。</li></ul><h3 id="3、第四级页表条目"><a href="#3、第四级页表条目" class="headerlink" title="3、第四级页表条目"></a>3、第四级页表条目</h3><p>图9-24给出了第四级页表中条目的格式：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/23.png?raw=true" alt></p><p>注意一下几点：</p><ul><li>PTE（page table entry）有三个权限位，控制对页的访问，分别是R/W控制读写，U/S是否能在用户模式中访问，XD（禁止执行），禁止从某些内存页取指令，防止缓冲区溢出攻击。</li><li>MMU翻译虚拟地址时，还会更新另外两个内核缺页处理程序会用到的位。A位称为引用位，内核用这个引用位来实现它的页替换算法。<strong>D位（修改位/脏位），告诉内核在复制替换页之前是否必须写回牺牲页</strong>。</li></ul><p>图9-25给出Core i7如何使用四级页表来将虚拟地址翻译成物理地址的。36位VPN被划分为四个9位的片，每个片被用作到一个页表的偏移量，CR3寄存器（控制寄存器3）包含L1页表的物理地址。VPN1提供到一个L1 PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供一个到L2 PTE的偏移量，以此类推。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/24.png?raw=true" alt></p><p><strong>优化地址翻译</strong><br>当CPU需要翻译个虚拟地址时，它就发送一VPN到MMU,发送VPO到高速L1缓存。当MMU向TLB请求一个页表条目时，L1高速缓存正忙着利用VPO位查找对应的组，并读取这个组里的8个标记和相应的数据字。然后等MMU拿到PPN后直接就可以和8个标记进行匹配，决定是否取出其中的值。</p><h3 id="4、Linux虚拟内存系统"><a href="#4、Linux虚拟内存系统" class="headerlink" title="4、Linux虚拟内存系统"></a>4、Linux虚拟内存系统</h3><p>本节主要是了解一个实际的操作系统如何组织虚拟内存和处理缺页。</p><p>Linux为每个进程维护了一个单独的虚拟地址空间如图9-26：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/25.png?raw=true" alt></p><p><strong>进程地址空间分为内核虚拟内存和进程虚拟内存</strong>。</p><ul><li><strong>进程虚拟内存</strong>包括进程的代码和数据段、堆和共享库以及栈段。</li><li><strong>内核虚拟内存</strong>包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构，有趣的是，linux也将一组连续的虚拟页面（大小等于DRAM）映射到相应的一组连续的物理页面，为内核提供了便利的方法来访问物理内存中的任何特定位置</li><li><strong>内核虚拟内存</strong>的其他区域包含每个进程都不相同的数据，比如说页表和内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</li></ul><h4 id="4-1-linux虚拟内存区域"><a href="#4-1-linux虚拟内存区域" class="headerlink" title="4.1 linux虚拟内存区域"></a>4.1 linux虚拟内存区域</h4><p>Linux将虚拟内存组织成一些区域（也叫做段）的集合。一个区域（area）就是已经存在着的（已分配的）虚拟内存的连续片。例如，代码段，数据段，堆，共享库段，以及用户栈都是不同的区域。</p><p>每个存在虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在，并且不能被进程引用。区域的概念很重要，因为它允许虚拟地址空间有间隙。内核不用记录那些不存在的虚拟页，而这样的页也不占用内存、磁盘或者内存本身中的任何额外资源。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/26.png?raw=true" alt></p><p>如上图，内核为系统中的每个进程维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID，指向用户栈的指针，可执行目标文件的名字，以及程序计数器）。</p><p>任务结构中的一个条目指向mm_struct,它描述了虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向第一级页表（页全局目录）的基址，而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。</p><h4 id="4-2-linux缺页异常处理"><a href="#4-2-linux缺页异常处理" class="headerlink" title="4.2 linux缺页异常处理"></a>4.2 linux缺页异常处理</h4><p>假设MMU在试图翻译莫格虚拟地址A时，触发了一个缺页，这个异常导致控制转移到内核的缺页处理程序，进行如下处理：</p><ul><li>（1）判断虚拟地址A是合法的吗？是在某个区域结构定义的区域内吗？缺页处理程序搜索区域结构链表（在链表中构建树来查找），如果不合法，触发一个段错误，终止进程。对应图中情况1</li><li>（2）试图进行的内存访问是否合法？权限对吗？对应图中情况2</li><li>（3）如果是对合法虚拟地址的合法操作，那么就选择一个牺牲页面，如果这个牺牲页面被修改过，就将它交换出去，换入新的页面并更新页表。</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/27.png?raw=true" alt></p><h3 id="5、内存映射"><a href="#5、内存映射" class="headerlink" title="5、内存映射"></a>5、内存映射</h3><p> <strong>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射</strong>。虚拟内存区域可以映射到两种类型的对象中的一种：</p><ul><li><p>Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行的目标文件。文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以<strong>这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面</strong>。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</p></li><li><p>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页面表，将该页面标记为是驻留在内存中的。<strong>注意在磁盘和内存之间并没有实际的数据传送</strong>。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</p></li></ul><p>无论哪种情况下，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。<strong>交换文件</strong>也叫作交换空间或者交换区域。需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p><h3 id="6、再看共享对象"><a href="#6、再看共享对象" class="headerlink" title="6、再看共享对象"></a>6、再看共享对象</h3><p>通过内存映射，一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私用对象。</p><h4 id="6-1-共享对象"><a href="#6-1-共享对象" class="headerlink" title="6.1 共享对象"></a>6.1 共享对象</h4><p>一个进程将共享对象映射到它的虚拟空间的一个区域内，那么这个进程对这个区域的所有写操作，对于那些也把这个共享对象映射到它们虚拟空间内的进程来说，都是可见的。这些变化也都会反映在磁盘的原始对象中，多个进程通过将内存映射和将页表条目指向相同的物理页面实现贡献对象，此时<strong>物理内存中只需要存放共享对象的一个副本</strong>。</p><h4 id="6-2-私有对象写时复制（COW）"><a href="#6-2-私有对象写时复制（COW）" class="headerlink" title="6.2 私有对象写时复制（COW）"></a>6.2 私有对象写时复制（COW）</h4><p>私有对象采用的是写时复制(copy on write)，一个私有对象开始生命周期的方式基本和共享对象一样，在物理内存上只保留一份副本。</p><p>对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。</p><p>一个进程试图写私有区域内的某个页面，那<strong>么这个写操作就会触发一个保护故障</strong>，故障处理程序会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本，然后恢复这个页面的可写权限，如下图所示。之后重新执行这个写指令，则写操作可以正常执行。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/28.png?raw=true" alt></p><p><strong>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分的使用了稀有的物理存储器</strong>。</p><h3 id="7、再看fork函数"><a href="#7、再看fork函数" class="headerlink" title="7、再看fork函数"></a>7、再看fork函数</h3><p>fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的？</p><p>当fork函数被当前进程调用时，内核为新进程创建了各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页表都标记为只读，并将两个进程中的区域结构都标记为私有(设置vm_flags)的写时拷贝。</p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中任一个后来进行写操作时，写时拷贝机制就会创建新页表，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h3 id="8、再看execve函数"><a href="#8、再看execve函数" class="headerlink" title="8、再看execve函数"></a>8、再看execve函数</h3><p>假设运行在当前进程中的程序执行了如下的调用：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">execve("a.out",</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">);</span></span><br></pre></td></tr></table></figure></p><p>execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li>映射私有区域。为新程序的文本、数据、bss（映射到匿名文件）和栈区域创建新的区域结构。所有这些新的区域都是私有的，写时拷贝的。</li><li>映射共享区域。如果a.out程序与共享对象或目标链接，比如标准库，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域中。</li><li>设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><h3 id="9、使用mmap函数的用户级内存映射"><a href="#9、使用mmap函数的用户级内存映射" class="headerlink" title="9、使用mmap函数的用户级内存映射"></a>9、使用mmap函数的用户级内存映射</h3><p>mmap函数为我们在进程的虚拟空间开辟一块新的虚拟内存，可以将一个对象（如文件）映射到这块新的虚拟内存，所以操作新的虚拟内存就是操作这个文件，下面我将介绍mmap函数的运用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>各个参数的意义如下：</p><ul><li>start表示新的虚拟内存从这个地址开始，一般来说取NULL，那么将有内核来分配。</li><li>length表示新的虚拟内存的大小。</li><li>prot表示这块新的虚拟内存的访问权限：<br>PROT_EXEC:可执行<br>PROT_READ:可读<br>PROT_WRITE:可写<br>PROT_NONE:无法访问</li><li>flags标识被映射对象匿名对象、私有对象或共享对象。</li></ul><p>eg:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufp=Mmap(<span class="literal">NULL</span>,size,PROT_READ,MAP_PRIVATE<span class="string">|MAP_ANON,0,0);</span></span><br></pre></td></tr></table></figure></p><p>表示让内核创建一个新的包含size字节的只读、私有、请求二进制0的虚拟内存区域。如果调用成功，那么bufp包含新区域的地址。</p><p>munmap用于删除虚拟内存的区域。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 虚拟内存</title>
      <link href="/2019/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2019/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>为了更有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟内存</strong>(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的俺没交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟地址内存提供了三个重要的能力:</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li><li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ul><a id="more"></a><h3 id="1、物理和虚拟地址"><a href="#1、物理和虚拟地址" class="headerlink" title="1、物理和虚拟地址"></a>1、物理和虚拟地址</h3><p>计算机系统的<strong>主存</strong>被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一<strong>地物理地址</strong>(Physical Address, PA)。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，以此类推。给这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>。</p><p>早期的PC使用物理地址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。然而现代处理器使用的是一种称为<strong>虚拟寻址</strong>的寻址形式。如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/7.png?raw=true" alt></p><p>使用虚拟寻址，CPU通过生成一个<strong>虚拟地址</strong>(Virtual Address, VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做<strong>内存管理单元</strong>(Memory Management Unit， MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h3 id="2、地址空间"><a href="#2、地址空间" class="headerlink" title="2、地址空间"></a>2、地址空间</h3><p>在一个带虚拟内存的系统中，CPU从一个有N=2^n个地址的地址空间中生成虚拟地址，这个地址空间被称为<strong>虚拟地址空间</strong>。一个地址空间的大小由表示表示最大地址所需要的位数来描述，可以把前面这个由N个虚拟地址组成的虚拟空间叫做一个<strong>n位地址空间</strong>。现代系统通常支持32位或者64位虚拟地址空间。</p><p>一个系统还有一个物理地址空间，内存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><h3 id="3、虚拟内存作为缓存的工具"><a href="#3、虚拟内存作为缓存的工具" class="headerlink" title="3、虚拟内存作为缓存的工具"></a>3、虚拟内存作为缓存的工具</h3><p> <strong>概念上</strong>而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一地虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其它缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。</p><p> VM系统通过将虚拟内存分割为称为<strong>虚拟页</strong>(Virtual Page， VP)的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^p字节。类似地，物理内存被分割为<strong>物理页</strong>(Physical Page，PP)，大小也为P字节(物理页也被称为页帧)。</p><p>在任意时刻，虚拟页面的集合都分为三个不想交的子集:</p><ul><li>未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的： 未缓存在物理内存中的已分配页。</li></ul><h4 id="3-1-DRAM缓存的组织结构"><a href="#3-1-DRAM缓存的组织结构" class="headerlink" title="3.1 DRAM缓存的组织结构"></a>3.1 DRAM缓存的组织结构</h4><p>术语SRAM缓存用来表示位于CPU和主存之间的的L1、L2和L3高速缓存，DRAM用来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p><p>在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。回想一下，DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100 000多倍。一次DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵的多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的。而且，从磁盘的第一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节慢大约100 000倍。（后续字节被缓存在主存中）</p><p> 因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。因为大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。同时不命中时的替换策略也很重要，故与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更加精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是写直达。</p><h4 id="3-2-页表"><a href="#3-2-页表" class="headerlink" title="3.2 页表"></a>3.2 页表</h4><p>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。</p><p> 这些功能是由软硬件联合提供的，包括<strong>操作系统软件</strong>、<strong>MMU(内存管理单元)中的地址翻译硬件</strong>和一个存放在物理内存中叫做<strong>页表</strong>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读 取页表。操作系统负责维护页表内容，以及在磁盘与DRAM之间来回传送页。</p><p> 下图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目</strong>(Page Table Entry， PTE)的数组。虚拟地址空间中的每个页中一个固定偏移量处都有一个PTE。假设每个PTE都由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始地址。如果没有设置有效位，那么一个空地址表示这个虚拟页还未分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/8.png?raw=true" alt></p><p>上图展示了一个有8个虚拟页和4个物理页的系统的页表。四个虚拟页(VP1、VP2、VP4和VP7)当前被缓存在DRAM中。两个页(VP0和VP5)还未被分配，而剩下的页(VP3和VP6)已经被分配了，但是当前还未被缓存。</p><h4 id="3-3-页命中"><a href="#3-3-页命中" class="headerlink" title="3.3 页命中"></a>3.3 页命中</h4><p>考虑一下当CPU想要读包含在VP2中的虚拟内存的一个字时会发生什么，VP2被缓存在DRAM中。使用地址翻译技术，地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存中的了。所以它使用PTE中的物理内存地址(该地址指向PP1中缓存页的起始位置)，构造出这个字的物理地址。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/9.png?raw=true" alt></p><h4 id="3-4-缺页"><a href="#3-4-缺页" class="headerlink" title="3.4 缺页"></a>3.4 缺页</h4><p>在虚拟内存的习惯说法中，缓存不命中称为<strong>缺页</strong>。下图展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/10.png?raw=true" alt></p><p>接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。<strong>当异常处理程序返回时，它会重新启动导致缺页的指令</strong>，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。下图展示了在缺页之后我们的示例页表的状态。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/11.png?raw=true" alt></p><h4 id="3-5-分配页面"><a href="#3-5-分配页面" class="headerlink" title="3.5 分配页面"></a>3.5 分配页面</h4><p>当我们调用malloc等分配一个新的虚拟页VP5时，主要是在磁盘上创建空间并更新PTE5，使它指向这个新创建的页面。</p><h4 id="3-6-又是局部性救了我们"><a href="#3-6-又是局部性救了我们" class="headerlink" title="3.6 又是局部性救了我们"></a>3.6 又是局部性救了我们</h4><p>虚拟内存能工作好，主要归功于<strong>局部性</strong>。尽管在整个运行过程中程序引用的不同的页面的总数可能会超过物理内存总的大小，但是局部性原则保证了在任意时刻，程序趋向于在一个较小的<strong>活动页面</strong>集合上工作。这个集合叫做工作集合或者常驻集合。</p><p>有时程序可能不会表现出良好的时间局部性。如果工作集的大小超过了物理内存的大小，那么程序将产生一种不幸的状态，叫做<strong>抖动</strong>，这时页面将会不断换入换出，程序就会很慢，我们也该想想是不时设计出了问题，并尝试解决抖动。</p><blockquote><p>内存抖动最常见的例子应该就是数组的按行访问和按列访问了，按行访问明显会好一点。</p></blockquote><h3 id="4、虚拟内存作为内存管理的工具"><a href="#4、虚拟内存作为内存管理的工具" class="headerlink" title="4、虚拟内存作为内存管理的工具"></a>4、虚拟内存作为内存管理的工具</h3><p>实际上，操作系统为每一个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间，而且多个虚拟页面也可以映射到同一个物理页面上。</p><p><strong>按需页面调度</strong>和<strong>独立的虚拟地址空间</strong>的结合，对系统内存的使用和管理造成了深远的影响。VM简化了加载和链接、代码和数据的共享，以及应用程序的内存分配：</p><ul><li><p>简化链接<br>独立地址空间允许每个进程的内存映像使用相同的基本格式。例如在64位x86-64平台上，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间夹杂着对齐空白。栈占据用户进程地址空间的最高部分0x7fffffff，并向下增长。<strong>这样的一致性极大地简化了链接器的设计和实现，运行链接器生成完全连接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的</strong>。</p></li><li><p>简化加载<br>把目标文件（可执行文件和共享对象文件）中的.text和.data加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把他们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。然而，<strong>加载器从不从磁盘复制任何数据到内存中</strong>，而在每个页被初次引用时，或CPU取指令时，或一条正在执行的指令引用一个内存位置时，虚拟内存系统会按需自动调入数据页。</p></li><li><p>简化共享<br>一般情况下，<strong>每个进程都有自己私有的代码、数据、堆、以及栈区域，是不和其他进程共享的</strong>。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。在部分情况下，进程间还是需要共享代码和数据的，例如每个C程序都会调用C标准库中的程序（printf）、都需要调用相同的内核代码。<strong>操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和C标准库的副本</strong>。</p></li><li><p>简化内存分配<br>当运行在用户进程的程序要求额外的堆空间时（如调用malloc），操作系统分配k个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的k个任意的物理页面。<strong>由于页表的存在，操作系统没必要分配k个连续的物理页面，页面可随机地分散在物理内存中</strong>。</p></li></ul><h3 id="5、虚拟内存作为内存保护的工具"><a href="#5、虚拟内存作为内存保护的工具" class="headerlink" title="5、虚拟内存作为内存保护的工具"></a>5、虚拟内存作为内存保护的工具</h3><p>可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。比如每个PTE中已经添加了三个许可位，SUP位表示进程能否必须运行在内核模式才能访问该页，READ位和WRITE位控制对页面的读和写访问。</p><p>如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核的异常处理程序。Linux shell一般将这种异常报告为“段错误segmentation fault”。</p><h3 id="6-地址翻译"><a href="#6-地址翻译" class="headerlink" title="6 地址翻译"></a>6 地址翻译</h3><p>形式上来说，地址翻译是一个N元素的虚拟地址空间(VAS)的元素和一个M元素的物理地址空间(PAS)中元素之间的映射，</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/12.png?raw=true" alt></p><p>这里</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/13.png?raw=true" alt></p><p>下图展示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器(Page Table Base Register, PTRB)指向当前页表。<strong>n位的虚拟地址包含两个部分</strong>:一个p位的<strong>虚拟页面偏移</strong>(Virtual Page Offset, VPO)和一个(n-p)位的<strong>虚拟页号</strong>(Virtual Page Number， VPN)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE 0，VPN1选择PTE 1，以此类推。将页表条目中物理页号(Physical Page Number，PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/14.png?raw=true" alt></p><p>下面来讨论一下页面命中和不命中的处理过程。页面命中完全由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。<br><strong>当页面命中时，CPU硬件执行步骤如下</strong>：</p><ul><li>(1)、处理器生成一个虚拟地址，并把它传给MMU</li><li>(2)、MMU生成PTE地址，并从高速缓存/主存请求得到它（这一步是因为页表是在内存中）</li><li>(3)、高速缓存/主存向MMU返回PTE</li><li>(4)、MMU构造物理地址，并把它传送给高速缓存/主存</li><li>(5)、高速缓存/主存返回所请求的数据给处理器</li></ul><p><strong>缺页时，硬盘和操作系统内核协作完成如下</strong>：</p><ul><li>(1)、处理器生成一个虚拟地址，并把它传给MMU</li><li>(2)、MMU生成PTE地址，并从高速缓存/主存请求得到它（这一步是因为页表是在内存中）</li><li>(3)、高速缓存/主存向MMU返回PTE</li><li>(4)、PTE有效位是0，MMU出发一次异常，传递CPU中的控制到操作系统内核中的<strong>缺页异常处理程序</strong>。</li><li>(5)、缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到硬盘。</li><li>(6)、缺页异常处理程序页面调入新的页面，并更新内存中的PTE。</li><li>(7)、缺页异常处理程序返回到原来的进程中，再次执行指令，这次就会命中。</li></ul><h4 id="6-1-结合高速缓存和虚拟内存"><a href="#6-1-结合高速缓存和虚拟内存" class="headerlink" title="6.1 结合高速缓存和虚拟内存"></a>6.1 结合高速缓存和虚拟内存</h4><p>在任何既使用虚拟内存又使用SRAM高速缓存的系统中，都有因该使用虚拟地址还是物理地址来访问SRAM高速缓存的问题。大多数的系统都选择物理寻址，使用物理寻址，就可以将页表（条目）也加载到高速缓存并能像访问其他存储块一样访问。而且高速缓存也无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。 </p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/15.png?raw=true" alt></p><p>处理器（虚拟内存地址）——————&gt;MMU——————&gt;高速缓存——————&gt;内存。</p><h4 id="6-2-利用TLB加速地址翻译"><a href="#6-2-利用TLB加速地址翻译" class="headerlink" title="6.2 利用TLB加速地址翻译"></a>6.2 利用TLB加速地址翻译</h4><p>为了降低从内存取PTE的开销，许多系统在MMU中引入了一个关于PTE的小的缓存，称为<strong>翻译后备缓冲器</strong>（TLB，快表）。</p><p>TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由PTE组成的块。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/16.png?raw=true" alt></p><p>如果TLB命中，则取出对应的PTE并生成物理地址并访问高速缓存/主存获取请求的数据，如果不命中，则到高速缓存/内存中去取PTE，并放到TLB中，可能会覆盖。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/17.png?raw=true" alt></p><h4 id="6-3-多级页表"><a href="#6-3-多级页表" class="headerlink" title="6.3 多级页表"></a>6.3 多级页表</h4><p>为什么要使用多级页表？假设有一个32位的地址空间，每个页4KB，那么需要2^20个PTE来进行表示，又如果每条PTE占4Byte，那么总的需要4M的内存空间来存储页表。而这只是32位地址情况，如果是64位就又会复杂很多。</p><p>假设一个上述32位虚拟地址空间有如下形式：内存的前2K个页面分配给了代码和数据，接下来6K个页面未分配，再接下来的1023个也未分配，接下来的1个页面分配给了用户栈。下图展示了如何为虚拟空间构造一个两级也表层次结构:</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/19.png?raw=true" alt></p><p>多级页表从两个方面减少了内存要求：</p><ul><li>如果一级页表中的一个PTE为空，那么对应的二级页表就不存在。这能带来很大的结局，<strong>通常一个4GB的虚拟进程空间的大部分都是未分配的</strong>。</li><li>只有一级页表才需要总是存在主存中。而二级页表只有在需要时才进行创建、页面调入和调出，能极大地减少主存的压力，只有常用的二级页表才需要缓存在主存中。</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/20.png?raw=true" alt></p><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h3><p>参考书籍：《深入理解计算机系统》<br>参考链接：<a href="https://blog.csdn.net/longbei9029/article/details/79281273" target="_blank" rel="noopener">https://blog.csdn.net/longbei9029/article/details/79281273</a>   </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第6章 算法</title>
      <link href="/2019/05/20/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC6%E7%AB%A0%20%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/20/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC6%E7%AB%A0%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>STL算法部分主要由头文件<algorithm>,<numeric>,<functional>组成。要使用 STL中的算法函数必须包含头文件<algorithm>，对于数值算法须包含<numeric>，<functional>中则定义了一些模板类，用来声明函数对象。</functional></numeric></algorithm></functional></numeric></algorithm></p><a id="more"></a><blockquote><p>大部分内容摘自：<a href="https://www.cnblogs.com/linuxAndMcu/p/10264339.html" target="_blank" rel="noopener">https://www.cnblogs.com/linuxAndMcu/p/10264339.html</a></p></blockquote><h3 id="1、常见的算法种类"><a href="#1、常见的算法种类" class="headerlink" title="1、常见的算法种类"></a>1、常见的算法种类</h3><p>（1）质变与非质变算法：</p><ul><li>质变算法-会改变操作对象的值。所有的STL算法都作用在[first,last)所标示的区间上，在运算过程中改变区间元素值。例如：copy,swap,replace,fill,remove,permulation,partition,sort等。</li><li>非质变算法-不改变操作对象之值。例如：find,search,count,equal,max,min等。</li></ul><p>（2）STL中算法大致分为四类：</p><ul><li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li><li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li><li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li><li>数值算法：对容器内容进行数值计算。</li></ul><p>细致分类可分为13类，由于算法过多，所以不一一做介绍，只选取几个最常用的算法介绍。</p><h3 id="2、SGI-STL中的常见算法"><a href="#2、SGI-STL中的常见算法" class="headerlink" title="2、SGI STL中的常见算法"></a>2、SGI STL中的常见算法</h3><h4 id="2-1-查找算法"><a href="#2-1-查找算法" class="headerlink" title="2.1 查找算法"></a>2.1 查找算法</h4><p>查找算法共13个，包含在<algorithm>头文件中，用来提供元素排序策略，这里只列出一部分算法：</algorithm></p><ul><li>adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。</li><li>count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</li><li>count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。</li><li>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</li><li>equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。</li><li>find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回指向该元素的Iterator。</li><li>find_if: 使用输入的函数代替等于操作符执行find。</li><li>search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。</li><li>search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_find: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 ***/</span></span><br><span class="line">    <span class="comment">//原型： count(_InIt _First, _InIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count(==7): "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count(iv.begin(), iv.end(), <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//统计6的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 ***/</span></span><br><span class="line">    <span class="comment">//原型： count_if(_InIt _First, _InIt _Last, _Pr _Pred)</span></span><br><span class="line">    <span class="comment">//统计小于7的元素的个数 :9个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count_if(&lt;7): "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(iv.begin(), iv.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">7</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** binary_search: 在有序序列中查找value，找到返回true。 ***/</span></span><br><span class="line">    <span class="comment">//原型： bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"binary_search: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binary_search(iv.begin(), iv.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到返回true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 ***/</span></span><br><span class="line">    <span class="comment">//原型： equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; pairIte;  </span><br><span class="line">    pairIte = equal_range(iv.begin(), iv.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairIte.first:"</span> &lt;&lt; *(pairIte.first) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//lowerbound 3   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairIte.second:"</span> &lt;&lt; *(pairIte.second) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//upperbound 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *find(iv.begin(), iv.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回元素为4的元素的下标位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** find_if: 使用输入的函数代替等于操作符执行find。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find_if: "</span> &lt;&lt; *find_if(iv.begin(), iv.end(), bind2nd(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回大于2的第一个元素的位置：3 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列的位置。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)</span></span><br><span class="line">    <span class="comment">//在iv中查找 子序列 2 3 第一次出现的位置的元素   </span></span><br><span class="line">    <span class="keyword">int</span> iarr3[<span class="number">3</span>] = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv3(iarr3, iarr3 + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"search: "</span> &lt;&lt; *search(iv.begin(), iv.end(), iv3.begin(), iv3.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** search_n: 在指定范围内查找val出现n次的子序列。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//在iv中查找 2个6 出现的第一个位置的元素   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"search_n: "</span> &lt;&lt; *search_n(iv.begin(), iv.end(), <span class="number">2</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-排序和通用算法"><a href="#2-2-排序和通用算法" class="headerlink" title="2.2 排序和通用算法"></a>2.2 排序和通用算法</h4><p>排序算法共14个，包含在<algorithm>头文件中，用来判断容器中是否包含某个值，这里只列出一部分算法：</algorithm></p><ul><li>merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。</li><li>random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。</li><li>nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。</li><li>reverse: 将指定范围内元素重新反序排序。</li><li>sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。</li><li>stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要注意的技巧</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:</span></span><br><span class="line"><span class="comment">//自定义从大到小的比较器，用来改变排序方式</span></span><br><span class="line"><span class="keyword">bool</span> Comp(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr1[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv1(iarr1, iarr1 + <span class="keyword">sizeof</span>(iarr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(iarr1 + <span class="number">4</span>, iarr1 + <span class="number">8</span>); <span class="comment">//4 5 6 6</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** merge: 合并两个有序序列，存放到另一个序列 ***/</span></span><br><span class="line">    <span class="comment">//iv1和iv2合并到iv3中（合并后会自动排序）</span></span><br><span class="line">    merge(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"merge合并后: "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** random_shuffle: 对指定范围内的元素随机调整次序。 ***/</span></span><br><span class="line">    <span class="keyword">int</span> iarr2[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv4(iarr2, iarr2 + <span class="keyword">sizeof</span>(iarr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//打乱顺序  </span></span><br><span class="line">    random_shuffle(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"random_shuffle打乱后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** nth_element: 将范围内的序列重新排序。 ***/</span></span><br><span class="line">    <span class="comment">//将小于iv.begin+5的放到左边   </span></span><br><span class="line">    nth_element(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">begin</span>() + <span class="number">5</span>, iv4.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"nth_element重新排序后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** reverse: 将指定范围内元素重新反序排序。 ***/</span></span><br><span class="line">    reverse(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"reverse翻转后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** sort: 以升序重新排列指定范围内的元素。 ***/</span></span><br><span class="line">    <span class="comment">//sort(iv4.begin(), iv4.end(), Comp); //也可以使用自定义Comp()函数</span></span><br><span class="line">    sort(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="string">"sort排序（倒序）: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 ***/</span></span><br><span class="line">    <span class="keyword">int</span> iarr3[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv5(iarr3, iarr3 + <span class="keyword">sizeof</span>(iarr3) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    stable_sort(iv5.<span class="built_in">begin</span>(), iv5.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="string">"stable_sort排序（倒序）: "</span>;</span><br><span class="line">    for_each(iv5.<span class="built_in">begin</span>(), iv5.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-删除和替换算法"><a href="#2-3-删除和替换算法" class="headerlink" title="2.3 删除和替换算法"></a>2.3 删除和替换算法</h4><p>删除和替换算法共15个，包含在<numeric>头文件中，这里只列出一部分算法：</numeric></p><ul><li>copy: 复制序列。</li><li>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。</li><li>remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。</li><li>remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。</li><li>remove_if: 删除指定范围内输入操作结果为true的所有元素。</li><li>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr1[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv1(iarr1, iarr1 + <span class="keyword">sizeof</span>(iarr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** copy: 复制序列 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt copy(_InIt _First, _InIt _Last,_OutIt _Dest)</span></span><br><span class="line">    copy(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"copy(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,_BidIt2 _Dest)</span></span><br><span class="line">    copy_backward(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.rend());</span><br><span class="line">    cout &lt;&lt; <span class="string">"copy_backward(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove: 删除指定范围内所有等于指定元素的元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">remove</span>(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">//删除元素5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove(iv1): "</span>;</span><br><span class="line">    for_each(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 ***/</span></span><br><span class="line">    <span class="comment">// 原型：  _OutIt remove_copy(_InIt _First, _InIt _Last,_OutIt _Dest, const _Ty&amp; _Val)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(<span class="number">8</span>);</span><br><span class="line">    remove_copy(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>(), <span class="number">4</span>); <span class="comment">//去除4 然后将一个容器的元素复制到另一个容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_copy(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_if: 删除指定范围内输入操作结果为true的所有元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)</span></span><br><span class="line">    remove_if(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">6</span>)); <span class="comment">// 将小于6的元素 "删除"</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_if(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _OutIt remove_copy_if(_InIt _First, _InIt _Last,_OutIt _Dest, _Pr _Pred)</span></span><br><span class="line">    <span class="comment">// 将iv1中小于6的元素 "删除"后，剩下的元素再复制给iv3</span></span><br><span class="line">    remove_copy_if(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_if(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>replace: 将指定范围内所有等于vold的元素都用vnew代替。</li><li>replace_copy: 与replace类似，不过将结果写入另一个容器。</li><li>replace_if: 将指定范围内所有操作结果为true的元素用新值代替。</li><li>replace_copy_if: 与replace_if，不过将结果写入另一个容器。</li><li>swap: 交换存储在两个对象中的值。</li><li>swap_range: 将指定范围内的元素与另一个序列元素值进行交换。</li><li>unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。</li><li>unique_copy: 与unique类似，不过把结果输出到另一个容器。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace: 将指定范围内所有等于vold的元素都用vnew代替。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： void replace(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)</span></span><br><span class="line">    <span class="comment">//将容器中6 替换为 3   </span></span><br><span class="line">    replace(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace(iv): "</span>;</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//由于_X是static 所以接着 增长</span></span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv:8 10 7 8 3 3 7 8 3 7 8   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_copy: 与replace类似，不过将结果写入另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//将容器中3 替换为 5，并将结果写入另一个容器。  </span></span><br><span class="line">    replace_copy(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv2:8 10 7 8 5 5 7 8 5 7 8 0（最后y一个残留元素）   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将容器中小于 5 替换为 2   </span></span><br><span class="line">    replace_if(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy(iv): "</span>;</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());   </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv:8 10 7 8 2 5 7 8 2 7 8   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_copy_if: 与replace_if，不过将结果写入另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将容器中小于 5 替换为 2，并将结果写入另一个容器。  </span></span><br><span class="line">    replace_copy_if(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(), <span class="number">8</span>), <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy_if(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv2:9 10 7 8 2 5 7 9 2 7 8 0(最后一个残留元素)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iarr3[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(iarr3, iarr3 + <span class="keyword">sizeof</span>(iarr3) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> iarr4[] = &#123; <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv4(iarr4, iarr4 + <span class="keyword">sizeof</span>(iarr4) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** swap: 交换存储在两个对象中的值。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将两个容器中的第一个元素交换  </span></span><br><span class="line">    swap(*iv3.<span class="built_in">begin</span>(), *iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"swap(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest)</span></span><br><span class="line">    <span class="comment">//将两个容器中的全部元素进行交换  </span></span><br><span class="line">    swap_ranges(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"swap_range(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** unique: 清除序列中相邻的重复元素，和remove类似，它也不能真正删除元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) </span></span><br><span class="line">    unique(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"unique(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** unique_copy: 与unique类似，不过把结果输出到另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)</span></span><br><span class="line">    unique_copy(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"unique_copy(iv4): "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-排列组合算法"><a href="#2-4-排列组合算法" class="headerlink" title="2.4 排列组合算法"></a>2.4 排列组合算法</h4><p>排列组合算法共2个，包含在<algorithm>头文件中，用来提供计算给定集合按一定顺序的所有可能排列组合，这里全部列出：</algorithm></p><ul><li>next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。重载版本使用自定义的比较操作。</li><li>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp;x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">12</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。***/</span></span><br><span class="line">    <span class="comment">// 原型： bool next_permutation(_BidIt _First, _BidIt _Last)</span></span><br><span class="line">    <span class="comment">//生成下一个排列组合（字典序）   </span></span><br><span class="line">    next_permutation(iv.begin(), iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： bool prev_permutation(_BidIt _First, _BidIt _Last)</span></span><br><span class="line">    prev_permutation(iv.begin(), iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-数值算法"><a href="#2-5-数值算法" class="headerlink" title="2.5 数值算法"></a>2.5 数值算法</h4><p>数值算法共4个，包含在<numeric>头文件中，分别是：</numeric></p><ul><li>accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。</li><li>partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。</li><li>inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。</li><li>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //数值算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; //定义了ostream_iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(arr, arr + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2(arr, arr + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    temp = accumulate(vec.begin(), vec.end(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate(val = 0): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    temp = accumulate(vec.begin(), vec.end(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate(val = 1): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。</span></span><br><span class="line">    <span class="comment">//这里是：1*1 + 2*2 + 3*3 + 4*4 + 5*5</span></span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">    temp = inner_product(vec.begin(), vec.end(), vec2.begin(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"inner_product(val = 0): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。</span></span><br><span class="line">    <span class="comment">//第一次，1   第二次，1+2  第三次，1+2+3  第四次，1+2+3+4</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; oit(<span class="built_in">cout</span>, <span class="string">" "</span>); <span class="comment">//迭代器绑定到cout上作为输出使用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ostream_iterator: "</span>;</span><br><span class="line">    partial_sum(vec.begin(), vec.end(), oit);<span class="comment">//依次输出前n个数的和</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第一次，1   第二次，1-2  第三次，1-2-3  第四次，1-2-3-4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ostream_iterator(minus): "</span>;</span><br><span class="line">    partial_sum(vec.begin(), vec.end(), oit, minus&lt;<span class="keyword">int</span>&gt;());<span class="comment">//依次输出第一个数减去（除第一个数外到当前数的和）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。</span></span><br><span class="line">    <span class="comment">//第一次，1-0   第二次，2-1  第三次，3-2  第四次，4-3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_difference: "</span>;</span><br><span class="line">    adjacent_difference(vec.begin(), vec.end(), oit); <span class="comment">//输出相邻元素差值 后面-前面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第一次，1+0   第二次，2+1  第三次，3+2  第四次，4+3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_difference(plus): "</span>;</span><br><span class="line">    adjacent_difference(vec.begin(), vec.end(), oit, plus&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//输出相邻元素差值 后面-前面 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、几个算法的具体实现原理"><a href="#3、几个算法的具体实现原理" class="headerlink" title="3、几个算法的具体实现原理"></a>3、几个算法的具体实现原理</h3><h4 id="3-1-next-permutation-的实现"><a href="#3-1-next-permutation-的实现" class="headerlink" title="3.1 next_permutation()的实现"></a>3.1 next_permutation()的实现</h4><p>该算法用于求区间序列的<strong>下一个</strong>排列组合，在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，并且满足*i &lt; *ii。然后再从尾端寻找另一个元素*j，如果满足*i &lt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/23.png?raw=true" alt="image"></p><p>代码实现：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class BidirectionalIterator&gt;  </span><br><span class="line">bool next_permutation(BidirectionalIterator <span class="built_in">first</span>, BidirectionalIterator <span class="built_in">last</span>)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">first</span> == <span class="built_in">last</span>)  <span class="built_in">return</span> <span class="literal">false</span>; //空序列  </span><br><span class="line">  </span><br><span class="line">    BidirectionalIterator i = <span class="built_in">first</span>;  </span><br><span class="line">    ++i;  </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="built_in">last</span>)  <span class="built_in">return</span> <span class="literal">false</span>;  //一个元素，没有下一个序列了  </span><br><span class="line">      </span><br><span class="line">    i = <span class="built_in">last</span>;  </span><br><span class="line">    --i;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;  </span><br><span class="line">        BidirectionalIterator ii = i;  //不断往前移动</span><br><span class="line">        --i;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(*i &lt; *ii) //满足条件</span><br><span class="line">        &#123;  </span><br><span class="line">            BidirectionalIterator j = <span class="built_in">last</span>;  </span><br><span class="line">            <span class="keyword">while</span>(!(*i &lt; *--j)); //找到*i&lt;*j的情况  </span><br><span class="line">            iter_swap(i, j);  //进行交换</span><br><span class="line">            <span class="built_in">reverse</span>(ii, <span class="built_in">last</span>);  </span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="built_in">first</span>) </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">reverse</span>(<span class="built_in">first</span>, <span class="built_in">last</span>);  //全逆向，即为最小字典序列，如cba变为abc  </span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-pre-permutation-的实现原理"><a href="#3-2-pre-permutation-的实现原理" class="headerlink" title="3.2 pre_permutation()的实现原理"></a>3.2 pre_permutation()的实现原理</h4><p>该算法用于求区间序列的<strong>上一个</strong>排列组合，在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，直到满足*i &gt; *ii。然后再从尾端寻找另一个元素*j，如果满足*i &gt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出上一个序列了。</p><h4 id="3-3-sort-的实现原理"><a href="#3-3-sort-的实现原理" class="headerlink" title="3.3 sort()的实现原理"></a>3.3 sort()的实现原理</h4><p>STL中的sort并非只是普通的快速排序，<strong>除了对普通的快速排序进行优化，它还结合了插入排序和堆排序</strong>。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾</p><p>Quick Sort中任何一个元素都可以被选做枢轴，比如随机选取，固定选取。但是划分的两端越均匀，执行效率越高；如果其中一段长度为0，那就出现了最坏情况。最理想的选取方法是选取头、尾和中间三个元素中大小处于中间的那个元素作为枢轴。这样可以避免出现最坏情况（<strong>三点中值法</strong>）。</p><h4 id="3-4-partition-的实现原理"><a href="#3-4-partition-的实现原理" class="headerlink" title="3.4 partition()的实现原理"></a>3.4 partition()的实现原理</h4><p>对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last。一元谓词可以用lambda表达式等。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; <span class="built_in">class</span> ForwardIt, <span class="built_in">class</span> UnaryPredicate &gt;</span><br><span class="line">ForwardIt partition( ForwardIt <span class="keyword">first</span>, ForwardIt <span class="keyword">last</span>, UnaryPredicate p );</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11特性之列表初始化</title>
      <link href="/2019/05/19/c++%E5%9F%BA%E7%A1%80/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/05/19/c++%E5%9F%BA%E7%A1%80/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>最近注意到c++11的列表初始化特性，发现还是挺方便的，这里总结一下，以便之后进行使用。<br><a id="more"></a></p><hr><h3 id="1、-C-11的各种初始化方式"><a href="#1、-C-11的各种初始化方式" class="headerlink" title="1、 C++11的各种初始化方式"></a>1、 C++11的各种初始化方式</h3><p>c++11主要提供了如下6种初始化方式：<strong>零初始化、默认初始化、值初始化、直接初始化、拷贝初始化、列表初始化</strong>。<br>几种初始化之间的主要区别如下：</p><ul><li><strong>默认初始化</strong>：如果是一个类，那么调用默认构造函数进行初始化；如果是一个数组，那么每个元素默认初始化；除了前面的情况之外，不进行初始化，其值未定义。</li><li><strong>值初始化</strong>：如果是一个类，那么类的对象进行默认初始化,如果用户没有定义默认构造函数，则会进行零值初始化再进行默认初始化；如果是一个数组，每个元素值初始化，否则进行零初始化。<strong>如果你不想要你的默认构造函数是用户自定义的，那么必须在类的内部声明处使用”=default”，而不是在类外部定义处使用，后者会使得编译器认为用户定义了默认构造函数。</strong></li><li><strong>零初始化</strong>：对于static或者thread_local变量将会在其他类型的初始化之前先初始化。如果T是算数、指针、枚举类型，将会初始化为0；如果是类类型，基类和数据成员会零初始化；如果是数组，数组元素也零初始化。</li></ul><h3 id="2、-几种初始化的实例"><a href="#2、-几种初始化的实例" class="headerlink" title="2、 几种初始化的实例"></a>2、 几种初始化的实例</h3><p>下面给出几种上述初始化方式的实例，从代码上来体现他们的区别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;         <span class="comment">//默认初始化</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;       <span class="comment">//值初始化(C++11)，要求初始化，但没有给出初始值的行为</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">5</span>;     <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l</span><span class="params">()</span></span>;       <span class="comment">//值初始化</span></span><br><span class="line"><span class="keyword">int</span> m&#123;<span class="number">4</span>&#125;;       <span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;       <span class="comment">//默认初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>();     <span class="comment">//值初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>&#123;&#125;;     <span class="comment">//值初始化(C++11)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="string">"dengwen"</span>&#125;; <span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">string</span> str1=str;  <span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure></p><p>只要使用了括号（圆括号或花括号）但没有给出具体初始值，就是值初始化。可以简单理解为括号告诉编译器你希望该对象初始化。</p><p>没有使用括号，就是默认初始化。可以简单理解成，你放任不管，允许编译器使用默认行为。通常这是糟糕的行为，除非你真的懂自己在干什么。</p><h3 id="3、-列表初始化的特殊之处"><a href="#3、-列表初始化的特殊之处" class="headerlink" title="3、 列表初始化的特殊之处"></a>3、 列表初始化的特殊之处</h3><p>在C++11以前，程序员，或者初学者经常会感到疑惑关于怎样去初始化一个变量或者是一个对象。这么多的对象初始化方式，不仅增加了学习成本，也使得代码风格有较大出入，影响了代码的可读性和统一性。</p><p>从C++11开始，对列表初始化（List Initialization）的功能进行了扩充，可以作用于任何类型对象的初始化，至此，列表初始化方式完成了天下大一统。</p><p>花括号列表初始化，作为C++11新标准的一部被加入到了C++中。因为这个原因，c++11提出了统一初始化，下面的做法都是正确的。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:    </span><br><span class="line">    C(int i, int j); </span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int b;   </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">Test </span>t&#123;1,3&#125;; //初始化</span><br><span class="line">t=&#123;2,4&#125;;  //这里可以直接进行赋值，而且是对私有变量....</span><br><span class="line"><span class="keyword">Test </span>*p=new Test&#123;3,5&#125;;  //列表初始化</span><br><span class="line">int *q = new int[3]&#123;1,2,0&#125;;   //数组</span><br></pre></td></tr></table></figure></p><p>此外，C++11列表初始化还可以应用于容器，终于可以摆脱 push_back() 调用了，将C++11提供的列表初始化作为统一的初始化方式，既降低了记忆难度，也提高的代码的统一度。</p><p>需要注意的点：<strong>使用初始化列表来初始化内置类型的变量时，若存在类型转换且具有丢失信息的风险时，编译器将会报错</strong>。</p><p>通过这一点可以看出，列表初始化比原有的初始化方式具有更严格的安全要求。下面是例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>；</span><br><span class="line"><span class="keyword">int</span> a &#123;ld&#125;， b = &#123;ld&#125;;  <span class="comment">// 编译器报错，存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span>(<span class="params">ld</span>), d</span> = ld ;    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11特性 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第5章 关联式容器</title>
      <link href="/2019/05/18/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC5%E7%AB%A0%20%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/05/18/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC5%E7%AB%A0%20%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>所谓关联式容器，观念上类似于关联式数据库，每个元素都有一个键值key和一个实值value</strong>。当向容器插入元素时，容器根据其key值将实值放到适当的位置。关联式容器没有头尾的概念，所以也不会有push_front()，push_back()等操作函数。</p><p>STL关联容器分为set（集合）和map（映射表）两大类，及其衍生体multiset和multimap。这些容器的底层机制均以RB-tree（红黑树）实现。RB-tree也是一个独立容器，但并不开放使用。</p><p>SGI STL还提供一个不在标准规格的关联式容器 hash_table（散列表），以及以 hash_table 为底层机制而完成的 hash_set散列集合、hash_map散列映射表、hash_multiset散列多键集合、hash_multimap散列多键映射表。</p><p>本章我们将主要学习各种容器对应的底层实现原理和应该注意的地方。<br><a id="more"></a></p><h3 id="1、树的基本的概念"><a href="#1、树的基本的概念" class="headerlink" title="1、树的基本的概念"></a>1、树的基本的概念</h3><p>一个关于树的比较重要且容易模糊的概念是：</p><ul><li>节点路径长度（也叫深度）：根节点到当前节点所经过的边数和。</li><li>节点的高度：某节点至其最远叶子节点的路径长度的值。</li></ul><p>二叉搜索树在一些情况下不能很好地保持平衡性，所以引入了AVL树（带额外平衡条件的二叉搜索树），其保证任意节点的左右两颗子树的高度差不超过1，这就要求每插入一个节点<br>时都需要进行调整以保证平衡性。调整分为四种情况对应两种调整方式：单旋转和双旋转。</p><p>AVL的不足之处在于过分追求平衡，从而导致插入效率变低，在不大影响查找效率的基础上同时满足大概的平衡就好了，于是人们引入了RB-Tree。</p><h3 id="2、RB-tree"><a href="#2、RB-tree" class="headerlink" title="2、RB-tree"></a>2、RB-tree</h3><p>RB-tree（红黑树）是一种被广泛使用的平衡二搜索树，其通过一些着色法则确保没有一条路径会比其它路径长两倍，从而达到接近平衡目的。RB-tree必须满足以下规则：</p><ul><li>（1）每个节点不是红色就是黑色；</li><li>（2）根节点为黑色；</li><li>（3）如果节点为红，其子节点必须为黑；</li><li>（4）任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同。</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/19.png?raw=true" alt="image"></p><p>根据规则（4），新增节点必须为红，根据规则（3），新增节点之父节点必须为黑。当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调整颜色并旋转树形。</p><h4 id="2-1-RB-tree效率所在"><a href="#2-1-RB-tree效率所在" class="headerlink" title="2.1 RB-tree效率所在"></a>2.1 RB-tree效率所在</h4><p>红黑树之所以为红黑树的原因：红黑颜色用来检测树的平衡性，达到AVL树的平衡要求，降低了对旋转的要求，从而提高了统计性能。红黑树相对AVL树能够给我们一个比较便宜的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更好。</p><p>RB-tree不仅在树性的平衡上表现不错，在效率表现和实现复杂度上也保持相当的平衡，所以运用甚广。主要用于存储有序的数据，它的时间复杂度为O(logn)效率非常之高，Java集合中的TreeSet和TreeMap，C++的STL中的set，map以及Linux虚拟内存的管理，都通过红黑树去实现。</p><h4 id="2-2-RB-tree插入节点的调整"><a href="#2-2-RB-tree插入节点的调整" class="headerlink" title="2.2 RB-tree插入节点的调整"></a>2.2 RB-tree插入节点的调整</h4><p>假设新节点为X，其父节点为P，祖父节点为G，伯父节点（父节点的兄弟节点）为S，曾祖父节点为GG。当向RB插入一个节点时，主要讨论四种情况：</p><ul><li>（1）状况1：S为黑且X为外侧插入。对此情况，先对P,G做一次单选转，再更改P,G颜色，即可重新满足红黑树的规则3。</li><li>（2）状况2：S为黑且X为内测插入。对此情况，必须现对P,X做一次单选转并更改G,X颜色，再将结果对G做一次单选转，即可再次满足红黑树规则3。</li><li>（3）状况3：S为红且X为外侧插入。对此情况，现对P和G做一次单选转，并改变X的颜色。此时如果GG为黑，一切搞定，但如果GG为红，则问题比较大，见状况4。</li><li>（4）状况4：S为红且X为外侧插入。对此情况，先对P和G做一次单选转，并改便X的颜色。此时如果GG也为红。害的持续网上做，直到不再有父子连续为红的情况。</li></ul><p>红黑树删除基本思想是：删除后，用其子树替换，这部分与二叉搜索树的删除的思想本质一样，但是红黑树删除后，可能会破坏红黑树的性质，此时就需要进行树的调整操作即可。</p><h4 id="2-3-RB-tree节点设计和迭代器"><a href="#2-3-RB-tree节点设计和迭代器" class="headerlink" title="2.3 RB-tree节点设计和迭代器"></a>2.3 RB-tree节点设计和迭代器</h4><p>RB-tree有红黑二色，并且拥有左右子节点，很容易勾勒出其结构风貌。实现上，为了有更大的弹性，节点分为两层。同时由于RB-tree的各种操作时常需要上溯其父节点，所以特别在数据结构中安排了一个parent指针。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/20.png?raw=true" alt="image"></p><p>SGI将RB-tree迭代器实现分为两层。上图是两层节点结构和双层迭代器结构间的关系，其中_ rb_tree_node继承自rb_tree_node_base，rb_tree_iterator继承自_rb_tree_base_iterator。</p><h4 id="2-4-RB-tree的元素插入接口"><a href="#2-4-RB-tree的元素插入接口" class="headerlink" title="2.4 RB-tree的元素插入接口"></a>2.4 RB-tree的元素插入接口</h4><p>RB-tree提供两种插入操作：insert_unique()和insert_equal()，前者标识被插入节点的键值（key）在整棵树中必须独一无二,如果整棵树中已存在相同的键值，插入操作就不会真正进行;后者标识被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功。</p><p>当然插入元素后是需要对RB-tree进行调整的，这里不进行讲解了。</p><h3 id="3、set和multiset"><a href="#3、set和multiset" class="headerlink" title="3、set和multiset"></a>3、set和multiset</h3><p>set的所有特性可以归纳为以下几点： </p><ul><li>（1）所有元素都会根据元素的键值自动被排序。 </li><li>（2）set是集合，它的元素的键值就是实值，实值就是键值，不允许两个元素有相同的值。</li><li>（3）<strong>不可以通过set的iterator来改变元素的值，因为set的元素值就是键值，改变键值会违反元素排列的规则</strong>。 </li><li>（4）在客户端对set进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。 </li><li>（5）它的底层机制是RB-tree，几乎所有的操作都只是转调用RB-tree的操作行为而已。</li><li>（6）set提供的算法包括交集、并集、差集、对称差集等。</li></ul><p>multiset和set几乎一样，唯一的区别是，multiset允许键值重复。因此set使用底层RB-tree的insert_unique()实现插入，而multiset插入采用的是RB-tree的insert_equal()而非insert_unique()。 </p><h3 id="4、map和multimap"><a href="#4、map和multimap" class="headerlink" title="4、map和multimap"></a>4、map和multimap</h3><p>map的特性可以归纳为以下几条： </p><ul><li>（1）所有元素都会根据元素的键值自动被排序。 </li><li>（2）map的所有元素都是pair，第一个值是键值，第二个是实值。 </li><li>（3）map不允许两个元素拥有相同的键值。 </li><li>（4）可以通过map的迭代器来改变元素的实值，但不可以改变键值，那样会违反元素的排列规则。 </li><li>（5）在客户端对map进行插入或删除操作后，之前的迭代器依然有效。当然，被删除的元素的迭代器是个例外。 </li><li>（6）它的底层机制是RB-tree。几乎所有的操作都只是转调用RB-tree的操作行为而已。</li></ul><p>multimap和map几乎一样，唯一的区别是，multimap允许键值重复。因此map使用底层RB-tree的insert_unique()实现插入，而multimap插入采用的是RB-tree的insert_equal()而非insert_unique()。</p><h3 id="5、hashtable"><a href="#5、hashtable" class="headerlink" title="5、hashtable"></a>5、hashtable</h3><p>二叉搜索树具有对数平均时间的表现，但这样的表现依赖于一个假设：<strong>输入的数据有足够的随机性</strong>。本节要结束一种名为hash table(散列表)的数据结构，这种结构使得插入、删除、搜寻等操作上都具有“常数平均时间”的表现，而且这种表现以统计为基础，不依赖于输入元素的随机性。</p><h4 id="5-1-hashtable的散列函数和碰撞冲突问题"><a href="#5-1-hashtable的散列函数和碰撞冲突问题" class="headerlink" title="5.1 hashtable的散列函数和碰撞冲突问题"></a>5.1 hashtable的散列函数和碰撞冲突问题</h4><p>hashtable可以提供对任意有名项的存取和删除操作，这种结构的用意在于提供常数时间的的基本操作，而不依赖于插入元素的随机性，是以统计为基础的。</p><p>为了将特定键值key输入转为hash table的索引，就需要<strong>散列函数hash function</strong>，其主要负责将某一元素映射为一个”大小可接受之索引”。使用hash function带来的问题：可能有不同元素映射到相同的位置，即具有相同索引，这便是<strong>碰撞或冲突问题</strong>。</p><p>解决碰撞问题的方法常见的有线性探测、二次探测、开链等。<strong>stl hashtable采用的hash方式是开链法</strong>。</p><ul><li>（1）线性探测：当hash function计算出某个元素的插入位置，而该位置空间不再可用时，就循序往下一一寻找，直到找到一个可用空间为止。线性探测会造成<strong>主集团问题</strong>：平均插入成本的成长幅度，远高于<strong>负载系数</strong>的成长幅度。</li><li>（2）二次探测：主要用来解决主集团问题。解决碰撞的方程式为F(i) = i^2。如果hash function计算出新元素的位置为H,而该位置实际上已被使用，那么就依次尝试H+1^2,H+2^2,H+3^2,H+4^2,….,H+i^2，而不像线性探测尝试的是H+1,H+2,H+3,H+4,….,H+i。<strong>二次探测可以消除主集团，却可能造成次集团</strong>：两个元素经hash function计算出来的位置若相同，则插入时所探测的位置也相同，形成某种浪费。消除次集团的方法如复式散列。</li><li>（3）开链：这种做法是在每一个表格元素中维护一个list。hash function为选择某一个list，然后我们在那个list身上执行元素的插入、搜寻、删除等操作。若list够短，速度还是够快。使用开链法，表格的负载系数将大于1。</li></ul><h4 id="5-2-STI-STL的hashtable的数据结构"><a href="#5-2-STI-STL的hashtable的数据结构" class="headerlink" title="5.2 STI STL的hashtable的数据结构"></a>5.2 STI STL的hashtable的数据结构</h4><p>SGI STL中hash table使用的是开链法进行的冲突处理，其结构如图所示： </p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/21.png?raw=true" alt="image"></p><p><strong>bucket所维护的linked list不采用STL的list或者slist，而是自行维护hash table node</strong>。而至于<strong>buckets聚合体，则使用vector来完成</strong>，以便有动态扩容能力。</p><p>STL中的hash迭代器，是一种forward迭代器，只能++。有指向当前节点的指针和指向对应的vector的指针，没有后退操作，也就是没有所谓的逆向迭代器。有过next到list的尾端，就跳至下一个bucket。</p><p>设计思想：hashtable以质数来设计表格大小，预先计算好了28个质数，以备随时访问，大约都是两倍的关系递增，同时提供一个函数，查询28个质数中“最接近某数且大于某数”的质数作为vector的长度，如果需要重新分配，则分配下一个质数长度的vector。<br><strong>stl hash table扩张表格的触发条件是：当元素的数目大于或等于表格的大小</strong>。（这个条件应该是为了保证常数操作时间，在统计基础上得出的）。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/22.png?raw=true" alt="image"></p><p>insert分为insert_unique和insert_equal操作，前者保证插入的数不能有重复，后者可以插入键值相同的数。可以先用unique之后再用equal。insert_unique：先调用resize函数，看是否需要增大vector，然后插入，vector的索引通过取余得到。</p><p>resize：如果已有元素的个数大于vector的size，需要根据得到的最新质数，分配新的空间，将在旧空间的元素，重新计算hash，复制到新的空间，最后旧空间与新空间swap一下即可。insert_equal:也是先调用resize，遍历找到和他相同的节点，在该节点的前面插入。</p><p><strong>hashtable有一些无法处理的型别，比如string，double，float。除非用户为那些型别写了相应的hash function</strong>。</p><h3 id="6、hash-set和hash-multiset"><a href="#6、hash-set和hash-multiset" class="headerlink" title="6、hash_set和hash_multiset"></a>6、hash_set和hash_multiset</h3><p><strong>hash_set是以hashtable为底层机制</strong>。因hash_set所供应的操作接口，hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为。</p><p>set是为了能够快速搜寻元素。其底层是Rb-tree有自动排序功能，但hashtable没有自动排序功能，故hash_set没有自动排序功能。hash_set和set一样，元素的键值就是实值，实值就是键值。hash_set和set使用方式基本相同。</p><p><strong>hash_multiset和multiset完全相同</strong>，唯一差别是底层实现机制不同，hash_multiset的底层实现机制是hashtable，multiset的底层实现机制是Rb-tree。<strong>hash_multiset和hash_set实现上的唯一差别是</strong>，hash_set的插入操作采用hashtable中的insert_unique()，而hash_multiset的插入操作采用hashtable中的insert_euqal()。hash_multiset和hash_set使用方式基本相同。</p><h3 id="7、hash-map和hash-multimap"><a href="#7、hash-map和hash-multimap" class="headerlink" title="7、hash_map和hash_multimap"></a>7、hash_map和hash_multimap</h3><p>hash_map的底层实现机制也是hashtable。故hash_map所供应的操作接口，hashtable都提供了，所以几乎所有的hash_map操作行为，都只是转调用hashtable的操作行为而已。</p><p>map能够根据键值快速搜索元素，其底层实现机制是Rb-tree，Rb-tree具有自动排序功能，故map具有自动排序功能，但hashtable没有自动排序功能，故hash_map没有自动排序功能。hash_map和map都有相同的特性，即每一个元素都同时拥有一个实值（value）和一个键值（key）。hash_map和map使用方式大体相同。</p><p><strong>hash_multimap的特征与multimap完全相同</strong>，唯一差别为它的底层实现机制是hashtable，故hash_multimap的元素并不会被自动排序<strong>。hash_multimap和hash_map实现上的唯一差别是</strong>，hash_multimap的插入操作使用底层机制hashtable中的insert_equal()，而hahs_map使用的是底层机制hashtable中的insert_unique()。hash_multimap使用方式与hash_map完全相同。</p><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则： </p><ul><li>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector； </li><li>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list； </li><li>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque； </li><li>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap； </li><li>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十年一瞬，沧海之间</title>
      <link href="/2019/05/17/%E4%BD%93%E4%BC%9A%E7%94%9F%E6%B4%BB/%E5%9B%9E%E9%A1%BE%E5%8D%81%E5%B9%B4/"/>
      <url>/2019/05/17/%E4%BD%93%E4%BC%9A%E7%94%9F%E6%B4%BB/%E5%9B%9E%E9%A1%BE%E5%8D%81%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 体会生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第4章 序列式容器</title>
      <link href="/2019/05/16/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC4%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/05/16/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC4%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>所谓序列式容器，其中的元素<strong>都可序，但未必有序</strong>，C++语言本身提供了一个序列式容器array，STL另外再提供vector、list、deque、stack、queue、priority-queue等序列容器。其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器。</p><p>本文将主要总结各种序列式容器的实现和用法。<br><a id="more"></a></p><h3 id="1、vector容器"><a href="#1、vector容器" class="headerlink" title="1、vector容器"></a>1、vector容器</h3><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置就不能改变，如果要换个大点的空间，需要程序员自己来；<strong>vector是动态空间</strong>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</p><p>vector的实现技术，<strong>关键在于其对大小的控制以及重新配置时的数据移动效率</strong>。因为“配置新空间/数据移动/释放旧空间”是一个大工程。</p><h4 id="1-1-vector的迭代器"><a href="#1-1-vector的迭代器" class="headerlink" title="1.1 vector的迭代器"></a>1.1 vector的迭代器</h4><p>由于vector使用的是连续线性的空间，普通指针能满足所有vector迭代器的所需的操作行为，所以其迭代器实际就是原生指针，支持随机存取，为Random Access Iterator。</p><h4 id="1-2-vector的数据结构"><a href="#1-2-vector的数据结构" class="headerlink" title="1.2 vector的数据结构"></a>1.2 vector的数据结构</h4><p>vector所采用的数据结构：线性连续空间。<br>它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/9.png?raw=true" alt="image"></p><p>vector的空间配置策略为：</p><ul><li>当插入元素的时候，如果配置的空间不足，则扩充空间至当前的两倍，如果仍然不足则扩充至所需空间。 </li><li>容量的扩张必须经历“重新配置、元素移动、释放原空间”等过程。</li></ul><blockquote><p>vector的空间配置中，需要扩容时为什么为当前容量的两倍呢？<br>可以参考<a href="https://www.zhihu.com/question/36538542/answer/67929747，其实这是空间和时间的权衡，一次分配的空间少，那么空间浪费也少，但分配的次数多时间也多;一次分配的空间多则对应的分配次数少效率也高，但空间浪费会增加，常见的为2倍和1.5倍。" target="_blank" rel="noopener">https://www.zhihu.com/question/36538542/answer/67929747，其实这是空间和时间的权衡，一次分配的空间少，那么空间浪费也少，但分配的次数多时间也多;一次分配的空间多则对应的分配次数少效率也高，但空间浪费会增加，常见的为2倍和1.5倍。</a></p></blockquote><h3 id="2、list容器"><a href="#2、list容器" class="headerlink" title="2、list容器"></a>2、list容器</h3><p>list是一个双list是一个双向链表，每次插入或删除一个元素，就分配或释放一个元素的空间；所以list对空间的控制十分精确，而且任何位置的插入或删除需要的时间都是常数，即时间复杂度为o(1)。</p><p>list和vector是两种最常用的容器，什么时候选用哪种容器，视元素的多寡、元素的构造复杂度以及元素存取的行为特性，一般来说查找比较多的情况用vector,而插入和删除比较多的场景则比较适合list。</p><h4 id="2-1-list的迭代器"><a href="#2-1-list的迭代器" class="headerlink" title="2.1 list的迭代器"></a>2.1 list的迭代器</h4><p>  list迭代器正确的递增、递减、取值、成员取用操作是指，递增指向下一个节点，递减指向上一个节点，取值取的是节点的数据值，成员取用时取用的是节点的成员。list不能再以原生指针作为迭代器，而需要定义特定的iterator类。<strong>list迭代器是一种Bidirectional Iterator</strong>，支持单步的前进或后退操作。</p><p>list迭代器有一个重要性质：<strong>插入和结合操作都不会有list迭代器失效</strong>，这在vector是不成立的，因为vector的插入操作可能造成原来的重新配置，导致原有的迭代器全部失效。<strong>list的元素删除操作也只有指向删除元素的那个迭代器失效，其他迭代器不受影响</strong>。</p><h4 id="2-2-list的数据结构"><a href="#2-2-list的数据结构" class="headerlink" title="2.2 list的数据结构"></a>2.2 list的数据结构</h4><p> list的结构如下图，SGI list不仅是一个双向链表，而且还是一个<strong>环状双向链表</strong>，所以它只需一个指针，便可完整表现整个链表。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/10.png?raw=true" alt="image"></p><p> list缺省使用alloc作为空间配置器，以节点大小为配置单位。当我们以push_back()将元素插入list尾部时，此函数内部调用insert()，insert()是一个重载函数，有多种形式最简单的一种是：首先配置并构造一个节点，然后在尾端进行适当的指针操作，最后将节点插入进去，list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效。由于list是一个双向循环链表，只要我们把边界条件处理好，那么，在头部或者尾部插入元素的操作几乎是一样的，list内部提供一个所谓的迁移操作：将某连续范围的元素迁移到某个特定位置之前，节点间的指针移动而已。</p><blockquote><p>需要注意的是：list不能使用stl提供的通用sort算法，因为sort算法只接受Random Access Iterator，所以提供了自己的sort方法,可以直接调用，其内部好像是将原链分解为多个链表，然后依次进行合并。</p></blockquote><h3 id="3、deque容器"><a href="#3、deque容器" class="headerlink" title="3、deque容器"></a>3、deque容器</h3><p> vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾分别做元素的的安插和删除操作；vector当然也可以在头尾两端做动作，但是其头部动作效率奇差。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/11.png?raw=true" alt="image"></p><p>deque和vector的差异：</p><ul><li>一在于deque允许常数时间内对头端进行元素的插入或移除操作</li><li>二在于deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque没有必要提供所谓的空间保留功能。vector只能向尾端“生长”，而deque可以在前端或者尾端增加新空间。不存在像vector那样“因空间不足而分配一块更大的空间然后复制元素”问题。</li></ul><h4 id="3-1-deque的迭代器"><a href="#3-1-deque的迭代器" class="headerlink" title="3.1 deque的迭代器"></a>3.1 deque的迭代器</h4><p>deque提供random access iterator，但并不是原生指针。其实现的复杂度也很大，这也影响到相关算法的效率。所以<strong>如非必要，应该尽量使用vector而不是deque</strong>。对的确需要进行排序时，可以先将元素复制到一个vector，排序后再复制回deque。</p><h4 id="3-2-deque的数据结构"><a href="#3-2-deque的数据结构" class="headerlink" title="3.2 deque的数据结构"></a>3.2 deque的数据结构</h4><p>deque采用的是一种<strong>分段连续空间存储结构</strong>，采用一个map来管理这些空间段，这里所谓map是一小块连续空间，其中每个元素都是指针，指向另外一段较大的连续线性空间，称为缓冲区，<strong>缓冲区才是deque的存储空间主</strong>体，SGI STL允许我们指定缓冲区大小，默认值0表示使用512bytes缓冲区。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/12.png?raw=true" alt="image"></p><p>由于<strong>每个缓冲区的大小是固定的</strong>，当有新元素加入而空间不足时，就分配一个新的缓冲区,配置策略为reallocate_map()。 deque的这种结构，使得其迭代器上的操作可能需要跨越多个缓冲区，这使得迭代器的实现非常复杂。</p><h3 id="4、stack容器"><a href="#4、stack容器" class="headerlink" title="4、stack容器"></a>4、stack容器</h3><p>stack是一种<strong>先进后出</strong>的数据结构，它只有一个出口,stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端元素外，没有任何其他方式可以存取stack的其他元素，换言之，<strong>stack不允许有遍历行为</strong>。</p><p>stack不支持对元素的遍历，因此<strong>没有迭代器</strong>。</p><h4 id="4-1-stack的数据结构"><a href="#4-1-stack的数据结构" class="headerlink" title="4.1 stack的数据结构"></a>4.1 stack的数据结构</h4><p>stack是一种先进后出的数据结构，只可以在顶端进行元素操作。如果有某种双向开口的数据结构，将其接口改变，符合“先进后出”的特性，就可以形成一个stack：deque和list都是这样的结构。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/13.png?raw=true" alt="image"></p><p>SGI STL便以deque作为缺省情况下的stack底部结构。由于stack是以底部容器deque完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为<strong>adapter（配接器）</strong>,因此，STL stack往往不被归类为container（容器），而被归类为container adapter。</p><h3 id="5、queue容器"><a href="#5、queue容器" class="headerlink" title="5、queue容器"></a>5、queue容器</h3><p>queue是一种先进先出的数据结构，它有两个出口。queue允许新增元素、移除元素、从底端加入元素、取得最顶端元素（queue不允许有遍历行为）。</p><p>与stack一样，queue也不允许有遍历行为，queue没有迭代器。</p><p>与stack类似，SGI STL默认情况下以deque作为queue的底部结构。也是一种container adapter。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/14.png?raw=true" alt="image"></p><h3 id="6、heap"><a href="#6、heap" class="headerlink" title="6、heap"></a>6、heap</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演priority queue的助手,它分为 max heap 和min heap，在缺省情况下，<strong>max-heap是priority queue的底层实现机制</strong>。</p><h4 id="6-1-heap的数据结构"><a href="#6-1-heap的数据结构" class="headerlink" title="6.1 heap的数据结构"></a>6.1 heap的数据结构</h4><p>以array表达tree的方式，称为<strong>隐式表述法</strong>,这样就可以使用一个array表示出一颗完全二叉树。array的缺点是无法动态的改变大小，所以实际实现机制中的<strong>max-heap实际上是以一个vector表现的完全二叉树</strong>。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/15.png?raw=true" alt="image"></p><p> 从上图可以看出，第0号元素保留，这样就可以使得从arry[1]开始保存A，位于位置i的某个结点arry[i]，他的左子结点必然在arry[2*i]中，右子结点必然位于arry[2*i+1]，其父亲结点必然位于arry[i/2]处。</p><h4 id="6-2-heap的相关算法"><a href="#6-2-heap的相关算法" class="headerlink" title="6.2 heap的相关算法"></a>6.2 heap的相关算法</h4><ul><li><p>（1）建立堆：make_heap(_First, _Last, _Comp)<br>传入vector的迭代器，默认是建立最大堆的。对int类型，<strong>可以在第三个参数传入greater<int>()得到最小堆</int></strong>。</p></li><li><p>（2）在堆中添加数据：push_heap(_First, _Last)<br>要先在容器中加入数据push_back()，再调用push_heap()，vector的元素放在尾端，所以实际上push_heap所做的操作就是将尾端元素和其父节点进行比较，如果大于父节点则交换并不断上溯<strong>直到不满足大于为止</strong>。</p></li><li><p>（3）在堆中删除数据：pop_heap(_First, _Last)<br>该算法主要是先将vector的根节点即最大值放到vector的尾端，然后处理[start,end-1)区间的元素，从根节点开始，<strong>只要父节点的元素小于某个子节点的元素就进行交换并继续下溯</strong>，否则停止。 调用pop_heap()结束后vector()可以通过pop_back()取出最大元素。</p></li><li><p>（4）堆排序sort_heap(_First, _Last)<br>sort_heap算法的内部实现原理：每次pop_heap可获得heap中键值最大的元素，如果持续对整个heap做pop_heap操作，每次将操作范围从后向前缩减一个元素，当整个程序执行完毕时，便有了一个递增的序列。</p></li></ul><h4 id="6-3-heap的迭代器"><a href="#6-3-heap的迭代器" class="headerlink" title="6.3 heap的迭代器"></a>6.3 heap的迭代器</h4><p>heap本身并不是一个容器，它更多的是依靠vector容器底层，并在上面实现算法从而实现对tree的表达。heap不提供遍历功能，也没有对应的迭代器。</p><h3 id="7、priority-queue"><a href="#7、priority-queue" class="headerlink" title="7、priority__queue"></a>7、priority__queue</h3><p>priority_queue是一个拥有权值观念的queue，它允许加入新元素、移除旧元素、审视新元素等功能。由于是一个queue，所以只能在底端加入元素，在顶端取出元素。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/16.png?raw=true" alt="image"></p><p>priority_queue带有权值概念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列。<strong>priority_queue缺省情况下是以vector为底层容器，并加上heap处理规则实现</strong>，因此，STL priority_queue往往不被归类为container(容器)，而被归类为container adapter。</p><p>与queue一样，priority_queue也没有迭代器。</p><h3 id="8、slist"><a href="#8、slist" class="headerlink" title="8、slist"></a>8、slist</h3><p>STL list是个双向链表，迭代器属于双向的Bidirectional iterator，而SGI STL另提供了一个<strong>单向链表，名为slist，迭代器属于单向的Forward iterator</strong>。slist的许多功能也因此受到限制，不过单项链表所耗用的空间更小，某些操作更快，不失为另一种选择。</p><p>slist没有任何方便的方法可以回头定位到前一个位置，除了从头找起。slist不提供push_back()，只提供push_front()，因此slist的元素顺序和插入顺序完全是相反的！</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/17.png?raw=true" alt="image"></p><h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p>在实际使用过程中，到底选择这几种容器中的哪一个？通常应该根据遵循以下原则： </p><ul><li>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector； </li><li>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list； </li><li>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque； </li><li>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap； </li><li>（5）如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第3章 迭代器与traits编程技法</title>
      <link href="/2019/05/15/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC3%E7%AB%A0%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/"/>
      <url>/2019/05/15/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC3%E7%AB%A0%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本节主要介绍迭代器和traits编程技法。</p><p>迭代器是一种模板class，迭代器在STL中得到了广泛的应用，通过迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。此外，迭代器本身也是一种设计模式，其设计思想也值得我们仔细体会。</p><p>traits编程技法主要是通过模板的类型推导和class内嵌类型定义从而获取并使用迭代器的所指对象的真正类型，比如作为返回值等。</p><a id="more"></a><h3 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h3><p>什么是迭代器呢？迭代器有什么用呢？</p><p><strong>迭代器模式</strong>的定义：提供一种方法，在不需要暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素，能针对多种容器提供统一的接口。</p><p>下面以算法find为例，展示容器、算法和迭代器之间的合作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T &amp;value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//迭代器对容器进行了屏蔽，不需要知道容器是什么。</span></span><br><span class="line">    <span class="keyword">while</span> (first != last &amp;&amp; *frist != value)  ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要给予不同的迭代器，比如vector<int>::iterator、list<int>::iterator，find()就能对不同的容器进行查找，而无需针对某个容器来设计多个版本。这样看来，迭代器似乎依附在容器之下，<strong>有没有独立而范用的迭代器</strong>？这个问题先留着，后面自有答案。</int></int></p><h4 id="1-1-迭代器是一种smart-pointer"><a href="#1-1-迭代器是一种smart-pointer" class="headerlink" title="1.1 迭代器是一种smart pointer"></a>1.1 迭代器是一种smart pointer</h4><p>实际上<strong>迭代器是一种智能指针，是一种行为类似指针的对象</strong>，它内部封装了一个原始指针，并重载了operator*() 和operator-&gt;()等操作。</p><p>迭代器在这里使用的好处主要有：</p><ul><li>(1) 不用担心内存泄漏（类似智能指针，析构函数释放内存）；</li><li>(2) 对于list，取下一个元素不是通过自增而是通过next指针来取，这样子暴露了太多东西，使用智能指针可以对自增进行重载，从而<strong>提供统一接口</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于数组的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++() <span class="comment">//对于算法来说，就是++n操作，不关心内部实现</span></span><br><span class="line">&#123; </span><br><span class="line">    ++m_ptr; </span><br><span class="line">    retrun *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于链表的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    m_ptr = m_ptr-&gt;next(); <span class="comment">//next()用于获取链表的下一个节点 </span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-设计一个简单迭代器"><a href="#1-2-设计一个简单迭代器" class="headerlink" title="1.2 设计一个简单迭代器"></a>1.2 设计一个简单迭代器</h4><p>知道迭代器的主要功能后，<strong>下面我们来设计一个独立的list迭代器</strong>。首先先设计一个list：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List节点的结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> //链表节点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListItem() &#123; m_pNext = <span class="number">0</span>;&#125;</span><br><span class="line">    ListItem(T v, ListItem *p = <span class="number">0</span>) &#123; m_value = v; m_pNext = p;&#125;</span><br><span class="line">    <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> m_value;&#125; <span class="comment">//取值</span></span><br><span class="line">    <span class="function">ListItem* <span class="title">next</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_pNext;&#125;  <span class="comment">//取下一个指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;  <span class="comment">//存储的数据</span></span><br><span class="line">    ListItem* m_pNext;  <span class="comment">//指向下一个ListItem的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List表的结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">Push</span><span class="params">(T value)</span> <span class="comment">//从链表尾部插入元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_pTail = <span class="keyword">new</span> ListItem&lt;T&gt;(value);</span><br><span class="line">       m_pTail = m_pTail-&gt;next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表头部指针</span></span><br><span class="line">    ListItem&lt;T&gt;* begin() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_pHead;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表尾部指针</span></span><br><span class="line">    ListItem&lt;T&gt;* end() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_pTail;&#125;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//其它成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    ListItem&lt;T&gt; *m_pHead;    <span class="comment">//指向链表头部的指针</span></span><br><span class="line">    ListItem&lt;T&gt; *m_pTail;    <span class="comment">//指向链表尾部的指针</span></span><br><span class="line">    <span class="keyword">long</span> m_nSize;    <span class="comment">//链表长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>list有了，现在我们需要设计一个迭代器来访问list的值和next,来看一下怎么实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span>  //<span class="title">mylist</span>迭代器</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListIterator(T *p = <span class="number">0</span>) : m_ptr(p)&#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr;&#125;  <span class="comment">//取值，即dereference</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr;&#125; <span class="comment">//成员访问，即member access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置++操作</span></span><br><span class="line">    ListIterator&amp; <span class="keyword">operator</span>++() </span><br><span class="line">    &#123; </span><br><span class="line">        m_ptr = m_ptr-&gt;next(); <span class="comment">//暴露了ListItem的东西</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置++操作</span></span><br><span class="line">    ListIterator <span class="keyword">operator</span>++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        ListIterator temp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个ListIter是否指向相同的地址</span></span><br><span class="line">    bool opeartor==(<span class="keyword">const</span> ListIterator &amp;arg) <span class="keyword">const</span> &#123; <span class="keyword">return</span> arg.m_ptr == m_ptr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个ListIter是否指向不同的地址</span></span><br><span class="line">    bool <span class="keyword">operator</span>!=(<span class="keyword">const</span> ListIterator &amp;arg) <span class="keyword">const</span> &#123; <span class="keyword">return</span> arg.m_ptr != m_ptr;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>好了，现在list和其对应的迭代器都有了，那我们该怎么将ListIter将List和find()粘合起来呢？来看一下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span>  <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) mylist.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里暴露了ListItem，为了获取对应的指针</span></span><br><span class="line">    ListIterator&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">begin</span>(mylist.<span class="built_in">begin</span>());</span><br><span class="line">    ListIterator&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">end</span>(mylist.<span class="built_in">end</span>());</span><br><span class="line">    ListIterator&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; iter;</span><br><span class="line"></span><br><span class="line">    iter = <span class="built_in">find</span>(<span class="built_in">begin</span>, <span class="built_in">end</span>, <span class="number">3</span>);<span class="comment">//从链表中查找3</span></span><br><span class="line">    <span class="built_in">if</span> (iter != <span class="built_in">end</span>)  cout&lt;&lt;<span class="string">"found"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">else</span>  cout&lt;&lt;<span class="string">"not found"</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，算法find是通过*first != value用来判断元素是否符合要求，而上面测试代码中，first的类型为ListItem<int>，而value的类型为int，两者之间并没有可用的operator!=函数，因此，需要另外声明一个全局的operator!=重载函数，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> ListItem&lt;T&gt; &amp;item, T n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> item.Value() != n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></p><h4 id="1-3-迭代器小结"><a href="#1-3-迭代器小结" class="headerlink" title="1.3 迭代器小结"></a>1.3 迭代器小结</h4><p>从上面的代码我们可以看到，为了实现迭代器ListIter，我们在很多地方暴露了容器List的内部实现ListItem，这违背一开始说的<strong>迭代器模式中不暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素的定义</strong>。</p><p>可见，<strong>独立的迭代器并不能满足我们的要求，所以STL将迭代器的实现交给了容器，每种容器都会以嵌套的方式在内部定义专属的迭代器</strong>。各种迭代器的接口相同，内部实现却不相同，这也直接体现了泛型编程的概念。（泛型编程的思想主要是定义相同的接口，而内部实现各不相同，从而实现多态）  </p><p>总而言之，<strong>迭代器依附于具体的容器，即不同的容器有不同的迭代器实现</strong>。     对于泛型算法find，只要给它传入不同的迭代器，就可以对不同的容器进行查找操作。迭代器的穿针引线，有效地实现了算法对不同容器的访问。</p><h3 id="2、traits编程技法"><a href="#2、traits编程技法" class="headerlink" title="2、traits编程技法"></a>2、traits编程技法</h3><p>其实上一章我们就涉及过trait编程技法，就是在配置器的destroy()函数中，我们需要用traits来判断某类型的构造和析构函数是否是trival(无用的)，从而决定有没有必要调用析构函数，从而减少一些不必要的操作。</p><p>本节我们来了解其实现原理。</p><h4 id="2-1-迭代器型别value-type"><a href="#2-1-迭代器型别value-type" class="headerlink" title="2.1 迭代器型别value type"></a>2.1 迭代器型别value type</h4><p>迭代器所指对象的型别，称为该迭代器的value type，比如int*的value type为int。那我们该怎么来获取这个型别呢？<br>RTTI性质中的typeid()只能获得型别的名称，但不能用来声明变量。要想获得迭代器型别，<strong>参数推导机制</strong>是一个不错的方法。</p><p>在下面这个函数里面，如果我们想要得到迭代器的value type，以下做法是否可行？看看下面这种情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iteratorator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Iteratorator iter)</span> </span>&#123;</span><br><span class="line">    *Iteratorator var;<span class="comment">//对迭代器取值，得其值类型？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，以上代码是编译失败的，C++并不提供这个支持。</p><h4 id="2-2-参数推导机制-内嵌型别机制"><a href="#2-2-参数推导机制-内嵌型别机制" class="headerlink" title="2.2 参数推导机制+内嵌型别机制"></a>2.2 参数推导机制+内嵌型别机制</h4><p>既然上述方式不能行，那我们换一种思路，引入中间层试一下，来看代码实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt; <span class="comment">//T推导为int型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(Iterator iter, T t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;<span class="comment">//这里就解决了问题</span></span><br><span class="line">    <span class="comment">//这里做原本func()的工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt; <span class="comment">//Iterator推导为int*类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Iterator iter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_impl(iter, *iter);<span class="comment">//这里通过传递*iter，让func_impl去推导</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span>  <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i); <span class="comment">//这里传入的是一个迭代器（原生指针也是一种迭代器）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面做法通过多层迭代很巧妙地导出了T，但是却很有局限性，比如，我的func()希望返回迭代器的value type类型返回值，那么上面的做法就无能为力了。<strong>这种template参数推导的只是参数，无法推导返回值</strong>。</p><p>上述方法还是不行，但如果在参数推导机制上加上内嵌型别(typedef)呢？来看一下实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//内嵌类型声明</span></span><br><span class="line">    Iterator(T *p = <span class="number">0</span>) : m_ptr(p) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr;&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="comment">//以迭代器所指对象的类型作为返回类型</span></span><br><span class="line"><span class="comment">//注意typename是必须的，它告诉编译器这是一个类型</span></span><br><span class="line"><span class="keyword">typename</span> Iterator::<span class="function">value_type <span class="title">func</span><span class="params">(Iterator iter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span>  <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Iterator&lt;<span class="keyword">int</span>&gt; iter(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;func(iter)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出：10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的解决方案近乎完美了，但其实有一个隐晦的陷阱：<strong>实际上并不是所有的迭代器都是class type，原生指针也是一种迭代器,由于原生指针不是class type，所以没法为它定义内嵌型别</strong>。要解决这个问题，Partial specialization（模板偏特化）就出场了。</p><h4 id="2-4-Partial-specialization（模板偏特化）"><a href="#2-4-Partial-specialization（模板偏特化）" class="headerlink" title="2.4 Partial specialization（模板偏特化）"></a>2.4 Partial specialization（模板偏特化）</h4><p>所谓偏特化是指如果一个class template拥有一个以上的template参数，我们可以针对其中某个（或多个，但不是全部）template参数进行特化，比如下面这个例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line">class C <span class="meta">&#123;...&#125;</span>; //此泛化版本的T可以是任何类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;typename T&gt;</span><br><span class="line">class C&lt;T*&gt; <span class="meta">&#123;...&#125;</span>; //特化版本，仅仅适用于T为“原生指针”的情况，是泛化版本的限制版</span><br></pre></td></tr></table></figure></p><p>所谓特化，就是特殊情况特殊处理，第一个类为泛化版本，T可以是任意类型，第二个类为特化版本，是第一个类的特殊情况，只针对原生指针。</p><h4 id="2-5-原生指针怎么办？——特性“萃取”traits"><a href="#2-5-原生指针怎么办？——特性“萃取”traits" class="headerlink" title="2.5 原生指针怎么办？——特性“萃取”traits"></a>2.5 原生指针怎么办？——特性“萃取”traits</h4><p>还记得前面的参数推导机制+内嵌型别机制获取型别有什么问题吗？问题就是原生指针虽然是迭代器但不是class，无法定义内嵌型别，而偏特化似乎可以解决这个问题。</p><p>有了上面的认识，我们再看看STL是如何应用的,STL定义了下面的类模板，它专门用来“萃取”迭代器的特性，而value type正是迭代器的特性之一：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> //类型萃取机</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们看看加入萃取机前后的变化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt; <span class="comment">//萃取前</span></span><br><span class="line"><span class="keyword">typename</span> Iterator::<span class="function">value_type  <span class="title">func</span><span class="params">(Iterator iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过iterator_traits作用后的版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;  <span class="comment">//萃取后</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type  <span class="title">func</span><span class="params">(Iterator iter)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里也许你会晕了，iterator_traits::value_type跟Iterator::value_type完全是同一个东西，为什么还要增加iterator_traits这一层封装，是不是多此一举？</p><p>回想萃取之前的版本有什么缺陷：不支持原生指针。而通过萃取机的封装，<strong>我们可以通过类模板的特化来支持原生指针的版本</strong>！如此一来，无论是智能指针，还是原生指针，iterator_traits::value_type都能起作用，这就解决了前面的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator_traits的偏特化版本，针对迭代器是原生指针的情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-6-偏特化处理更多的情况——const指针"><a href="#2-6-偏特化处理更多的情况——const指针" class="headerlink" title="2.6 偏特化处理更多的情况——const指针"></a>2.6 偏特化处理更多的情况——const指针</h4><p>通过偏特化添加一层中间转换的traits模板class，能实现对原生指针和迭代器的支持，但是这里还有一个特殊情况，对于指向常数对象的指针又该怎么处理呢？比如下面的例子：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;::value_type  //获得的value_type是<span class="keyword">const</span> <span class="keyword">int</span>，并不是<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>这里会调用的还是上述原生指针对应的偏特化，获得的value taype是const int，我们知道，const变量只能初始化，而不能赋值（这两个概念必须区分清楚）。这将带来问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type  <span class="title">func</span><span class="params">(Iterator iter)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type tmp;<span class="comment">//注意不是typedef哦..</span></span><br><span class="line">    tmp = *iter; <span class="comment">//ok?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;val;</span><br><span class="line">func(p); <span class="comment">//这时函数里对tmp的赋值都将是不允许的</span></span><br></pre></td></tr></table></figure></p><p>可以看到，我们的本意是获取int，而事实上获取到的是const int，这将造成误会，那该怎么办呢？答案还是偏特化，来看实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt; //特化<span class="title">const</span>指针</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//得到T而不是const T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-7-traits编程技法总结"><a href="#2-7-traits编程技法总结" class="headerlink" title="2.7 traits编程技法总结"></a>2.7 traits编程技法总结</h4><p>通过本节的学习，我们知道traits编程技法就是增加一层中间的模板class，以解决获取迭代器的型别中的原生指针问题，其核心知识点在于<strong>模板参数推导机制+内嵌类型定义机制</strong>，为了能处理原生指针这种特殊的迭代器，在traits机这个模板class上引入了<strong>偏特化机制</strong>。traits就像一台“特性萃取机”，把迭代器放进去，就能榨取出迭代器的特性。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/7.png?raw=true" alt="image"></p><h3 id="3、迭代器的型别和种类"><a href="#3、迭代器的型别和种类" class="headerlink" title="3、迭代器的型别和种类"></a>3、迭代器的型别和种类</h3><h4 id="3-1-迭代器的型别"><a href="#3-1-迭代器的型别" class="headerlink" title="3.1 迭代器的型别"></a>3.1 迭代器的型别</h4><p>常见迭代器相应型别有5种：</p><ul><li>（1）value_type：迭代器所指对象的类型，原生指针也是一种迭代器，对于原生指针int*，int即为指针所指对象的类型，也就是所谓的value_type。</li><li>（2）difference_type用来表示两个迭代器之间的距离，对于原生指针，STL以C++内建的ptrdiff_t作为原生指针的difference_type。</li><li>（3）reference_type是指迭代器所指对象的类型的引用，reference_type一般用在迭代器的*运算符重载上，如果value_type是T，那么对应的reference_type就是T&amp;；如果value_type是const T，那么对应的reference_type就是const T&amp;。</li><li>（4）pointer_type就是相应的指针类型，对于指针来说，最常用的功能就是operator*和operator-&gt;两个运算符。</li><li>（5）iterator_category的作用是标识迭代器的移动特性和可以对迭代器执行的操作，从iterator_category上，可将迭代器分为Input Iterator、Output Iterator、Forward Iterator、Bidirectional Iterator、Random Access Iterator五类，这样分可以尽可能地提高效率。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Category,</span><br><span class="line">         <span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>,</span><br><span class="line">         <span class="keyword">typename</span> Pointer = T*,</span><br><span class="line">         <span class="keyword">typename</span> Reference = T&amp;&gt;</span><br><span class="line">struct iterator <span class="comment">//迭代器的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>iterator class不包含任何成员变量，只有类型的定义，因此不会增加额外的负担。由于后面三个类型都有默认值，在继承它的时候，只需要提供前两个参数就可以了。<strong>这个类主要是用来继承的，在实现具体的迭代器时，可以继承上面的类，这样子就不会漏掉上面的5个型别了</strong>。</p><p>对应的迭代器萃取机设计如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>  //特性萃取机，萃取迭代器特性</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> typeanme I:difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要对型别为指针和const指针设计特化版本</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-迭代器的分类"><a href="#3-2-迭代器的分类" class="headerlink" title="3.2 迭代器的分类"></a>3.2 迭代器的分类</h4><p>迭代器型别iterator_category对应迭代器类别，这个类别会限制迭代器的操作和移动特性，<br><strong>除了原生指针以外</strong>，迭代器被分为五类：</p><ul><li><strong>(1) Input Iterator</strong>： 此迭代器不允许修改所指的对象，即是只读的。支持==、!=、++、*、-&gt;等操作。</li><li><strong>(2) Output Iterator</strong>：允许算法在这种迭代器所形成的区间上进行只写操作。支持++、*等操作。</li><li><strong>(3) Forward Iterator</strong>：允许算法在这种迭代器所形成的区间上进行读写操作，但只能单向移动，每次只能移动一步。支持Input Iterator和Output Iterator的所有操作。</li><li><strong>(4) Bidirectional Iterator</strong>：允许算法在这种迭代器所形成的区间上进行读写操作，可双向移动，每次只能移动一步。支持Forward Iterator的所有操作，并另外支持–操作。</li><li><strong>(5) Random Access Iterator</strong>：包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种Iterator的所有操作，并另外支持it + n、it - n、it += n、 it -= n、it1 - it2和it[n]等操作。</li></ul><p><strong>为什么我们要对迭代器进行分类呢</strong>?<br>设计算法时，如果可能，我们尽量针对上面某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一种定义，这样才能在不同情况下提供最大效率。比如，有个算法可接受Forward Iterator，但是你传入一个Random Access Iterator，虽然可用（Random Access Iterator也是一种Forward Iterator），但是不一定是最佳的，因为Random Access Iterator可能更加臃肿，效率不一定高。</p><p>对于一个算法，它该调用哪个类型的迭代器，我们可以简单的在内部使用if…else在执行时选择，但是这样却降低了效率，如果能在编译时选择就再好不过了。STL使用了重载函数机制达成了这个目标，此处就不再深入讨论了。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
            <tag> traits编程技法 </tag>
            
            <tag> 模板特化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11特性之move和forward应用与区别</title>
      <link href="/2019/05/14/c++%E5%9F%BA%E7%A1%80/c++11move%E5%92%8Cforword/"/>
      <url>/2019/05/14/c++%E5%9F%BA%E7%A1%80/c++11move%E5%92%8Cforword/</url>
      
        <content type="html"><![CDATA[<p>move和forward有他们各自的应用场景，学习并合理区别他们的用法很重要。<br>最近刚好把它们俩梳理了一遍, 来写写move和forward为什么会出现, 他们能解决什么痛点.<br><a id="more"></a></p><h3 id="1、特性背景"><a href="#1、特性背景" class="headerlink" title="1、特性背景"></a>1、特性背景</h3><p>c++中传值默认是copy，而copy开销很大， 比如下面例子, 他们都要经历至少一次复制操作:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="string">"some temporary string"</span>)</span></span>; <span class="comment">//初始化string, 传入函数, 可能会导致string的复制</span></span><br><span class="line">v.push_back(<span class="type">X</span>()); <span class="comment">//初始化了一个临时X, 然后被复制进了vector</span></span><br><span class="line">a = b + <span class="built_in">c</span>; <span class="comment">//b+c是一个临时值, 然后被赋值给了a</span></span><br><span class="line">x++; <span class="comment">//x++操作也有临时变量的产生</span></span><br><span class="line">a = b + <span class="built_in">c</span> + d; <span class="comment">//c+d一个临时变量, b+(c+d)另一个临时变量</span></span><br></pre></td></tr></table></figure><p>这些临时变量在C++11里被定义为<strong>右值</strong>, 因为没有对应的变量名存他们，同时有对应变量名的被称为<strong>左值</strong>。</p><h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><p>以上copy操作有没有必要呢? 有些地方可不可以省略呢? 我们来看看下面一个案例, 之后我们会用到它来推导出为什么我们需要move和forward:</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A<span class="meta">&#123;...&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> A::<span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp; var1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; var2)&#123;</span><br><span class="line">  m_var1 = var1;  //copy</span><br><span class="line">  m_var2 = var2;  //copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个写法是没法避免copy的, 因为怎么着都得把外部初始的string传进set函数, 再复制给成员变量:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">a1</span><span class="comment">;</span></span><br><span class="line">string var1(<span class="string">"string1"</span>)<span class="comment">;</span></span><br><span class="line">string var2(<span class="string">"string2"</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">a1</span><span class="meta">.set</span>(var1, var2)<span class="comment">; // OK to copy</span></span><br></pre></td></tr></table></figure><p>但下面这个呢? 临时生成了2个string, 传进set函数里, 复制给成员变量, 然后这两个临时string再被回收，本质上来说，和上一个是一样的，是不是有点多余?</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">a1</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">a1</span><span class="meta">.set</span>(<span class="string">"temporary str1"</span>,<span class="string">"temporary str2"</span>)<span class="comment">; //temporary, unnecessary copy</span></span><br></pre></td></tr></table></figure><p>上面复制的行为, 在底层的操作很可能是这样的:</p><ul><li>(1)临时变量的内容先被复制一遍</li><li>(2)被复制的内容覆盖到成员变量指向的内存</li><li>(3)临时变量用完了再被回收</li></ul><p>这里能不能优化一下呢? 临时变量反正都要被回收, 如果能直接把临时变量的内容, 和成员变量内容交换一下, 就能避免复制了? 如下:</p><ul><li>(1)成员变量内部的指针指向”temporary str1”所在的内存</li><li>(2)临时变量内部的指针指向成员变量以前所指向的内存</li><li>(3)最后临时变量指向的那块内存再被回收</li></ul><p>上面这个操作避免了一次copy的发生, 其实它就是所谓的<strong>move语义</strong>.</p><h3 id="3、传变量和临时变量"><a href="#3、传变量和临时变量" class="headerlink" title="3、传变量和临时变量"></a>3、传变量和临时变量</h3><p>再回到我们的例子，没法避免copy操作的时候, 还是要用const T&amp;把<strong>变量</strong>传进set函数里, 现在T &amp;叫左值引用了, 如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; var1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; var2)</span></span>&#123;</span><br><span class="line">  m_var1 = var1;  <span class="comment">//copy</span></span><br><span class="line">  m_var2 = var2;  <span class="comment">//copy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">var1</span><span class="params">(<span class="string">"string1"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">var2</span><span class="params">(<span class="string">"string2"</span>)</span></span>;</span><br><span class="line">a1.<span class="built_in">set</span>(var1, var2); <span class="comment">// OK to copy</span></span><br></pre></td></tr></table></figure></p><p>传临时变量的时候, 可以传T &amp;&amp;, 叫右值引用, 它能接收临时变量（右值）,之后再调用std::move就避免copy了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> &amp;&amp; var1, <span class="built_in">string</span> &amp;&amp; var2)</span></span>&#123;</span><br><span class="line">  <span class="comment">//avoid unnecessary copy!</span></span><br><span class="line">  m_var1 = <span class="built_in">std</span>::move(var1);  </span><br><span class="line">  m_var2 = <span class="built_in">std</span>::move(var2);</span><br><span class="line">&#125;</span><br><span class="line">A a1;</span><br><span class="line"><span class="comment">//temporary, move! no copy!</span></span><br><span class="line">a1.<span class="built_in">set</span>(<span class="string">"temporary str1"</span>,<span class="string">"temporary str2"</span>);</span><br></pre></td></tr></table></figure><h3 id="4、引入forward"><a href="#4、引入forward" class="headerlink" title="4、引入forward"></a>4、引入forward</h3><p>现在终于能处理临时变量了, 但如果按上面那样写, 处理临时变量用右值引用string &amp;&amp;, 处理普通变量用const引用const string &amp;…这代码量有点大呀? 每次都至少要写两遍,怎么避免重复呢？那就是forward。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename <span class="built_in">T1</span>, typename <span class="built_in">T2</span>&gt;</span><br><span class="line">void set(<span class="built_in">T1</span> &amp;&amp; var1, <span class="built_in">T2</span> &amp;&amp; var2)&#123;</span><br><span class="line">  m_var1 = std::forward&lt;<span class="built_in">T1</span>&gt;(var1)<span class="comment">;</span></span><br><span class="line">  m_var2 = std::forward&lt;<span class="built_in">T2</span>&gt;(var2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perfect forward (完美转发)能将上述两者结合在一起：</p><ul><li>如果外面传来了右值临时变量, 它就转发右值并且启用move语义.</li><li>如果外面传来了左值, 它就转发左值并且启用copy. 然后它也还能保留const.</li></ul><h3 id="5、有了forward为什么还要用move"><a href="#5、有了forward为什么还要用move" class="headerlink" title="5、有了forward为什么还要用move?"></a>5、有了forward为什么还要用move?</h3><p>技术上来说, forward确实可以替代所有的move，但还有一些问题:</p><p>首先, forward常用于template函数中, 使用的时候必须要多带一个template参数T:forward<t>, 代码略复杂;还有, 明确只需要move的情况而用forward, 代码意图不清晰, 其他人看着理解起来比较费劲.</t></p><p>更技术上来说, 他们都可以被static_cast替代. 为什么不用static_cast呢? 也就是为了读着方便易懂.</p><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>可以这么说，move属于强转，forward对于左值还是会转换成左值，对于右值转换成右值。一般在模板元编程里面，对于forward需求比较多，因为可以处理各种不同场景。而一般的代码里面，由于可以确认传入的是左值还是右值，所以一般直接就调用std::move了。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11特性 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11特性之std-move的使用和原理</title>
      <link href="/2019/05/14/c++%E5%9F%BA%E7%A1%80/c++11std-move%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
      <url>/2019/05/14/c++%E5%9F%BA%E7%A1%80/c++11std-move%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>面试经常遇到std::move，同时也确实存在一些知识点需要整理，在这里总结一下。<br><a id="more"></a></p><h3 id="1、左值和右值"><a href="#1、左值和右值" class="headerlink" title="1、左值和右值"></a>1、左值和右值</h3><p>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。</p><p>一般来说，变量可以取地址，所以是左值，但是常量和临时对象等不可以取地址，所以是右值。</p><p><strong>左值的声明符号为&amp;，右值的声明符号为&amp;&amp;。</strong></p><h3 id="2、右值引用的作用与移动语义"><a href="#2、右值引用的作用与移动语义" class="headerlink" title="2、右值引用的作用与移动语义"></a>2、右值引用的作用与移动语义</h3><p>我们可能在各种场合（初始化,push_back,函数返回等）调用拷贝构造函数将一个临时对象初始化给另一个对象，而这时如果是深拷贝则代价会比较大。</p><p>深拷贝对程序的影响比较大，把临时对象的内容直接移动（move）给被赋值的左值对象，效率改善将是显著的。这就产生了移动语义，<strong>右值引用是用来支持转移语义的</strong>。</p><p>移动语义可以将资源（堆，系统对象等） 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。</p><h3 id="3、移动语义的实现"><a href="#3、移动语义的实现" class="headerlink" title="3、移动语义的实现"></a>3、移动语义的实现</h3><p>移动语义意味着两点：</p><ul><li><strong>原对象不再被使用</strong>，如果对其使用会造成不可预知的后果。</li><li>所有权转移，资源的所有权被转移给新的对象。</li></ul><p>移动语义通过<strong>移动构造函数</strong>和<strong>移动赋值操作符</strong>实现，其与拷贝构造函数类似，区别如下：</p><ul><li>参数的符号必须为右值引用符号，即为&amp;&amp;。</li><li>参数不可以是常量，因为函数内需要修改参数的值</li><li>参数的成员转移后需要修改（如改为nullptr），避免临时对象的析构函数将资源释放掉。</li></ul><p>下面来一个实例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()&#123;&#125;;</span><br><span class="line">    Test(Test &amp;&amp;test) <span class="comment">//移动构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_p=test.m_p;</span><br><span class="line">        test.m_p = <span class="literal">nullptr</span>; <span class="comment">//修改参数的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;&amp;test) <span class="comment">//移动赋值操作符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;test)</span><br><span class="line">        &#123;</span><br><span class="line">            m_p = test.m_p;</span><br><span class="line">            test.m_p= <span class="literal">nullptr</span>; <span class="comment">//修改参数资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">    vec.push_back(Test()); <span class="comment">//移动构造函数</span></span><br><span class="line">    Test foo = Test(); <span class="comment">//注意.....这里是拷贝构造函数...但是为什么？？？</span></span><br><span class="line">    foo = Test();      <span class="comment">//移动赋值操作符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果没有实现移动构造函数，则默认调用拷贝构造函数，拷贝方式为浅拷贝。但是对于数组等还会有清空处理…</p></blockquote><h3 id="4、std-move的实现"><a href="#4、std-move的实现" class="headerlink" title="4、std::move的实现"></a>4、std::move的实现</h3><p>std::move除了能实现右值引用，同时也能实现对左值的引用。在左值上使用移动语义。</p><p>std::move的实现主要依赖于static&lt;T&amp;&amp; &gt;，但同时也会做一些参数推导的工作。其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-对于右值"><a href="#4-1-对于右值" class="headerlink" title="4.1 对于右值"></a>4.1 对于右值</h4><p>有如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"dengwen"</span>));</span><br></pre></td></tr></table></figure></p><p>首先模板类型推导确定T的类型为string，得remove_reference<t>::type为string，故返回值和static的模板参数类型都为string &amp;&amp;;而move的参数就是string &amp;&amp;,于是不需要进行类型转换直接返回。</t></p><h4 id="4-2-对于左值"><a href="#4-2-对于左值" class="headerlink" title="4.2 对于左值"></a>4.2 对于左值</h4><blockquote><p>引入一条规则：当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断模板参数类型为实参的左值引用。</p></blockquote><p>有如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"dengwen"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::move(str);</span><br></pre></td></tr></table></figure></p><p>此时明显str是一个左值，首先模板类型推导确定T的类型为string &amp;，得remove_reference<t>::type为string。故返回值和static的模板参数类型都为string &amp;&amp;;而move的参数类型为string&amp; &amp;&amp;，<strong>折叠</strong>后为sting &amp;。</t></p><p>所以结果就为将string &amp;通过static_cast<string &&>转为string &amp;&amp;。返回string &amp;&amp;。</string></p><h4 id="4-3-引用折叠"><a href="#4-3-引用折叠" class="headerlink" title="4.3 引用折叠"></a>4.3 引用折叠</h4><p>如果间接的创建一个引用的引用，则这些引用就会“折叠”。如：     </p><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;都折叠成X&amp;</li><li>X&amp;&amp; &amp;&amp;折叠为X&amp;&amp;</li></ul><h3 id="5、测试实例"><a href="#5、测试实例" class="headerlink" title="5、测试实例"></a>5、测试实例</h3><p>下面我们写一个完整的测试程序来测试std::move在各种场景下的运用和结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::move进行右值引用，可以将左值和右值转为右值引用， 这种操作意味着被引用的值将不再被使用，否则会引起“不可预期的结果”。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">        q=*p=k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"q address: "</span>&lt;&lt;&amp;q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"p address: "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"常规变量-----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">6</span>, s = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">" "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    k=<span class="built_in">std</span>::move(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">" "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    k=<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"常规数组（自动清空）-----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    data1 = <span class="built_in">std</span>::move(data2);</span><br><span class="line"><span class="comment">//     data1 = static_cast&lt;vector&lt;int&gt; &amp;&amp;&gt;(data2);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"after move:"</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt; <span class="string">"data1:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> foo : data1)  <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt; <span class="string">"data2:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> foo : data2)  <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"指针变量-----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">3</span>, n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;m, *q = &amp;n;</span><br><span class="line">    p = <span class="built_in">std</span>::move(q);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"       "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q&lt;&lt;<span class="string">"       "</span> &lt;&lt; *q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"class 对象-----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Base <span class="title">ba</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">bb</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    bb=<span class="built_in">std</span>::move(ba);</span><br><span class="line">    ba.show();</span><br><span class="line">    bb.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"string（自动清空） -----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="built_in">std</span>::move(<span class="string">"deng wen"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"luo chao"</span>)</span></span>;</span><br><span class="line">    str1=<span class="built_in">std</span>::move(str);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;str&lt;&lt;<span class="string">"   "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;str1&lt;&lt;<span class="string">"   "</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"vector（自动清空） -----------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2=&#123;<span class="number">9</span>,<span class="number">0</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    vec1=<span class="built_in">std</span>::move(vec2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> foo : vec1)  <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="string">"  "</span>;<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec1.size();i++)  <span class="built_in">cout</span> &lt;&lt; &amp;vec1[i] &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"&amp;&amp;的真正含义--------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> ta = <span class="number">3</span>; <span class="comment">// int &amp;&amp;tb=2;//临时对象的引用，即tb存的是临时对象2的地址</span></span><br><span class="line">    <span class="keyword">int</span> tb = <span class="number">2</span>; <span class="comment">//生成对象tb,并将2赋值给tb所指的地址中。 感觉两种的结果一样，但是含义不一样</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ta &lt;&lt; <span class="string">"  "</span> &lt;&lt; ta &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;tb &lt;&lt; <span class="string">"  "</span> &lt;&lt; tb &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> tc = <span class="number">1</span>;</span><br><span class="line">    ta = tc;</span><br><span class="line">    tb = tc;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ta &lt;&lt; <span class="string">"  "</span> &lt;&lt; ta &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;tb &lt;&lt; <span class="string">"  "</span> &lt;&lt; tb &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11特性 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《STL源码剖析》第2章 空间配置器</title>
      <link href="/2019/05/13/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC2%E7%AB%A0%20%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
      <url>/2019/05/13/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC2%E7%AB%A0%20%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>由于整个STL的操作对象都放在容器内，而容器需要配置空间以放置数据，学习空间配置器的原理是掌握其它部分知识的基础。</p><p>为什么不说allocator是内存配置器而说它是空间配置器呢？这是因为空间配置器的配置不一定是内存，其实也可以是磁盘或者其他辅助存储介质。<strong>我们也可以自己实现空间配置器，只需要自己对应实现相应的标准接口即可</strong>。</p><a id="more"></a><h3 id="1、SGI-STL配置器简介"><a href="#1、SGI-STL配置器简介" class="headerlink" title="1、SGI STL配置器简介"></a>1、SGI STL配置器简介</h3><p>SGI STL的配置器与众不同，也与标准规范不同，<strong>其名称是 alloc 而非 allocator</strong> ,而且不接受任何参数。如果要在程序中明确使用SGI配置器，那么应该这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::alloc&gt; iv; <span class="comment">//而不是vector&lt;int,std::allocator&lt;int&gt; &gt; iv;</span></span><br></pre></td></tr></table></figure></p><p>标准配置器的名字是allocator，而且可以接受参数。<br>SGI STL的每一个容器都已经指定了<strong>缺省配置器</strong>：alloc。我们很少需要自己去指定空间配置器。比如vector容器的声明：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = alloc&gt;  <span class="comment">// 预设使用alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>其实SGI也定义了一个符合部分标准，名为allocator的配置器，但是它自己不使用，也不建议我们使用，主要原因是效率不佳。<strong>它只是把C++的操作符::operator new和::operator delete做了一层简单的封装而已</strong>，可以用但是不建议我们使用。</p></blockquote><h3 id="2、SGI特殊的空间配置器alloc"><a href="#2、SGI特殊的空间配置器alloc" class="headerlink" title="2、SGI特殊的空间配置器alloc"></a>2、SGI特殊的空间配置器alloc</h3><p>我们所习惯的c++内存配置操作和释放操作如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo; <span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf; <span class="comment">// 将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure></p><p>这其中的new 操作符（new operator）包含两阶段操作：</p><ul><li>（1）调用operator new配置内存       </li><li>（2）调用Foo::Foo( )构造函数构造对象内容。</li></ul><p>delete操作符包含两阶段操作：</p><ul><li>（1）调用Foo::~Foo( )析构函数将对象析构。        </li><li>（2）调用operator delete释放内存</li></ul><p>SGI也提供了类似的操作函数，<strong>STL allocator 将这两阶段操作区分开来。内存配置操作由 alloc::allocate() 负责，内存释放操作由 alloc::deallocate() 负责；对象构造操作由 ::construct() 负责，对象析构操作由 ::destroy() 负责。</strong></p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/1.png?raw=true" alt="image"></p><p>如上图，STL空间配置器主要分三个文件实现：  </p><ul><li>（1）<code>&lt;stl_construct.h&gt;</code>：定义了全局函数construct()和destroy()，负责对象的构造和析构。</li><li>（2）<code>&lt;stl_alloc.h&gt;</code>：定义了一、二两级配置器，彼此合作，配置器名为alloc。</li><li>（3）<code>&lt;stl_uninitialized.h&gt;</code>：这里定义了一些全局函数，用来初始化填充(fill)或复制大块内存数据，他们也都隶属于STL标准规范,具体实现可能为construct或memmove。</li></ul><h3 id="3、构造和析构工具：construct-和destroy"><a href="#3、构造和析构工具：construct-和destroy" class="headerlink" title="3、构造和析构工具：construct()和destroy()"></a>3、构造和析构工具：construct()和destroy()</h3><p>这两个函数的主要版本和功能如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/2.png?raw=true" alt="image"></p><h4 id="3-1-destory-函数"><a href="#3-1-destory-函数" class="headerlink" title="3.1 destory()函数"></a>3.1 destory()函数</h4><p>destroy()函数有两个版本，分别如下：<br>(1)第一个版本较简单，接受一个指针作为参数，直接调用对象的析构函数即可，其源代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">pointer</span>) &#123;</span></span><br><span class="line">    pointer-&gt;~T();<span class="comment">// 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)第二个版本，其参数接受两个迭代器，将两个迭代器所指范围内的所有对象析构掉。而且，<strong>它采用了一种特别的技术：依据元素的型别，判断其是否有trivial destructor（无用的析构函数）进行不同的处理</strong>。value_type用于获取迭代器所指对象的型别，_type_traits用于判断类型的析构函数是否有作用。如果对象的析构函数是trivial的,则不需要做析构操作。<br>SGI的destroy()的实际由_destroy()调用_destroy_aux()实现。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 destroy() 第二版本，接受两个迭代器。它会设法找出元素的数值型別，</span></span><br><span class="line"><span class="comment">// 进而利用 __type_traits&lt;&gt; 求取最适当措施。</span></span><br><span class="line">template &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> destroy(ForwardIterator first, ForwardIterator last) &#123;</span><br><span class="line">  __destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型別（value type）是否有 trivial destructor，分别调用上面的函数进行不同的处理</span></span><br><span class="line">template &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 non-trivial destructor…</span></span><br><span class="line">template &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    destroy(&amp;*first);<span class="comment">//调用析构函数,destory不支持迭代器，转为第一个版本执行</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 trivial destructor…</span></span><br><span class="line">template &lt;<span class="keyword">class</span> ForwardIterator&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125;<span class="comment">//不调用析构函数</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-construct-函数"><a href="#3-2-construct-函数" class="headerlink" title="3.2 construct()函数"></a>3.2 construct()函数</h4><p>construct()函数使用了new placement操作符，其也叫new placement运算子，作用是在指针所指的空间上初始化一个对象值，实现代码如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T<span class="number">1</span>, <span class="keyword">class</span> T<span class="number">2</span>&gt;</span><br><span class="line">inline <span class="keyword">void</span> construct(T<span class="number">1</span>* p, const T<span class="number">2</span>&amp; <span class="keyword">value</span>) &#123;</span><br><span class="line">  <span class="keyword">new</span> (p) T<span class="number">1</span>(<span class="keyword">value</span>); <span class="comment">// 定位new操作符placement new; 在指针p所指处构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、空间的配置和释放-std-alloc"><a href="#4、空间的配置和释放-std-alloc" class="headerlink" title="4、空间的配置和释放,std::alloc"></a>4、空间的配置和释放,std::alloc</h3><p>对象构造前的空间分配和析构后的空间释放，定义在头文件&lt;stl_alloc.h&gt;中，设计思想主要考虑以下几点：</p><ul><li>向system heap要求空间。</li><li>考虑多线程状态。</li><li>考虑内存不足时的应变措施。</li><li>考虑过多“小额区块”可能造成的内存碎片问题。</li></ul><p><strong>本节不考虑多线程状态的处理</strong>，SGI绕过new()和free(),直接以malloc()和free()完成内存的配置和释放。考虑到<strong>小型区块</strong>可能造成的内存破碎问题，<strong>SGI设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级则视情况采用不同的策略：当配置区块超过128bytes时，便调用第一级配置器，小于128bytes时则采用复杂的内存池memory pool整理方式，而不再调用一级配置器</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/3.png?raw=true" alt="image"></p><p>整个设计究竟是只开放第一级配置器还是同时开放第二级配置器取决于宏__USE_MALLOC是否被定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc; <span class="comment">//令 alloc为第一级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">//alloc为默认空间配置器</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span> </span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//令 alloc 为第二级配置器 </span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></span><br></pre></td></tr></table></figure><p>无论alloc被定义为第一级或者是第二级配置器，SGI还为它包装一个接口如下，使配置器的接口能够符合STL规格：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>SGI STL容器全部是使用这个simple_alloc接口，比如vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt; //默认使用<span class="title">alloc</span>为配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;<span class="comment">//配置器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(...) deta_allocator::deallocate(start,end_of_storage-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、双层级配置器机制"><a href="#5、双层级配置器机制" class="headerlink" title="5、双层级配置器机制"></a>5、双层级配置器机制</h3><p>如上节所述，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级则视情况采用不同的策略：当配置区块超过128bytes时，便调用第一级配置器，小于128bytes时则采用复杂的内存池memory pool整理方式，而不再调用一级配置器。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/4.png?raw=true" alt="image"></p><h4 id="5-1-第一级配置器-malloc-alloc-template"><a href="#5-1-第一级配置器-malloc-alloc-template" class="headerlink" title="5.1 第一级配置器__malloc_alloc_template"></a>5.1 第一级配置器__malloc_alloc_template</h4><p>第一级配置器直接使用malloc(),free(),realloc()等C函数执行实际的内存配置、释放、重配置操作，并实现出<strong>类似C++ new handler机制</strong>（意思是可以要求系统在配置需求无法被满足时，调用一个你所指定的函数，这里之所以说类似是因为SGI没有new operator，不能直接使用对应的handler）。</p><p>它有独特的<strong>out-of-memory</strong>(内存不足)内存处理机制：<br>SGI第一级配置器的allocate()和reallocate()在调用malloc()和realloc()不成功后，在抛出std::bad_alloc异常之前，改调用oom_malloc(),oom_realloc()，这两个函数两种都有内循环，不断调用“内存不足处理例程”以期望获得足够内存满足分配请求。如果没有设定“内存不足处理例程”，则还是会抛出std::bad_alloc异常。</p><h4 id="5-2-第二级配置器-default-alloc-template"><a href="#5-2-第二级配置器-default-alloc-template" class="headerlink" title="5.2 第二级配置器__default_alloc_template"></a>5.2 第二级配置器__default_alloc_template</h4><p>相比第一级配置器，第二级配置器多了一些机制，<strong>避免小额区块造成内存的碎片</strong>。小区块带来的不仅仅是碎片的问题，配置时的额外负担也是一个大问题。因为区块越小，额外负担所占的比例就越大，愈显得浪费（额外负担是指动态分配内存块的时候，位于其头部的额外信息）。</p><p>第二级配置器的思想主要包括以下两点：</p><ul><li>如果要分配的区块大于128bytes，则移交给第一级配置器处理。</li><li>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置）：每次配置一大块内存，并维护对应的自由链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</li></ul><h5 id="5-2-1-free-list的实现"><a href="#5-2-1-free-list的实现" class="headerlink" title="5.2.1 free_list的实现"></a>5.2.1 free_list的实现</h5><p>在第二级配置器中，<strong>小额区块内存需求大小都被上调至8的倍数</strong>，比如需要分配的大小是30bytes，就自动调整为32bytes。系统中总共维护16个free-lists，各自管理大小为8,16，…，128bytes的小额区块。</p><p>为了维护链表，需要额外的指针，为了避免造成另外一种额外的负担，这里采用了一种技术：用union表示链表节点结构：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123; //实现头节点和每个链表节点的复用</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span> /<span class="regexp">/指向下一个节点</span></span><br><span class="line"><span class="regexp">      char client_data[1]; /</span><span class="regexp">/值表示所对应的每个链中的块的大小</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h5 id="5-2-2-default-alloc-template的allocate"><a href="#5-2-2-default-alloc-template的allocate" class="headerlink" title="5.2.2 __default_alloc_template的allocate()"></a>5.2.2 __default_alloc_template的allocate()</h5><p>身为一个配置器，__default_alloc_template拥有配置器的标准接口函数allocate(),此函数首先判断区块大小，如果要分配的区块大于128bytes，就调用第一级配置器。小于128bytes就检查对应free-list，如果free-list之内有可用的区块就就直接从free-list中取用，负责调用refill()为free list重新填充空间,refill()函数将下节介绍。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/6.png?raw=true" alt="image"></p><h5 id="5-2-2-default-alloc-template的deallocate"><a href="#5-2-2-default-alloc-template的deallocate" class="headerlink" title="5.2.2 __default_alloc_template的deallocate()"></a>5.2.2 __default_alloc_template的deallocate()</h5><p>身为一个配置器，__default_alloc_template也拥有析构接口deallocate()，函数判断如果需要回收的区块大于128bytes，则调用第一级配置器的deallocate()。<br>如否则找到对应的free -list，将区块回收，<strong>注意是将区块放入free-list的头部</strong>。</p><h3 id="6、refill-函数的处理机制"><a href="#6、refill-函数的处理机制" class="headerlink" title="6、refill()函数的处理机制"></a>6、refill()函数的处理机制</h3><p><strong>前面提到，如果free-list中没有可用的区块，就通过refill为对应的free-list 重新填充空间。此时refill进行了怎样的操作呢</strong>？</p><p>默认操作是通过<strong>chunk_alloc</strong>从内存池中取得20个新的节点添加到free-list链表中，而如果内存池中的内存不够用，这时候能分多少就分多少节点，返回的相应的节点数。再万一内存池<strong>一个节点都提供不了</strong>，就给内存池新增空间，如果失败，再抛出bad_alloc异常。</p><h4 id="6-1-chunk-alloc——从内存池中取空间供free-list使用"><a href="#6-1-chunk-alloc——从内存池中取空间供free-list使用" class="headerlink" title="6.1 chunk_alloc——从内存池中取空间供free list使用"></a>6.1 chunk_alloc——从内存池中取空间供free list使用</h4><p>通过<strong>chunk_alloc()</strong>，从内存池中分配空间给free-list。<strong>chunk_alloc()</strong>的流程总结如下：</p><ul><li>(1) 内存池剩余空间完全满足20个区块的需求量，则直接取出对应大小的空间（其中1个返回，剩下部分放入free-list）。</li><li>(2) 内存池剩余空间不能完全满足20个区块的需求量，但是足够供应一个及一个以上的区块，则取出能够满足条件的区块个数的空间。</li><li>(3) 内存池剩余空间不能满足一个区块的大小，则:</li><li><ul><li>首先判断内存池中是否有残余零头内存空间，如果有则进行回收，将其编入free list。然后向heap申请空间，补充内存池。</li></ul></li><li>heap空间满足，空间分配成功(分配的个数为需求的2倍再加一个附加量，然后一半留给内存池，剩下的除去请求的的那部分后放入free-list)。</li><li>heap空间不足，malloc()调用失败。则<br>搜寻适当的free list（适当的是指：<strong>尚有未用区块，并且区块足够大</strong>），调整以进行释放，将其编入内存池。然后递归调用chunk_alloc函数从内存池取空间供free list。<br>搜寻free list释放空间也未能解决问题，这时候调用第一级配置器，利用out-of-memory机制尝试解决内存不足问题。如果可以就成功，否则抛出bad_alloc异常。</li></ul><p><strong>如果有需求的话，内存池中会不断的通过malloc申请新的内存，最后内存池所拥有的内存也会越来越大，当然最后进程结束的时候，这些内存都会由操作系统收回。</strong></p><h3 id="7、内存基本处理工具"><a href="#7、内存基本处理工具" class="headerlink" title="7、内存基本处理工具"></a>7、内存基本处理工具</h3><p>处理construct()和destroy(),另外还有三个函数作用于未初始化空间上，分别为uninitialized_copy()、uninitialized_fill()、uninitialized_copy_n()，此处不再介绍。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/5.png?raw=true" alt="image"></p><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>学完空间配置器的相关知识，有必要总结一下：</p><ul><li>constructor: 由new placement操作符实现。</li><li>destroy: 进行特化，利用value_type和type_trait<t>确定析构函数是否有效，从而决定是否利用指针调用析构函数。</t></li><li>alloc:双层配置器，第一级配置器采用malloc+类似new handle实现，第二级配置器采用free-list处理小额区块+块为8的整数倍+memory pool+一级配置器实现。</li><li>dealloc：大于128bytes用free()+否则将空间放到free-list的首部。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> STL源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.字典序</title>
      <link href="/2019/03/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E5%AD%97%E5%85%B8%E5%BA%8F/"/>
      <url>/2019/03/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。<br>对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.<br>对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…<br><a id="more"></a></p><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/6c9d8d2e426c4c58bbadfdf67d591696?tpId=85&amp;&amp;tqId=29877&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6c9d8d2e426c4c58bbadfdf67d591696?tpId=85&amp;&amp;tqId=29877&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。<br>对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.<br>对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>输入仅包含两个整数n和m。<br>数据范围:<br>对于20%的数据, 1 &lt;= m &lt;= n &lt;= 5 ;<br>对于80%的数据, 1 &lt;= m &lt;= n &lt;= 10^7 ;<br>对于100%的数据, 1 &lt;= m &lt;= n &lt;= 10^18.</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>输出仅包括一行, 即所求排列中的第m个数字.</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">11 </span><span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>参考链接：<a href="https://www.nowcoder.com/questionTerminal/fc05f68c5f47438db54c6923ef23cf4a。" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/fc05f68c5f47438db54c6923ef23cf4a。</a>   </p><p>在具备字典树相关知识的基础上，不难想象如下字典树：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">10</span></span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">11</span></span><br><span class="line"><span class="number">1</span>--&gt;...</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">19</span></span><br><span class="line"><span class="number">2</span>--&gt;<span class="number">20</span></span><br><span class="line"><span class="number">2</span>--&gt;<span class="number">21</span></span><br><span class="line"><span class="number">2</span>--&gt;....</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">100</span></span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">101</span></span><br><span class="line"><span class="number">10</span>--&gt;.....</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">109</span></span><br></pre></td></tr></table></figure></p><p>由上图可知，需要计算每个节点所对应的子节点数，节点数就是上级节点<em>10，可知总的节点数= 1 + （1 </em> 10） + （1 <em> 10 </em> 10） + （1 <em> 10  </em> 10 * 10） +……，需要注意的是，节点的值必须小于等于n，所以大于n的值是必须去掉的。</p><p>具体求解过程如下: </p><ul><li>（1）记所求的第m个数为value=1，从start=value查找，end=value+1最为边界，m等于0时结束，value即为所求值。</li><li>（2）求start的子节点中值在n以内的子节点个数，记为count。</li><li>（3）比较count和m的大小：<blockquote><ul><li>若count&gt;m,则所求值在value的子节点中，value=value*10,m–；   </li><li>若count&lt;=m,则所求的值不在value的子节点中，value=value+1,m=m-count;</li><li>回到第一步继续求值</li></ul></blockquote></li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    long m,n,start,<span class="keyword">end</span>,<span class="keyword">value</span>=<span class="number">1</span>,<span class="built_in">count</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    m--;//默认把当前点算入进来</span><br><span class="line">    <span class="keyword">while</span>(m<span class="comment">!=0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        start=<span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">end</span>=<span class="keyword">value</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">count</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=n)//求出当前<span class="keyword">value</span>的子树数</span><br><span class="line">        &#123;</span><br><span class="line">            //求出当前一层，能算入的子树数目</span><br><span class="line">            <span class="built_in">count</span>+=((n+<span class="number">1</span>)&gt;<span class="keyword">end</span>?<span class="keyword">end</span>:(n+<span class="number">1</span>))-start;</span><br><span class="line">            start=start*<span class="number">10</span>;//进入下一层</span><br><span class="line">            <span class="keyword">end</span>=<span class="keyword">end</span>*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">count</span>&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            //当前<span class="keyword">value</span>的子树数目大于m，所求节点在<span class="keyword">value</span>的子树中</span><br><span class="line">            <span class="keyword">value</span>=<span class="keyword">value</span>*<span class="number">10</span>;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            //当前<span class="keyword">value</span>的子树数目小于m,进入<span class="keyword">value</span>+<span class="number">1</span>继续寻找其子树</span><br><span class="line">            m=m-<span class="built_in">count</span>;</span><br><span class="line">            <span class="keyword">value</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="keyword">value</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><ul><li>代码不长，除了具备相应知识外，能静下心来慢慢理清思路并实现也是一种能力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 字典树 </tag>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.异或</title>
      <link href="/2019/03/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%BC%82%E6%88%96/"/>
      <url>/2019/03/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<p>给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。<br><a id="more"></a></p><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/fc05f68c5f47438db54c6923ef23cf4a?tpId=85&amp;&amp;tqId=29876&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fc05f68c5f47438db54c6923ef23cf4a?tpId=85&amp;&amp;tqId=29876&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>第一行包含两个整数n,m.<br>第二行给出n个整数A1，A2，…，An。<br>数据范围:<br>对于30%的数据，1 &lt;= n, m &lt;= 1000<br>对于100%的数据，1 &lt;= n, m, Ai &lt;= 10^5</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>输出仅包括一行，即所求的答案</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">10</span>  </span><br><span class="line"><span class="symbol">6 </span><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>参考链接：<a href="https://blog.csdn.net/qq_30507287/article/details/68947863。" target="_blank" rel="noopener">https://blog.csdn.net/qq_30507287/article/details/68947863。</a></p><p>考虑用字典树来解决该题，用示例中6、5、10来构建一颗如下字典树(虚线表示不用)：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">root--&gt;<span class="number">0</span></span><br><span class="line">root--&gt;<span class="number">1</span></span><br><span class="line"><span class="number">0</span>-.-&gt;<span class="number">00</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span>--&gt;<span class="number">01</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">01</span>--&gt;<span class="number">010</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">01</span>--&gt;<span class="number">011</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">011</span>--&gt;<span class="number">0110</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">011</span>-.-&gt;<span class="number">0111</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">010</span>-.-&gt;<span class="number">0100</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">010</span>--&gt;<span class="number">0101</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>--&gt;<span class="number">10</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span>-.-&gt;<span class="number">11</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">10</span>-.-&gt;<span class="number">100</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">10</span>--&gt;<span class="number">101</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">101</span>--&gt;<span class="number">1000</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">101</span>-.-&gt;<span class="number">1001</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>从已有的数据中选一个数记为a，遍历该字典树（二叉树）,求所有与a异或大于m的数的个数，分情况讨论：</p><ul><li>如果a的当前位为0，m的当前位为0，那么明显父节点的右子树的所有数与a异或都大于m；但左子树不能确定，需要继续查询。</li><li>如果a的当前位为1，m的当前位为0，那么明显父节点的左子树的所有数与a异或都大于m；但右子树不能确定，需要继续查询。</li><li>如果a的当前位为0，m的当前位为1，那么明显父节点的左子树中的数和a异或一定小于m，查询结束；右子树的数不能确定，需要继续查询。</li><li>如果a的当前位为1，m的当前位为1，那么明显父节点的右子树中的数和a异或一定小于m，查询结束；左子树的数不能确定，需要继续查询。</li></ul><p>具体求解过程如下: </p><ul><li>（1）依次读取n,m,将n个数依次放入数组并且构建对应的字典树。</li><li>（2）获取获取数组中的数，查询字典树，计算与其异或值大于m的数的个数。</li><li>（3）得到的count除2，因为如果a\^b大于m,那么b\^a也会大于m。</li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">*@bref:暴力求解，好像是可以通过<span class="number">80</span><span class="comment">%，果然暴力还是不行</span></span><br><span class="line">*</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,<span class="built_in">i</span>,<span class="built_in">j</span>,result,count=<span class="number">0</span>,*value;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    value=new int[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;value[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n<span class="number">-1</span>;<span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="built_in">i</span>+<span class="number">1</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            result=value[<span class="built_in">i</span>]^value[<span class="built_in">j</span>];</span><br><span class="line">            <span class="keyword">if</span>(result&gt;m) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>能通过的解法：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @bref:参考了大神们的思路，服气</span></span><br><span class="line"><span class="comment">*       了解字典树之后，理解这个题的解法就好多了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义字典树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trieTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> num;</span><br><span class="line">      trieTree *son[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      trieTree(<span class="keyword">int</span> num) </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;num=num;</span><br><span class="line">          son[<span class="number">0</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">          son[<span class="number">1</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a,trieTree *current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入每一个节点，17位所能表示的最大值位131071</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        foo=(a&gt;&gt;i)&amp;<span class="number">1</span>;<span class="comment">//获取对应的位</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[foo] == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            current-&gt;son[foo]=<span class="keyword">new</span> trieTree(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        current=current-&gt;son[foo];</span><br><span class="line">        current-&gt;num++;<span class="comment">//记数加1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询结果</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(trieTree *root,<span class="keyword">int</span> a,<span class="keyword">int</span> m,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    trieTree *current=root; </span><br><span class="line">    <span class="keyword">int</span> aDigit=(a&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mDigit=(m&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(aDigit==<span class="number">0</span> &amp;&amp; mDigit==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=(current-&gt;son[<span class="number">1</span>]==<span class="literal">nullptr</span>? <span class="number">0</span>:current-&gt;son[<span class="number">1</span>]-&gt;num);</span><br><span class="line">        <span class="keyword">int</span> q=query(current-&gt;son[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> p+q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">1</span> &amp;&amp; mDigit==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=(current-&gt;son[<span class="number">0</span>]==<span class="literal">nullptr</span>? <span class="number">0</span>:current-&gt;son[<span class="number">0</span>]-&gt;num);</span><br><span class="line">        <span class="keyword">int</span> p=query(current-&gt;son[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> p+q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">0</span> &amp;&amp; mDigit==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[<span class="number">1</span>]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(current-&gt;son[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aDigit==<span class="number">1</span> &amp;&amp; mDigit==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;son[<span class="number">0</span>]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(current-&gt;son[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,*data;</span><br><span class="line">    <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function">trieTree <span class="title">root</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    data=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">        insert(data[i],&amp;root);<span class="comment">//将所有的数</span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count+=query(&amp;root,data[i],m,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><p>这种题目的第一思路是暴力求解，虽然很大概率是不行的，但不妨一试，能想出合理高效的求解方案不是每一个人都能做到的，问题的抽象能力、联想能力往往是解题的关键，常备知识，遇到问题才能直击痛点，庖丁解牛。<br><strong>在写这个题的时候，我自己实现了代码，但是感觉完全没问题，然后提交之后一直只通过80%，我后来花了将近两天的时间近乎一直在想这个题，最后突然灵光发现是用来存结果的count值是int型，而实际结果要大于int型所能表示的范围。真的服气…….我发誓以后存结果的数一定用long。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 字典树 </tag>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.保卫方案</title>
      <link href="/2019/03/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E4%BF%9D%E5%8D%AB%E6%96%B9%E6%A1%88/"/>
      <url>/2019/03/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E4%BF%9D%E5%8D%AB%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。<br><a id="more"></a></p><h2 id="保卫方案"><a href="#保卫方案" class="headerlink" title="保卫方案"></a>保卫方案</h2><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/e1967ae812ea42e7a3ce57ee1f83b686?tpId=85&amp;tqId=29878&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/e1967ae812ea42e7a3ce57ee1f83b686?tpId=85&amp;tqId=29878&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p></blockquote><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。</p><h3 id="2-输入描述"><a href="#2-输入描述" class="headerlink" title="2.输入描述"></a>2.输入描述</h3><blockquote><p>输入中有多组测试数据，每一组测试数据的第一行为一个整数n(3&lt;=n&lt;=10^6),为首都周围的小山数量，第二行为n个整数，依次表示为小山的高度h（1&lt;=h&lt;=10^9）.</p></blockquote><h3 id="3-输出描述"><a href="#3-输出描述" class="headerlink" title="3.输出描述"></a>3.输出描述</h3><blockquote><p>对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。</p></blockquote><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h3><p>输入<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p><h3 id="5-解题思路"><a href="#5-解题思路" class="headerlink" title="5.解题思路"></a>5.解题思路</h3><p>这个题想了好长时间，但是一直没想出来怎么做，参考了大神的解体思路后，总算想清楚了，原链接如下：<a href="http://www.cnblogs.com/mengmz/p/7263915.html。" target="_blank" rel="noopener">http://www.cnblogs.com/mengmz/p/7263915.html。</a></p><p>分析题目可知，对于山峰a,如果能在它的左边和右边分别找到最近且比它大的b和c，那么b能看到a，a能看到c，即整体计数对应加2。那么题目可以分为如下两种情况进行讨论：  </p><ul><li>对于数组中无重复数字出现的情况，在构成环的全部元素当中，最大值和次大值只有一边存在比它大的数，但能彼此看到，故计数值加1。除了这两个元素外，剩下的n-2个元素都能在左边和右边分别找到比它大的数，故计数值加（n-1）<em>2。即总的结果为：1+（n-2）</em>2。      </li><li>对于有重复数字出现的情况，假设有一组序列为a,a,b,b,b,c,c且a&gt;b,c&gt;b。a,b,c分别出现的次数为2,3,2，b各元素能互相看见，故b自身能构成的组合数为：c(3,2)=3<em>(3-2)/2。同时所有的b都能看到最后一个a和第一个c，所以计数值加3+3。如果用N1,N2,N3分别表示a,b,c出现的话，则总的结果为：c(N2,2)+2</em>N2;</li></ul><p>分析完两种情况后，现在我们需要求出每一个数和两边大于这个数的情况，采用单调栈来解决，具体求解过程如下: </p><ul><li>（1）读取所有数据，放入数组V，计数值count=0。</li><li>（2）新建数组P，遍历数组V，将V中的元素消除重复后放入P中，并记录下每个元素重复的次数。同时找出最大的元素max和其在P中下标max_i。</li><li>（3）创建堆栈S，然后从max_i开始遍历所有P中元素。进行如下操作：<blockquote><ul><li>若堆栈为空， 将P[i]直接压入堆栈；   </li><li>若堆栈为非空，将P[i]与栈顶元素进行比较，如果大于栈顶元素，count加上栈顶元素的组合数（重复数N,组合数为c(N,2)+N,注意此时只考虑栈顶元素和P[i]的组合数），然后弹出栈顶元素，若栈不为空，则弹出的数和栈顶数也有组合数，count加弹出数的重复数N，执行本步骤一直弹出直到P[i]小于栈顶元素；</li><li>若等于栈顶元素，栈顶元素的重复数+P[i]的重复数，继续执行；</li><li>若小于栈顶元素，直接压入；</li></ul></blockquote></li><li>(4)上个步骤结束后，得到一个递减的堆栈。依次弹出栈顶元素到temp，直到堆栈为空，count加上其组合数目,这个时候要考虑以下情况：<blockquote><ul><li>堆栈中剩余元素个数多于1,则temp的组合数为c(N,2)+N*2。   </li><li>堆栈中的剩余元素个数为1，若剩余元素的重复次数n大于1，则temp的组合数为c(N,2)+N*2（如4,4,3,3,3序列，所有的3能看到第一个4和最后一个4）；若剩余的重复次数为1，则temp的组合数为c(N,2)+N（如4,3,3,3序列）</li><li>堆栈中的剩余元素个数为0，此时temp为最大值，组合数跟其重复次数N有关,为c(N,2)；   </li></ul></blockquote></li></ul><h3 id="6-实现代码"><a href="#6-实现代码" class="headerlink" title="6.实现代码"></a>6.实现代码</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用结构体来保存每个山峰的高度，和重复的次数</span></span><br><span class="line">struct node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    long <span class="built_in">count</span>;</span><br><span class="line">    node(int v,int c=<span class="number">1</span>): val(v),<span class="built_in">count</span>(c)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,value,i,<span class="built_in">max</span>,max_i;</span><br><span class="line">    long <span class="built_in">count</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; mountin(n);</span><br><span class="line">    vector&lt;node&gt; mnode;<span class="comment">//去重和计数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;mountin[i];<span class="comment">//依次获取每个山峰的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node temp(mountin[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">max</span>=mountin[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//去重和寻找最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mountin[i]==temp.val)<span class="comment">//若重复</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">count</span>++;<span class="comment">//计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;</span><br><span class="line">            mnode.push_back(temp);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span>&lt;temp.val)<span class="comment">//获取最大峰值和对应下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span>=temp.val;</span><br><span class="line">                max_i=mnode.<span class="built_in">size</span>()-<span class="number">1</span>;<span class="comment">//注意，这里获取的去重后的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp.val=mountin[i];</span><br><span class="line">            temp.<span class="built_in">count</span>=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mnode.push_back(temp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>&lt;temp.val)<span class="comment">//获取最大峰值和对应下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">max</span>=temp.val;</span><br><span class="line">        max_i=mnode.<span class="built_in">size</span>()-<span class="number">1</span>;<span class="comment">//注意，这里获取的去重后的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stack&lt;node&gt; s;</span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=max_i;n&lt;mnode.<span class="built_in">size</span>();++n,i=(i+<span class="number">1</span>)%mnode.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; mnode[i].val&gt;s.top().val)</span><br><span class="line">        &#123;   <span class="comment">//数组元素大于栈顶元素的情况</span></span><br><span class="line">            temp.val=s.top().val;</span><br><span class="line">            temp.<span class="built_in">count</span>=s.top().<span class="built_in">count</span>;</span><br><span class="line">            <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+temp.<span class="built_in">count</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) <span class="built_in">count</span>+=temp.<span class="built_in">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组元素小于栈顶元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty()||mnode[i].val&lt;s.top().val) s.push(mnode[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//数组元素等于栈顶元素的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.top().<span class="built_in">count</span>+=mnode[i].<span class="built_in">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对最后的递减栈进行求解</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp.val=s.top().val;</span><br><span class="line">        temp.<span class="built_in">count</span>=s.top().<span class="built_in">count</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>)  <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>*temp.<span class="built_in">count</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//堆栈中还剩一个值的情况</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(s.top().<span class="built_in">count</span>==<span class="number">1</span>) <span class="comment">//如4，3，3，3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+temp.<span class="built_in">count</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如4,4，3，3，3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">count</span>+=temp.<span class="built_in">count</span>*(temp.<span class="built_in">count</span>-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>*temp.<span class="built_in">count</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">count</span>&lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-思考与分析"><a href="#6-思考与分析" class="headerlink" title="6.思考与分析"></a>6.思考与分析</h3><ul><li>解题的时候还是需要学会将大问题化解之后进行分析，分情况不断讨论，然后也就能分而解之，水到渠成。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS安全通信机制及SSL握手过程</title>
      <link href="/2018/12/28/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%8F%8ASSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/12/28/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%8F%8ASSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>HTTP是一种超文本传输协议，它是无状态的、简单快速的、基于 TCP 的可靠传输协议。 HTTP使用明文传输，由此造成了很大的安全隐患。在网络传输过程中，只要数据包被人截获，截获人可以直接解析出数据包内的信息，容易导致信息泄露。</p><p>HTTPS常被定义为为HTTP over SSL，超文本传输安全协议。HTTPS协议在HTTP和传输层TCP之间增加了SSL/TSL层，SSL/TSL层能够提供密钥协商、数据加解密的功能，数据在网络以密文形式传输，从而保证数据安全。本文将一步步讲解https的安全通信原理。</p><a id="more"></a><h3 id="1、http为什么不安全？"><a href="#1、http为什么不安全？" class="headerlink" title="1、http为什么不安全？"></a>1、http为什么不安全？</h3><p><strong>http协议属于明文传输协议</strong>，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题。</p><p>可以把http通信比喻成寄送信件一样，A给B寄信，信件在寄送过程中，会经过很多的邮递员之手，他们可以拆开信读取里面的内容。A的信件里面的任何内容（包括各类账号和密码）都会被轻易窃取。除此之外，邮递员们还可以伪造或者修改信件的内容，导致B接收到的信件内容是假的。</p><p>比如常见的，在http通信过程中，“中间人”将广告链接嵌入到服务器发给用户的http报文里，导致用户界面出现很多不良链接； 或者是修改用户的请求头URL，导致用户的请求被劫持到另外一个网站，用户的请求永远到不了真正的服务器。这些都会导致用户得不到正确的服务，甚至是损失惨重。</p><h3 id="2、https如何保证安全？"><a href="#2、https如何保证安全？" class="headerlink" title="2、https如何保证安全？"></a>2、https如何保证安全？</h3><p>要解决http带来的问题，就要引入<strong>加密</strong>以及<strong>身份验证机制</strong>。</p><h4 id="2-1-引入对称加密算法"><a href="#2-1-引入对称加密算法" class="headerlink" title="2.1 引入对称加密算法"></a>2.1 引入对称加密算法</h4><p>如果Server给Client的消息是密文的，只有服务器和客户端才能读懂，就可以保证数据的保密性。同时，在交换数据之前，验证一下对方的合法身份，就可以保证通信双方的安全。那么，问题来了，服务器把数据加密后，客户端如何读懂这些数据呢？</p><p>这时服务器必须要把加密的密钥（<strong>对称密钥</strong>，后面会详细说明）告诉客户端，客户端才能利用对称密钥解开密文的内容。但是，服务器如果将这个对称密钥以明文的方式给客户端，还是会被中间人截获，中间人也会知道对称密钥，依然无法保证通信的保密性。但是，如果服务器以密文的方式将对称密钥发给客户端，客户端又如何解开这个密文，得到其中的对称密钥呢？</p><h4 id="2-2-引入非对称加密算法"><a href="#2-2-引入非对称加密算法" class="headerlink" title="2.2 引入非对称加密算法"></a>2.2 引入非对称加密算法</h4><p>这时，我们引入了<strong>非对称加解密的概</strong>念。在非对称加解密算法里，公钥加密的数据，有且只有唯一的私钥才能够解密，所以<strong>服务器只要把公钥发给客户端，客户端就可以用这个公钥来加密进行数据传输的对称密钥。客户端利用公钥将对称密钥发给服务器时，即使中间人截取了信息，也无法解密，因为私钥只部署在服务器，其他任何人都没有私钥，因此，只有服务器才能够解密。服务器拿到客户端的信息并用私钥解密之后，就可以拿到加解密数据用的对称密钥，通过这个对称密钥来进行后续通信的数据加解密</strong>。除此之外，非对称加密可以很好的管理对称密钥，保证每次数据加密的对称密钥都是不相同的，这样子的话，即使客户端病毒拉取到通信缓存信息，也无法窃取正常通信内容。</p><p>上述通信过程，可以画成以下交互图：</p><p><img src="https://pic3.zhimg.com/5c09960e4b42cc41cc058cd7d7b27d8d_b.jpg" alt></p><p>但是这样似乎还不够，如果通信过程中，在三次握手或者客户端发起HTTP请求过程中，客户端的请求被<strong>中间人劫持</strong>，那么中间人就可以伪装成“假冒客户端”和服务器通信；中间人又可以伪装成“假冒服务器”和客户端通信。接下来，我们详细阐述中间人获取对称密钥的过程。</p><h4 id="2-3-中间人劫持"><a href="#2-3-中间人劫持" class="headerlink" title="2.3 中间人劫持"></a>2.3 中间人劫持</h4><p>中间人在收到服务器发送给客户端的公钥（这里是“正确的公钥”）后，并没有发给客户端，而是中间人将自己的公钥（这里中间人也会有一对公钥和私钥，这里称呼为“伪造公钥”）发给客户端。之后，客户端把对称密钥用这个“伪造公钥”加密后，发送过程中经过了中间人，中间人就可以用自己的私钥解密数据并拿到对称密钥，此时中间人再把对称密钥用“正确的公钥”加密发回给服务器。此时，客户端、中间人、服务器都拥有了一样的对称密钥，后续客户端和服务器的所有加密数据，中间人都可以通过对称密钥解密出来。</p><p>中间人获取对称密钥的过程如下：</p><p><img src="https://pic2.zhimg.com/83296008f1e7d679cd8a99a61944fbbb_b.jpg" alt></p><h4 id="2-4-引入身份验证机制——数字证书"><a href="#2-4-引入身份验证机制——数字证书" class="headerlink" title="2.4 引入身份验证机制——数字证书"></a>2.4 引入身份验证机制——数字证书</h4><p>为了解决此问题，我们引入了<strong>数字证书</strong>的概念。服务器首先生成公私钥，将公钥提供给<strong>相关机构</strong>（CA），CA将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人发送的伪造证书，不能够获得CA的认证，此时，客户端和服务器就知道通信被劫持了。加入了CA数字签名认证的SSL会话过程如下所示：</p><p><img src="https://pic4.zhimg.com/0d635fd33e0c9a8da972e14c83ec094b_b.jpg" alt></p><p>所以综合以上三点：非对称加密算法（公钥和私钥）交换对称密钥+数字证书验证身份（验证公钥是否是伪造的）+利用对称密钥加解密后续传输的数据=安全</p><p><img src="https://pic3.zhimg.com/bbb86e2b373fcf8c61dc7b1b09b80cf7_b.jpg" alt></p><h3 id="3、https协议简介"><a href="#3、https协议简介" class="headerlink" title="3、https协议简介"></a>3、https协议简介</h3><p>接下来将会简要介绍https安全通信过程的相关技术，为什么是简单地介绍https协议呢？因为相关的知识太多了。</p><h4 id="3-1-对称加密算法"><a href="#3-1-对称加密算法" class="headerlink" title="3.1 对称加密算法"></a>3.1 对称加密算法</h4><p>对称加密是指：加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p><h5 id="3-1-1-对称加密又分为两种模式：流加密和分组加密"><a href="#3-1-1-对称加密又分为两种模式：流加密和分组加密" class="headerlink" title="3.1.1 对称加密又分为两种模式：流加密和分组加密"></a>3.1.1 对称加密又分为两种模式：流加密和分组加密</h5><p>流加密是将消息作为字节流对待，并且使用数学函数分别作用在每一个字节位上。使用流加密时，每加密一次，相同的明文位会转换成不同的密文位。流加密使用了密钥流生成器，它生成的字节流与明文字节流进行异或，从而生成密文。</p><p>分组加密是将消息划分为若干个分组，这些分组随后会通过数学函数进行处理，每次一个分组。假设使用64位的分组密码，此时如果消息长度为640位，就会被划分成10个64位的分组（如果最后一个分组长度不到64，则用0补齐之后加到64位），每个分组都用一系列数学公式进行处理，最后得到10个加密文本分组。然后，将这条密文消息发送给对端。对端必须拥有相同的分组密码，以相反的顺序对10个密文分组使用前面的算法解密，最终得到明文消息。<strong>比较常用的分组加密算法有DES、3DES、AES</strong>。其中DES是比较老的加密算法，现在已经被证明不安全。而3DES是一个过渡的加密算法，相当于在DES基础上进行三重运算来提高安全性，但其本质上还是和DES算法一致。而AES是DES算法的替代算法，<strong>AES是现在最安全的对称加密算法之一</strong>。</p><h5 id="3-1-2-对称加密算法的优缺点："><a href="#3-1-2-对称加密算法的优缺点：" class="headerlink" title="3.1.2 对称加密算法的优缺点："></a>3.1.2 对称加密算法的优缺点：</h5><p>优点：计算量小、加密速度快、加密效率高。<br>缺点：</p><ul><li>（1）交易双方都使用同样密钥，安全性得不到保证；</li><li>（2）每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。</li></ul><h4 id="3-2-非对称加密算法"><a href="#3-2-非对称加密算法" class="headerlink" title="3.2 非对称加密算法"></a>3.2 非对称加密算法</h4><p>在非对称密钥交换算法出现以前，对称加密的最主要缺陷就是不知道如何在通信双方之间传输对称密钥，而又不让中间人窃取。非对称密钥交换算法诞生之后，专门针对对称密钥传输做加解密，使得对称密钥的交互传输变得非常安全了。</p><p>非对称密钥交换算法本身非常复杂，密钥交换过程涉及到随机数生成，模指数运算，空白补齐，加密，签名等等一系列极其复杂的过程。<strong>常见的密钥交换算法有RSA，ECDHE，DH，DHE等算法</strong>。其中，最经典也是最常用的是RSA算法。</p><p>RSA算法安全性很高，最重要的是，算法实现非常简单。缺点就是需要比较大的质数（目前常用的是2048位）来保证安全强度，极其消耗CPU运算资源。<strong>RSA是目前唯一一个既能用于密钥交换又能用于证书签名的算法，RSA 是最经典，同时也是最常用的是非对称加解密算法</strong>。</p><h5 id="3-2-1-非对称加密的缺点"><a href="#3-2-1-非对称加密的缺点" class="headerlink" title="3.2.1 非对称加密的缺点"></a>3.2.1 非对称加密的缺点</h5><p>非对称加密相比对称加密更加安全，但也存在两个致命的缺点：</p><ul><li><p>（1）<strong>CPU计算资源消耗非常大</strong>。一次完全TLS握手，密钥交换时的非对称解密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%。如果后续的应用层数据传输过程也使用非对称加解密，那么CPU性能开销太庞大，服务器是根本无法承受的。赛门特克给出的实验数据显示，加解密同等数量的文件，非对称算法消耗的CPU资源是对称算法的1000倍以上。</p></li><li><p>（2）非对称加密算法对<strong>加密内容的长度有限制</strong>，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。</p></li></ul><p><strong>所以非对称加解密目前只能用来作对称密钥交换或者CA签名，不适合用来做应用层内容传输的加解密。</strong></p><h4 id="3-3-身份认证"><a href="#3-3-身份认证" class="headerlink" title="3.3 身份认证"></a>3.3 身份认证</h4><p><strong>https协议中身份认证的部分是由CA数字证书完成的</strong>，证书由公钥、证书主体、数字签名等内容组成。在客户端发起SSL请求后，服务端会将数字证书发给客户端，客户端会对证书进行验证（验证这张证书是否是伪造的？也就是公钥是否是伪造的），如果证书不是伪造的，客户端就获取用于对称密钥交换的非对称密钥（获取公钥）。</p><h5 id="3-3-1-数字证书的作用"><a href="#3-3-1-数字证书的作用" class="headerlink" title="3.3.1 数字证书的作用"></a>3.3.1 数字证书的作用</h5><p>数字证书有三个作用：</p><ul><li>（1）身份授权。确保浏览器访问的网站是经过CA验证的可信任的网站。</li><li>（2）分发公钥。每个数字证书都包含了注册者生成的公钥（验证确保是合法的，非伪造的公钥）。在SSL握手时会通过certificate消息传输给客户端。</li><li>（3）验证证书合法性。客户端接收到数字证书后，会对证书合法性进行验证。只有验证通过后的证书，才能够进行后续通信过程。</li></ul><h5 id="3-3-2-如何申请一个受信任的CA数字证书"><a href="#3-3-2-如何申请一个受信任的CA数字证书" class="headerlink" title="3.3.2 如何申请一个受信任的CA数字证书"></a>3.3.2 如何申请一个受信任的CA数字证书</h5><p>申请一个受信任的CA数字证书通常有如下流程：</p><ul><li>（1）公司的服务器生成公钥和私钥，并发起生成CA数字证书请求。</li><li>（2）RA（证书注册及审核机构）检查实体的合法性，即检查在注册系统里面是否注册过的正规公司。</li><li>（3）CA证书签发机构签发证书，发送给申请者实体。</li><li>（4）证书更新到repository（负责数字证书及CRL内容存储和分发），实体终端后续从repository更新证书，查询证书状态等。</li></ul><h4 id="3-4-数字证书验证"><a href="#3-4-数字证书验证" class="headerlink" title="3.4 数字证书验证"></a>3.4 数字证书验证</h4><p>申请者拿到CA的证书并部署在网站服务器端，那浏览器发起握手并接收到证书后，如何确认这个证书就是CA签发的呢？怎样避免第三方伪造这个证书？</p><p>答案就是数字签名，数字签名是证书的防伪标签，目前使用最广泛的SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）。<strong>数字签名的制作和验证过程如下</strong>：</p><ul><li>（1）数字签名的签发。首先是使用哈希函数对待签名内容进行安全哈希，生成消息摘要，然后使用CA自己的私钥对消息摘要进行加密。</li><li>（2）数字签名的校验。使用CA的公钥解密签名，然后使用相同的签名函数对签名证书内容进行签名，并和服务端数字签名里的签名内容进行比较，如果相同就认为校验成功。</li></ul><p><img src="https://pic2.zhimg.com/e464309875c608aefd964d905345a0a0_b.jpg" alt></p><p>需要注意的是：</p><ul><li>（1）数字签名签发和校验使用的非对称密钥是CA自己的公钥和私钥，跟证书申请者（提交证书申请的公司实体）提交的公钥没有任何关系。</li><li>（2）数字签名的签发过程跟公钥加密的过程刚好相反，即是用私钥加密，公钥解密。（一对公钥和私钥，公钥加密的内容只有私钥能够解密；反过来，私钥加密的内容，也就有公钥才能够解密）</li><li>（3）现在大的CA都会有证书链，证书链的好处：首先是安全，保持CA的私钥离线使用。第二个好处是方便部署和撤销。这里为啥要撤销呢？因为，如果CA数字证书出现问题（被篡改或者污染），只需要撤销相应级别的证书，根证书依然是安全的。</li><li>（4）根CA证书都是自签名，即用自己的公钥和私钥完成了签名的制作和验证。而证书链上的证书签名都是使用上一级证书的非对称密钥进行签名和验证的。</li><li>（5）怎样获取根CA和多级CA的密钥对？还有，既然是自签名和自认证，那么它们是否安全可信？这里的答案是：当然可信，因为这些厂商跟浏览器和操作系统都有合作，它们的根公钥都默认装到了浏览器或者操作系统环境里。</li></ul><h4 id="3-5-数据完整性验证"><a href="#3-5-数据完整性验证" class="headerlink" title="3.5 数据完整性验证"></a>3.5 数据完整性验证</h4><p>数据传输过程中的完整性使用MAC算法来保证。为了避免网络中传输的数据被非法篡改，或者数据比特被污染，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性（由于MD5在实际应用中存在冲突的可能性比较大，所以尽量别采用MD5来验证内容一致性）。</p><p>MAC算法是在密钥参与下的数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。发送者在密钥的作用下，利用MAC算法计算出消息的MAC值，并将其添加在需要发送的消息之后，并发送给接收者。接收者利用同样的密钥和MAC算法计算出消息的MAC值，并与接收到的MAC值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改或者污染，接收者将丢弃该报文。</p><p>SHA也不能使用SHA0和SHA1，山东大学的王小云教授在2005年就宣布破解了 SHA-1完整版算法，并获得了业内专家的认可。微软和google都已经宣布16年及17年之后不再支持sha1签名证书。</p><h3 id="4、Https的通信握手过程"><a href="#4、Https的通信握手过程" class="headerlink" title="4、Https的通信握手过程"></a>4、Https的通信握手过程</h3><p>SSL是一个介于HTTP协议与TCP之间的一个可选层，为数据通讯提供安全支持。SSL协议可分为两层：</p><ul><li>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li><li>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ul><p>SSL协议握手以及https的通信过程如下：</p><ul><li>（1）客户端请求建立SSL链接，并向服务端发送一个报文，内容包括TSL协议版本、用于生成对话密钥的随机数1、支持的加密方法、支持的压缩方法，此时是明文传输。</li><li>（2）服务端回复客户端一个报文，内容包括确认使用的加密通信协议版本、用于生成对话密钥的随机数2、确认加密方法、服务器证书（包含非对称加密的公钥）。</li><li>（3）客户端验证证书，如果证书不是可信机构颁布，或证书域名与实际域名不符，或者证书已经过期，就会向访问者显示一个警告，是否继续通信。</li><li>（4）客户端确认证书没有问题，就会取出证书中的服务器公钥，然后生成新的随机数3并通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li><li>（5）服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用上述3个随机数通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li></ul><p>此后的HTTP链接数据传输即通过对称加密方式进行加密传输。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Iptabls </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++实现单例模式</title>
      <link href="/2018/12/11/c++%E5%9F%BA%E7%A1%80/c++%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/11/c++%E5%9F%BA%E7%A1%80/c++%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在所有的设计模式中，单例模式是唯一一个能用较短代码实现的模式，所以其常成为面试的一个考点。《剑指offer》中的第二题中有讲到如何用c#实现单例模式的类，但实际上，我们用的比较多的是c++，c++也肯定会有类似的应用场景，那c++中又该怎样实现呢？<br><a id="more"></a></p><h3 id="1、引入"><a href="#1、引入" class="headerlink" title="1、引入"></a>1、引入</h3><p>加入有这样一个场景：设计一个类，我们只生成该类的一个实例，该怎么实现呢？</p><h3 id="2、设计思想："><a href="#2、设计思想：" class="headerlink" title="2、设计思想："></a>2、设计思想：</h3><ul><li>单例模式的class主要起工具作用，用于提供全局性的操作。其实用全局或者静态变量也能实现类似的功能，但这样的封装性不好。普通的class在不断new的过程中也会显得比较臃肿。</li><li>为了只生成一个实例，我们可以将构造函数声明为private级别，从而阻止用户产生多个实例。同时我们提供一个public static的方法，通过该方法获得这个类唯一 的实例化对象。这就是单例模式基本的一个思想。</li><li>常见的单例模式分为两种：<br>（1） 饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式<br>（2） 懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式</li></ul><h3 id="3、代码实现："><a href="#3、代码实现：" class="headerlink" title="3、代码实现："></a>3、代码实现：</h3><h4 id="3-1-饿汉式实现："><a href="#3-1-饿汉式实现：" class="headerlink" title="3.1 饿汉式实现："></a>3.1 饿汉式实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton instance; <span class="comment">// 单例对象在这里！</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象创建！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">~Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象销毁！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;instance;<span class="comment">//第一次调用时才会调用构建函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance;<span class="comment">//直接生成一个全局性的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton *ct1 = Singleton::getInstance();</span><br><span class="line">Singleton *ct2 = Singleton::getInstance();</span><br><span class="line">Singleton *ct3 = Singleton::getInstance();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-懒汉式实现："><a href="#3-2-懒汉式实现：" class="headerlink" title="3.2 懒汉式实现："></a>3.2 懒汉式实现：</h4><p>饱汉式的单例用法是线程安全的，不需要考虑线程同步，但是懒汉式的情况就不一样了。懒汉式单例模式是在第一次调用getInstance()的时候，才创建实例对象。我们可以直接把对象定义为static，然后放在getInstance()中。第一次进入该函数，就创建实例对象，然后一直到程序结束，释放该对象代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象创建！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">~Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象销毁！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton instance;<span class="comment">//第一次用到时才创建对象</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果我想把对象放在堆上呢？可以这么实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *instance;</span><br><span class="line">  </span><br><span class="line">Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象创建！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">~Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象销毁！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义一个内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nested</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Nested()&#123;&#125;;</span><br><span class="line">~Nested()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 定义一个内部类的静态对象</span></span><br><span class="line">        <span class="comment">// 当该对象销毁时，顺带就释放instance指向的堆区资源</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> != instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">instance = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Nested foo;<span class="comment">//在用户程序中需要使用该object才会触发创建</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-线程安全吗？"><a href="#3-3-线程安全吗？" class="headerlink" title="3.3 线程安全吗？"></a>3.3 线程安全吗？</h4><p>上面这种设计方式在单线程环境下是安全的，没问题，但是如果是多线程呢？在if (nullptr == instance)处会由于线程多个线程可能都得到instance==nullptr,就会创建多个对象，明显不符合要求，为了做到线程安全，需要做双重锁校验DLC，代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *instance;</span><br><span class="line">  </span><br><span class="line">Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象创建！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">~Singleton()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"单例对象销毁！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock();<span class="comment">//确保线程安全</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义一个内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nested</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Nested()&#123;&#125;;</span><br><span class="line">~Nested()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 定义一个内部类的静态对象</span></span><br><span class="line">        <span class="comment">// 当该对象销毁时，顺带就释放instance指向的堆区资源</span></span><br><span class="line">        lock();<span class="comment">//确保线程安全</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> != instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">instance = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Nested foo;<span class="comment">//在用户程序中需要使用该object才会触发创建</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解netfilter的核心原理与实现</title>
      <link href="/2018/12/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3netfilter%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/12/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3netfilter%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文旨在一探Iptables和Netfilter的关系，了解网络包经过网络协议栈的过程，从而对linux的防火墙机制有更深入的认识。<br><a id="more"></a></p><h3 id="1、Iptables和Netfilter的关系"><a href="#1、Iptables和Netfilter的关系" class="headerlink" title="1、Iptables和Netfilter的关系"></a>1、Iptables和Netfilter的关系</h3><p>iptables是用户用来管理和配置防火墙规则的一种策略，但是实际解析规则并按照规则实施产生作用的是Netfilter。</p><p>iptables与协议栈内有包过滤功能的hook交互来完成工作，这些内核hook构成了netfilter框架。每个进入网络系统的包（接收和发送）在经过协议栈的时候都会触发这些hook，程序可以通过<strong>注册hook函数</strong>的方式在一些关键路径上处理网络流量。iptables相关的内核模块在这些hook注册了处理函数，因此可以通过iptables规则来使得网络流量符合防火墙规则。</p><h3 id="2、Netfilter-Hooks"><a href="#2、Netfilter-Hooks" class="headerlink" title="2、Netfilter Hooks"></a>2、Netfilter Hooks</h3><p>netfilter提供了5个关于IPv4的hook点，数据包经过协议栈时会触发内核模块注册在这里的处理函数。触发哪个hook取决于包的方向（接收还是接收）、包的目的地址、以及包在上一个hook点是被丢弃还accept等等。</p><p>下面几个hook是内核协议栈已经定义好的：</p><ul><li>NF_IP_PRE_ROUTING: 接收到的包进入协议栈立即触发此个hook（刚刚进行完版本号，校验和等检测），在进行任何路由判断之前</li><li>NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此hook</li><li>NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此hook</li><li>NF_IP_LOCAL_OUT：本机产生的准备发送的包，在进入协议栈后立即触发此hook</li><li>NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由的判断之后，将触发此hook</li></ul><p>注册处理函数时必须提供优先级，以便hook触发能按照优先级高低调用处理函数，这使得多个模块可以在同一个hook点注册，并且有确定的处理顺序，内核模块会依次被调用，每次返回一个结果给netfilter框架，提示该对这包做什么操作。</p><h3 id="3、Hooks和Iptables-table-and-chain的关系"><a href="#3、Hooks和Iptables-table-and-chain的关系" class="headerlink" title="3、Hooks和Iptables table and chain的关系"></a>3、Hooks和Iptables table and chain的关系</h3><p>Iptable使用table来组织规则，分为以下5类table：</p><ul><li>Filter Table：是最常用的table之一，用于判断是否允许一个包通过。</li><li>NAT Table: 用于实现网络地址转换规则。当包进入协议栈的时候，这些规则决定是否以及如何修改包的源/目的地址，以改变包被 路由时的行为。nat table通常用于将包路由到无法直接访问的网络。</li><li>Mangle Table: 用于修改包的IP头。如可以修改包的TTL，增加或减少包可以经过的跳数。还可以对包打只在内核内有效的“标记”，后续的table或工具处理的时候可以用到这些标记。标记不会修改包本身，只是在包的内核表示上做标记。</li><li>Raw Table：其功能非常有限，其唯一目的就是提供一个让包绕过连接跟踪的框架。</li><li>Security Table：作用是给包打上SELinux标记，以此影响SELinux 或其他可以解读 SELinux 安全上下文的系统处理包的行为。这些标记可以基于单个包，也可以基于连接。</li></ul><p>在每个table内部，规则被进一步组织成chain，内置的chain是由内置的hook触发的。chain基本上能决定规则何时被匹配。内置的chain名字和netfilter hook名字是一一对应的：</p><ul><li>PREROUTING: 由 NF_IP_PRE_ROUTING hook触发 ——————&gt; raw,mangle,nat(目的)</li><li>INPUT: 由 NF_IP_LOCAL_IN hook触发 ——————&gt; mangle,filter,security,nat(源)</li><li>FORWARD: 由 NF_IP_FORWARD hook触发 ——————&gt; mangle,filter,security</li><li>OUTPUT: 由 NF_IP_LOCAL_OUT hook触发 ——————&gt; raw,mangle,nat,filter,security,nat(源)</li><li>POSTROUTING: 由 NF_IP_POST_ROUTING hook触发 ——————&gt; mangle，nat(源)</li></ul><p>chain使管理员可以控制在包的传输路径上哪个点应用策略。因为每个table有多个chain，因此一个 table可以在处理过程中的多个地方施加影响。特定类型的规则只在协议栈的特定点有意义，因此并不是每个table都会在内核的每个hook注册chain。可以看出raw table只有两个链prerouting和output，分别在对应的hook点发挥作用。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/1.jpg?raw=true" alt="image"></p><h3 id="4、从IP协议栈入手"><a href="#4、从IP协议栈入手" class="headerlink" title="4、从IP协议栈入手"></a>4、从IP协议栈入手</h3><p>要想理解Netfilter的工作原理，必须从对Linux IP报文处理流程的分析开始，Netfilter正是将自己紧密地构建在这一流程之中的。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/2.jpg?raw=true" alt="image"></p><h4 id="4-1-接收中断"><a href="#4-1-接收中断" class="headerlink" title="4.1 接收中断"></a>4.1 接收中断</h4><p>如果网卡收到一个和自己MAC地址匹配或链路层广播的以太网帧，它就会产生一个中断。此网卡的驱动程序会处理此中断做入下处理：</p><ul><li>从DMA/PIO或其他地方得到分组数据，写到内存里去；</li><li>接着，会分配一个新的套接字缓冲区skb，并调用与协议无关的、网络设备均支持的通用网络接收处理函数netif_rx(skb)。netif_rx()函数让内核准备进一步处理skb。</li><li>然后，skb会进入到达队列以便CPU处理（对于多核CPU而言，每个CPU维护一个队列）。如果FIFO队列已满，就会丢弃此分组。在skb排队后，调用__cpu_raise_softirq()标记NET_RX_SOFTIRQ 软中断，等待 CPU 执行。</li><li>至此， netif_rx() 函数调用结束，返回调用者状况信息（成功还是失败等）。此时，中断上下文进程完成任务，数据分组继续被上层协议栈处理。</li></ul><p>流程：网卡收到一帧————&gt;引发中断————&gt;cpu调用相应的中断处理函数（指向此网卡驱动中的相应的处理函数）（把此packet读到ram中）————&gt;呼叫netif_rx函数来打上timestamp，并把此skb放入到cpu设置的队列中————&gt;标记软中断（__cpu_raise_softirq）————&gt;中断完成。 </p><h4 id="4-2-softirq"><a href="#4-2-softirq" class="headerlink" title="4.2 softirq"></a>4.2 softirq</h4><p>内核2.4以后，整个协议栈不再使用bottom half，而是被软中断softirq取代。软中断 softirq优势明显，可以同时在多个CPU上执行；而bottom half一次只能在一个CPU上执行，即在多个CPU执行时严格保持串行。</p><p>整个softirq机制的设计与实现中自始自终都贯彻了一个思想：“谁触发，谁执行 ”，也即触发软中断的那个CPU负责执行它所触发的软中断，而且每个CPU都由它自己的软中断触发与控制机制。这个设计思想也使得softirq机制充分利用了SMP系统的性能和特点。</p><h4 id="4-3-NET-RX-SOFTIRQ-网络接收软中断"><a href="#4-3-NET-RX-SOFTIRQ-网络接收软中断" class="headerlink" title="4.3 NET_RX_SOFTIRQ 网络接收软中断"></a>4.3 NET_RX_SOFTIRQ 网络接收软中断</h4><p>这一阶段会根据协议的不同来处理数据分组。 CPU开始处理软中断do_softirq()，接着 net_rx_action() 处理前面标记的NET_RX_SOFTIRQ ，把出对列的skb送入相应列表处理（根据协议不同到不同的列表）。比如，IP分组交给 ip_rcv()处理， ARP分组交给arp_rcv()处理等。</p><h4 id="4-4-处理IPv4分组"><a href="#4-4-处理IPv4分组" class="headerlink" title="4.4 处理IPv4分组"></a>4.4 处理IPv4分组</h4><p>下面讲讲数据包到达网络层后所做的处理，整理流程如下图，从图中可以看到netfilter起作用的5个hooks。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/3.jpg?raw=true" alt="image"></p><h5 id="4-4-1-上述处理的详细过程如下："><a href="#4-4-1-上述处理的详细过程如下：" class="headerlink" title="4.4.1 上述处理的详细过程如下："></a>4.4.1 上述处理的详细过程如下：</h5><ul><li>ip_rcv()函数验证IP分组，比如目的地址是否本机地址，校验和是否正确等。若正确，<strong>则交给netfilter的NF_IP_PRE_ROUTING钩子</strong>,否则丢弃。</li><li>到了ip_rcv_finish()函数，数据包就要根据skb结构的目的或路由信息各奔东西了。<strong>ip_local_deliver</strong>()处理到本机的数据分组、<strong>ip_forward</strong>()处理需要转发的数据分组、<strong>ip_mr_input</strong>()转发组播数据包。如果是转发的数据包，还需要找出出口设备和下一跳。ip_rcv_finish()函数最后执行dst_input()，决定数据包的下一步的处理。</li></ul><h5 id="4-4-2-转发数据包"><a href="#4-4-2-转发数据包" class="headerlink" title="4.4.2 转发数据包"></a>4.4.2 转发数据包</h5><p>转发数据包的主要流程如下：</p><ul><li>处理IP头选项。如果需要的话，会记录本地IP地址和时间戳；</li><li>确认分组可以被转发；</li><li>将TTL减一，如果TTL为0 ，则丢弃分组；</li><li>根据 MTU 大小和路由信息，对数据分组进行分片，如果需要的话；</li><li>将数据分组送往外出设备。</li></ul><p>如果由于某种原因，数据分组不能被转发，那么就回应 ICMP 消息来说明不能转发的原因。在对转发的分组进行各种检查无误后，执行 ip_forward_finish ，准备发送。然后执行dst_output(skb) 。无论是转发的分组，还是本地产生的分组，都要经过dst_output(skb) 到达目的主机。 IP 头在此时已经完成就绪。dst_output(skb) 函数要执行虚函数 output（单播的话为ip_output ，多播为ip_mc_output）。最后，ip_finish_output 进入邻居子系统。</p><h5 id="4-4-3-数据包本地处理"><a href="#4-4-3-数据包本地处理" class="headerlink" title="4.4.3 数据包本地处理"></a>4.4.3 数据包本地处理</h5><p>数据包交给netfilter的IP_LOCAL_INPUT钩子,作相应处理，然后交给上层比如TCP进行下一步处理。TCP的处理过程如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/5.jpg?raw=true" alt="image"></p><p>ip_queue_xmit检查socket结构体中是否含有路由信息，如果没有则执行 ip_route_output_flow查找，并存储到sk数据结构中。如果找不到，则丢弃数据包。</p><p>数据最终到达驱动层，然后网卡再将数据发送出去。</p><h3 id="5、Netfilter-hook深入"><a href="#5、Netfilter-hook深入" class="headerlink" title="5、Netfilter hook深入"></a>5、Netfilter hook深入</h3><p>Netfilter的主要工作其实将iptable对应的规则转换成对应nf_hoo_ops变量，然后进行注册从而发挥作用，接下来我们看一下具体过程。</p><h4 id="5-1-注册和注销Netfilter-hook"><a href="#5-1-注册和注销Netfilter-hook" class="headerlink" title="5.1 注册和注销Netfilter hook"></a>5.1 注册和注销Netfilter hook</h4><p>注册一个hook函数是围绕nf_hook_ops数据结构的一个非常简单的操作，nf_hook_ops数据结构在linux/netfilter.h中定义，该数据结构的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span>                    </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>  </span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn *hook;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>   </span><br><span class="line">        <span class="keyword">u_int8_t</span> pf;    </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum;</span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>该数据结构中的list成员用于维护Netfilter hook的列表，并且不是用户在注册hook时需要关心的重点。</li><li>hook成员是一个指向nf_hookfn类型的函数的指针，该函数是这个hook被调用时执行的函数。nf_hookfn同样在linux/netfilter.h中定义。</li><li>pf这个成员用于指定协议族。有效的协议族在linux/socket.h中列出，但对于IPv4我们希望使用协议族PF_INET。</li><li>hooknum这个成员用于指定安装的这个函数对应的具体的hook类型，其值为NF_IP_PRE_ROUTING等。</li><li>priority这个成员用于指定在执行的顺序中，这个hook函数应当在被放在什么地方。对于IPv4，可用的值在linux/netfilter_ipv4.h的 nf_ip_hook_priorities 枚举中定义。出于示范的目的，在后面的模块中我们将使用NF_IP_PRI_FIRST。</li></ul><p>注册一个Netfilter hook需要调用nf_register_hook()函数，以及用到一个nf_hook_ops数据结构。nf_register_hook()函数以一个nf_hook_ops数据结构的地址作为参数并且返回一个整型的值。以下提供的是一个示例代码，该示例代码简单的注册了一个丢弃所有到达的数据包的函数。该代码同时展示了Netfilter的返回值如何被解析。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"xsc"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">nfho</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hook_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct net_device *in,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct net_device *out,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> (*okfn)(struct sk_buff *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NF_DROP;<span class="comment">//丢弃所有数据包</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kexec_test_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"kexec test start ...\n"</span>);</span><br><span class="line"> </span><br><span class="line">    nfho.hook = hook_func;</span><br><span class="line">    nfho.owner = <span class="literal">NULL</span>;</span><br><span class="line">    nfho.pf = PF_INET;</span><br><span class="line">    nfho.hooknum = NF_INET_LOCAL_OUT;</span><br><span class="line">    nfho.priority = NF_IP_PRI_FIRST;</span><br><span class="line">    </span><br><span class="line">    nf_register_hook(&amp;nfho);<span class="comment">// 注册一个钩子函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kexec_test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"kexec test exit ...\n"</span>);</span><br><span class="line">    nf_unregister_hook(&amp;nfho); <span class="comment">//注销钩子函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kexec_test_init); <span class="comment">//初始化</span></span><br><span class="line">module_exit(kexec_test_exit); <span class="comment">//退出处理</span></span><br></pre></td></tr></table></figure></p><h4 id="5-2-hook函数实现"><a href="#5-2-hook函数实现" class="headerlink" title="5.2 hook函数实现"></a>5.2 hook函数实现</h4><p>hook函数原型在linux/netfilter.h中给出，如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int nf_hookfn(unsigned int hooknum,</span><br><span class="line">                               struct sk_buff *skb,</span><br><span class="line">                               <span class="keyword">const</span> struct net_device *<span class="keyword">in</span>,</span><br><span class="line">                               <span class="keyword">const</span> struct net_device *<span class="keyword">out</span>,</span><br><span class="line">                               int <span class="comment">(*okfn)(struct sk_buff *)</span>);</span><br></pre></td></tr></table></figure></p><ul><li>skb之后的两个参数是指向net_device数据结构的指针，net_device数据结构被Linux内核用于描述所有类型的网络接口。这两个参数中的第一个in，用于描述数据包到达的接口，毫无疑问，参数out用于描述数据包离开的接口。必须明白，在通常情况下，这两个参数中将只有一个被提供。例如：参数in只用于NF_IP_PRE_ROUTING和NF_IP_LOCAL_IN hook，参数out只用于NF_IP_LOCAL_OUT和NF_IP_POST_ROUTING hook。</li><li>sk_buff数据结构中最有用的部分可能就是那三个描述传输层包头（例如：UDP, TCP, ICMP, SPX）、网络层包头（例如：IPv4/6, IPX, RAW）以及链路层包头（例如：以太网或者RAW）的联合(union)了。这三个联合的名字分别是h、nh以及mac。这些联合包含了几个结构，依赖于具体的数据包中使用的协议。</li><li>传递给hook函数的最后一个参数是一个命名为okfn函数指针，该函数以一个sk_buff数据结构作为它唯一的参数，并且返回一个整型的值。</li></ul><h4 id="5-3-Netfilter报过滤技术实现"><a href="#5-3-Netfilter报过滤技术实现" class="headerlink" title="5.3 Netfilter报过滤技术实现"></a>5.3 Netfilter报过滤技术实现</h4><p>介绍几种过滤技术的实现：</p><ul><li><strong>基于接口进行过滤</strong>:使用相应的net_device数据结构的name这个成员，你就可以根据数据包的源接口和目的接口来选择是否丢弃它。如果想丢弃所有到达接口eth0的数据包，你需要做的仅仅是将in-&gt;name 的值与”eth0”做比较，如果名字匹配，那么hook函数简单的返回NF_DROP即可，数据包会被自动销毁。</li><li><strong>基于地址进行过滤</strong>:基于数据包的源或目的IP地址进行过滤也同样可以实现， 获取一个数据包的IP头通过使用sk_buff数据结构中的网络层包头来完成。这个头位于一个联合中，可以通过sk_buff-&gt;nh.iph这样的方式来访问。如果数据包的源地址与我们设定的丢弃数据包的地址匹配，那么该数据包将被丢弃。</li><li><strong>基于TCP端口进行过滤</strong>:获取一个TCP头的指针是一件简单的事情,而可以分配一个tcphdr数据结构(在linux/tcp.h中定义)的指针，并将它指向我们的数据包中IP头之后的数据。如下代码：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int check_tcp_packet(<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span></span> *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span></span> *sk = skb_copy(skb, <span class="number">1</span>);  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span></span> *tcph = NULL;  </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span></span> *iph = NULL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span></span> *ip;  </span><br><span class="line">    __be16 dport;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!skb)  </span><br><span class="line"><span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">    ip = ip_hdr(sk);                                               </span><br><span class="line">    iph = ip_hdr(skb);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;protocol == IPPROTO_TCP)       <span class="comment">// TCP 协议</span></span><br><span class="line">    &#123;           </span><br><span class="line">        tcph = (void *) iph + iph-&gt;ihl * <span class="number">4</span>;  <span class="comment">// TCP 包头  </span></span><br><span class="line">        dport = tcph-&gt;dest;                  <span class="comment">// 目标端口  </span></span><br><span class="line">        <span class="keyword">if</span>(ntohs(dport) == <span class="number">25</span> )</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> NF_DROP;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、下一步延伸"><a href="#6、下一步延伸" class="headerlink" title="6、下一步延伸"></a>6、下一步延伸</h3><p>更多更深的内容需要进一步学习linux内核，这里就不再细述了，关于Netfilter的hook攻击技术以及libpcap的通信隐藏等都挺有意思的，有时间不妨深入去实践一下。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>1.<a href="https://arthurchiao.github.io/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">https://arthurchiao.github.io/blog/deep-dive-into-iptables-and-netfilter-arch-zh/</a><br>2.<a href="https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html</a><br>3.<a href="https://blog.csdn.net/cheng_fangang/article/details/8966242" target="_blank" rel="noopener">https://blog.csdn.net/cheng_fangang/article/details/8966242</a><br>4.<a href="https://blog.csdn.net/XscKernel/article/details/8186679" target="_blank" rel="noopener">https://blog.csdn.net/XscKernel/article/details/8186679</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Iptabls </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（七）站在对象模型的顶端</title>
      <link href="/2018/11/22/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2018/11/22/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章的的主题是站在对象模型的尖端，套路哦三个著名的c++语言扩充性质，它们都会影响c++对象，他们分别是exception handling（EH）、template support、runtime type identification(RTTI)。<br><a id="more"></a></p><hr><h3 id="一、Template"><a href="#一、Template" class="headerlink" title="一、Template"></a>一、Template</h3><p>这一节的焦点放在template的语意上面，我们将讨论templates在编译系统中“何时”，“为什么”以及“如何”发挥其功能。下面是有关template的三个主要讨论方向：</p><ul><li>template的声明，基本上来说就是当你声明一个template class、template class member function等等，会发生什么事情。</li><li>如何”实例化”class object、inline nonmember以及member template functions，这些是”每一个编译单元都会拥有的一份实体”的东西。</li><li>如何“实例化”出nonmember、member templates functions以及static template class members，这些都是”每一个可执行文件中只需要一份实体”的东西，这也就是一般而言template所带来的问题。</li></ul><h4 id="1-1-template的“实例化”行为"><a href="#1-1-template的“实例化”行为" class="headerlink" title="1.1 template的“实例化”行为"></a>1.1 template的“实例化”行为</h4><p>对于如下template class:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123; unallocated, normalized &#125;;</span><br><span class="line">    </span><br><span class="line">    Point(Type x = <span class="number">0.0</span>, Type y = <span class="number">0.0</span>, Type z = <span class="number">0.0</span>);</span><br><span class="line">    ~Point();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span> )</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Point&lt;Type&gt; *freeList;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">    Type _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>编译器对于template class会根据type的不同而产生不同的实例class。</p><ul><li>enum Status、freeList、chunkSize以及object都必须进行实例化，如<strong>Point<double>::freeList;</double></strong>,而不能是<strong>Point::freeList;</strong>`。</li><li>定义一个指针，指向特定的实例。例如<strong>Point<float> *ptr=0;</float></strong>因为一个指向class object的指针，本身并不是一个class object，编译器不需要知道与该class有关的任何member的数据或object的布局数据。所以不需要实例化。</li><li>定义一个reference,例如<strong>Point<float> &amp;refer=0;</float></strong>就需要产生一个Point的float实例。</li></ul><h4 id="2-2-member-function需要实例化吗？"><a href="#2-2-member-function需要实例化吗？" class="headerlink" title="2.2 member function需要实例化吗？"></a>2.2 member function需要实例化吗？</h4><p>member functions(至少对于那些未被使用过的)不应该被“实体”化，只有在member functions被使用的时候，C++ Standard才要求它们被“实例化”。当前的编译器并不精 确遵循这项要求，之所以由使用者来主导“具现”规则，有两个主要原因：</p><ul><li>空间和时间效率的考虑。如果class中有100个member functions，但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中5个，那么其他193个函数都“具现”将花费大量的时间和空间。</li><li>尚未实现的功能，并不是一个template实例化的所有类型就一定能够支持一组member functions所需要的所有运算符。如果只“具现”那些真正用到的memeber functions，template就能够支持那些原本可能会造成编译时期错误的类型(types)。</li></ul><h4 id="1-3-template的错误报告。"><a href="#1-3-template的错误报告。" class="headerlink" title="1.3 template的错误报告。"></a>1.3 template的错误报告。</h4><p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行以有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让它通过了，只有在特定实例被定义之后，才能发出抱怨。这是目前实现技术上的一个大问题。</p><h4 id="1-4-Template中的名称决议法。"><a href="#1-4-Template中的名称决议法。" class="headerlink" title="1.4 Template中的名称决议法。"></a>1.4 Template中的名称决议法。</h4><p>Template有两种语境，一种是C++ Standard所谓的”Scope of the template definition”，也就是“定义出template”的程序。另一种是C++ Standard所谓的”scope of the template instantiation”，也就是说“具现出template”的程序。<br>Template之中，对于一个nonmember name的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而设定的。如果其使用互不相关，那么就以“scope of the template declaration”来决定name。如果其使用互有关联，那么就以“scope of template instantiation”来决定name。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ScopeRules</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123; _member = foo(val); &#125;</span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> foo(_member);&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _val;</span><br><span class="line">    type _member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scope of the template instantiation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ScopeRultes&lt;<span class="keyword">int</span>&gt; sr0;</span><br></pre></td></tr></table></figure></p><ul><li>对于<strong>sr0.invariant();</strong>由于被用来实例化这个template的真正类型，对于 _val的类型并没有影响。所以选中<strong>extern double foo(double);</strong></li><li>对于<strong>sr0.type_dependent();</strong>_member与template参数有关,所以选中的foo()跟参数有关,所以选中<strong>extern int foo(int);</strong>。</li></ul><h4 id="1-5-Member-function的实例化行为。"><a href="#1-5-Member-function的实例化行为。" class="headerlink" title="1.5 Member function的实例化行为。"></a>1.5 Member function的实例化行为。</h4><p>对于template的支持，最困难的莫过于template function的实例化，目前的编译器提供了 两个策略：一个是编译时期策略，程序代码必须在program text file中备妥可用；另一个是链接时期策略，程序代码必须在meta-compliation工具可以导引编译器的实例化行为(instantiation)。<br>下面是编译器设计者必须回答的三个主要问题：</p><ul><li>（1）编译器如何找出函数的定义？<br>答案之一是包含template program text file，就好像它是个header文件一样，Borland编译器就是遵循这个策略。另一种方法是要求一个文件命名规则，例如，我们可以要求，在Point.h文件中发现的函数声明，其template program text一定要放置于文件Point.c或者Point.cpp中，以此类推。cfront就是遵循这个策略。Edison Desigin Group编译器对此两种策略都支持。</li><li>（2）编译器如何能够只实例化出程序中用到的member functions?<br>解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的——虽然它也提供#pragmas让你压制(或具现出)特定实体。另一种策略就是仿真链接操作，检测看看哪一个函数真正需要，然后只为它(们)产生实体。cfront就是这么做的，Edison Design Group编译器对此两种策略都支持。</li><li>（3）编译器如何阻止member definitions在多个.o文件中都被实例化呢?<br>解决办法之一是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另外一个办法就是由使用者来导引“仿真链接阶段”的实例化策略，决定哪些实体(instances)才是所需求的。</li></ul><p>实际上，template instantiation似乎拒绝全面自动化，甚至居然没意见工作都对了，产生出来的object files的重新编译成本仍然可能很高。<strong>以手动方式先在个别的object module中完成预先实例化操作，虽然沉闷，却是唯一有效率的方法。</strong></p><h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><h4 id="2-1-编译对异常处理的支持"><a href="#2-1-编译对异常处理的支持" class="headerlink" title="2.1 编译对异常处理的支持"></a>2.1 编译对异常处理的支持</h4><p>欲支持exception handling，编译器的主要工作就是找出catch子句，以处理被丢出来的exception。这多少需要追踪程序堆栈中的每一个函数当前作用区域(包括追踪函数中的local class objects当时的情况)。同时，编译器必须提供某种查询exception objects的方法，以知道其实际类型(这直接导致某种形式的执行期识别，也就是RTTI)。最后，还需要某种机制用以管理被丢出的object，包括它的产生、储存、可能的解构(如果有相关的destructor)、清理(clean up)以及一般存取，也可能有一个以上的objects同时起作用。      </p><p>一般而言，exception handling机制需要与编译器所产生的数据结构以及执行期的一个exception library紧密合作，在程序大小和执行速度之间，编译器必须有所抉择：</p><ul><li>为了维持执行速度，编译器可以在编译时期建立起用于支持的数据结构，这会使程序大小膨胀，但编译器可以几乎忽略这些结构，直到有个exception被丢出来。</li><li>为了维持程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构(并且可以抛弃之)。</li></ul><h4 id="2-2-Exception-Handling-快速检阅"><a href="#2-2-Exception-Handling-快速检阅" class="headerlink" title="2.2 Exception Handling 快速检阅"></a>2.2 Exception Handling 快速检阅</h4><p>C++的exception handing由三个主要的语汇组件构成：</p><ul><li>一个throw子句。它在程序某处发出一个exception。被抛出去的expection可以是內建类型，也可以是使用者自定类型。</li><li>一个或多个catch子句。每一个catch子句都是一个exception handler。它用来表示说，这个子句准备处理某种类型的exception，并且在封闭的大括号区段中提供实际的处理程序</li><li>一个try区段。它被围绕以一系列的叙述句(statements)，这些叙述句可能会引发catch子句起作用  </li></ul><p>当一个exception被丢出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate()会被调用。当控制权被抛弃后，堆栈中的每一个函数调用也就被推离(popped up)，这个程序称为unwinding the stack。<strong>在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用。</strong></p><h4 id="2-3-对Exception-Handling的支持"><a href="#2-3-对Exception-Handling的支持" class="headerlink" title="2.3 对Exception Handling的支持"></a>2.3 对Exception Handling的支持</h4><p>当一个exception发生时，编译系统必须完成以下事情：<br>（1）检验发生throw操作的函数；<br>（2）决定throw操场是否发生在try区段中；<br>（3）若是，编译系统必须把exception type拿来和每一个catch子句比较；<br>（4）如果比较吻合，流程控制应该交到catch子句手中；<br>（5）如果throw的发生并不在try区段中，并没有一个catch子句吻合，那么系统必须(a)摧毁所有active local objects，(b)从堆栈中将当前的函数”unwind”掉，(c)进行到程序堆栈中的下一个函数中去，然后重复上述步骤2~5</p><h4 id="2-4-当一个实际对象在程序执行时被丢出，会发生什么事？"><a href="#2-4-当一个实际对象在程序执行时被丢出，会发生什么事？" class="headerlink" title="2.4 当一个实际对象在程序执行时被丢出，会发生什么事？"></a>2.4 当一个实际对象在程序执行时被丢出，会发生什么事？</h4><p>当一个exception被丢出时，exception object会被产生出来并通常放置在相同形式的exception数据堆栈中，从throw端传染给catch子句的是exception object的地址、类型描述器(或是一个函数指针，该函数会传回与该exception type有关的类型描述器对象)，以及可能会有的exception object描述器(如果有人定义它的话)。</p><h3 id="三、执行器类型识别（RTTI）"><a href="#三、执行器类型识别（RTTI）" class="headerlink" title="三、执行器类型识别（RTTI）"></a>三、执行器类型识别（RTTI）</h3><p>RTTI是用于支持EH而获得的副产品，主要目的是处理和识别throw的object类型。</p><h4 id="3-1-Type-Safe-Downcast-保证安全的向下转型操作"><a href="#3-1-Type-Safe-Downcast-保证安全的向下转型操作" class="headerlink" title="3.1 Type-Safe Downcast(保证安全的向下转型操作)"></a>3.1 Type-Safe Downcast(保证安全的向下转型操作)</h4><p>一个type-safe downcast(保证安全地向下转换操作)必须在执行期对指针有所查询，看看它是否指向它所展现(表达)之object的真正类型。因此，欲支持type-safe downcast在object空间和执行时间上都需要一些额外的负担：</p><ul><li>需要额外的空间以存储类型信息(type information)，通常是一个指针，指向某个类型信息节点</li><li>需要额外的时间以决定执行期的类型(runtime type)，因为，正如其名所示，这需要再执行期才能决定。</li></ul><p>c++的RTTI机制提供了一个安全的downcast设备,但只对那些展现“多态”的类型有效。c++中，一个具备多态性质的class，正式内含着继承而来的virtual function。</p><h4 id="3-2-Type-Safe-Dynamic-cast-保证安全的动态转型"><a href="#3-2-Type-Safe-Dynamic-cast-保证安全的动态转型" class="headerlink" title="3.2 Type-Safe Dynamic cast(保证安全的动态转型)"></a>3.2 Type-Safe Dynamic cast(保证安全的动态转型)</h4><p>dynamic_cast运算符可以在执行期决定真正的类型。如果downcast是安全的，这个运算符会传回被适当转换过的指针。如果downcast不是安全地，这个运算符会传回0.</p><h4 id="3-3-References并不是Pointers"><a href="#3-3-References并不是Pointers" class="headerlink" title="3.3 References并不是Pointers"></a>3.3 References并不是Pointers</h4><p>程序中对一个class指针类型施以dynamic_cast运算符，会获得true或false：</p><ul><li>如果传回真正的地址，表示这个object的动态类型被确认了，一些与类型相关的操作现在可以施行于其上。</li><li>如果传回0，表示没有指向任何object，意味应该以另一种逻辑施行于这个动态类型未确定的object身上。</li></ul><p>dynamic_cast运算符也适用于reference身上。然而对于一个non-type-safe cast，其结果不会与施行于指针的情况相同。为什么？<br>一个reference不可以像指针那样”把自己设为0就代表了”no object”；若将一个reference 设为0，会引起一个临时性对象(拥有被参考到的类型)被产生出来，该临时对象的初值为0，这个reference然后被设定成为该临时性对象的一个别名。<br>因此当dynamic_cast运算符施行于一个reference时，不能够提供对等于指针情况下的那一组true/false。取而代之的是，会发生下列事情：</p><ul><li>如果reference真正参考到适当的derived class(包括下一层或下下一层或下下下一层或…)，downcast会被执行而程序可以继续执行。</li><li>如果reference并不真正是某一种derived class，那么，由于不能传回0，遂丢出一个bad_cast exception.</li></ul><h4 id="3-4-Typeid运算符"><a href="#3-4-Typeid运算符" class="headerlink" title="3.4 Typeid运算符"></a>3.4 Typeid运算符</h4><p>typeid运算符传回一个const reference，类型为type_info。<br>type_info object由什么组成？ C++ Standard中对type_info的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> type_info&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> type_info&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//传回class原始名称</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//prevent memberwise init and copy</span></span><br><span class="line">    type_info(<span class="keyword">const</span> type_info&amp; );</span><br><span class="line">    type_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> type_info&amp; );</span><br><span class="line">    <span class="comment">//data members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>编译器必须提供的最小量信息是class的真实名称、以及在type_info objects之间的某些排序算法(这就是before()函数目的)、以及某些形式的描述器，用以表现explicit class type和这个class的任何subtype。</p><h3 id="四、效率有了，弹性呢？"><a href="#四、效率有了，弹性呢？" class="headerlink" title="四、效率有了，弹性呢？"></a>四、效率有了，弹性呢？</h3><p>创痛的c++对对象模型提供有效率的执行期支持。这份效率，再加上与c之间的兼容性，造成了C++的广泛被接受。然而，在某些领域方面，像是动态共享库、共享内存以及分布式对象方面，这个对象模型的弹性还是不够。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（六）执行期语意学</title>
      <link href="/2018/11/21/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2018/11/21/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章的的主题是执行器语意学，查看执期的某些对象模型行为。包括零时性对象的生命及其死亡，以及对new运算符和delete预算符的支持。<br><a id="more"></a></p><hr><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>实际上，一个简单的操作，其背后所隐藏的意义都要经过编译器进行适当的解析，编译器所作的工作可能会超出我们的想象许多，编译器所做的这些填充操作最后都会在执行期一一执行，本章就是要看执行期所发生的转换。</p><h3 id="二、对象的构造和析构"><a href="#二、对象的构造和析构" class="headerlink" title="二、对象的构造和析构"></a>二、对象的构造和析构</h3><h4 id="2-1-关于构造和析构"><a href="#2-1-关于构造和析构" class="headerlink" title="2.1 关于构造和析构"></a>2.1 关于构造和析构</h4><p>构造通常在object被定义之后，而destructor要放在每一个离开点之前。一般而言我们会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。</p><blockquote><p>我们很多时候习惯把变量和object的定义放在函数的开始部分，这使得部分不必要的destructor不得不被调用，增加了部分开销。</p></blockquote><h4 id="2-2-全局对象"><a href="#2-2-全局对象" class="headerlink" title="2.2 全局对象"></a>2.2 全局对象</h4><p>C++ 保证，一定会在main()函数中第一次用到global object之前，把它构造出来，而在main() 函数结束之前把global object摧毁掉。global object如果有constructor和destructor的话， 我们说它需要静态的初始化操作和内存释放操作。<br>C++程序中所有的global objects都被放置在程序的data segment中。如果显式指定给它一个值， 此object 将以该值为初值。否则object配置到的内存内容为0。虽然class object在编译时期可以 被放置于data segment中并且内容为0，但constructor一直要到程序启动(startup)时才会实施。  </p><h4 id="2-3-局部静态对象"><a href="#2-3-局部静态对象" class="headerlink" title="2.3 局部静态对象"></a>2.3 局部静态对象</h4><p>关于局部静态对象，注意两点：<br>（1）即使其所在的函数被调用多次，对应的constructor也只能执行一次。<br>（2）即使其所在的函数被调用多次，对应的deconstructor也只能执行一次。<br>为了能只执行一次对应的constructor，编译器引入一个临时性变量用于进行判断，初始时临时性变量为false，当local static object被构建好后，临时性变量变为true。而destructor则根据该 临时性是否为true决定是否析构local static object。</p><h4 id="2-4-对象数组"><a href="#2-4-对象数组" class="headerlink" title="2.4 对象数组"></a>2.4 对象数组</h4><p>C++编译器之一cfront提供一个被命名为ve_new()函数，产生出以class objects构造而 成的数组。在vec_new()中，constructor施行于elem_count个元素之上;在vec_delete()中，destructor被施行于elem_count个元素身上。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>] = &#123;Point(),Point(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),<span class="number">-1.0</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>对于上述这种明显获得初值的元素，vec_new()不再有必要。对于那些尚未被初始化的元素，vec_new()的施行方式就像面对“由class elements组成的数组，而该数组没有explicit initialization list”一样。类似下面这样：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//明确初始化前3个元素</span></span><br><span class="line"><span class="symbol">Point:</span>:Point(<span class="variable">&amp;knots</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="symbol">Point:</span>:Point(<span class="variable">&amp;knots</span>[<span class="number">1</span>], <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="symbol">Point:</span>:Point(<span class="variable">&amp;knots</span>[<span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="comment">//以vec_new初始化后7个元素</span></span><br><span class="line">vec_new(<span class="variable">&amp;knots</span> + <span class="number">3</span>, sizeof(Point), <span class="number">7</span>, &amp;<span class="symbol">Point::</span>Point, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h2 id="三、new和delete运算符"><a href="#三、new和delete运算符" class="headerlink" title="三、new和delete运算符"></a>三、new和delete运算符</h2><h4 id="3-1-new和delete对内置类型的处理。"><a href="#3-1-new和delete对内置类型的处理。" class="headerlink" title="3.1 new和delete对内置类型的处理。"></a>3.1 new和delete对内置类型的处理。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>对于如上的语句，实际分为如下两个步骤完成：<br>（1）通过适当的new运算符配置所需的内存。<br>（2）给配置得来的对象设立初值。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际执行过程</span></span><br><span class="line">int *<span class="literal">pi</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">pi</span> = <span class="variable">_new</span>(<span class="built_in">sizeof</span>(int)))  *<span class="literal">pi</span> = <span class="number">5</span>; <span class="comment">//成功了才初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delete运算符的情况类似</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">pi</span> != <span class="number">0</span>)   <span class="variable">_delete</span>(<span class="literal">pi</span>);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-construct如何配置一个class-object？"><a href="#3-2-construct如何配置一个class-object？" class="headerlink" title="3.2 construct如何配置一个class object？"></a>3.2 construct如何配置一个class object？</h4><p>以constructor来配置一个class object，处理类似如下：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Point3d *<span class="built_in">origin</span> = <span class="built_in">new</span> Point3d;</span><br><span class="line">//被转换为：</span><br><span class="line">Point3d *<span class="built_in">origin</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">origin</span>  = _new(sizeof(Point3d)))  <span class="built_in">origin</span> = Point3d::Point3d(<span class="built_in">origin</span>);</span><br><span class="line"></span><br><span class="line">//对于<span class="built_in">delete</span> <span class="built_in">origin</span>，转换结果类似于：</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">origin</span> != <span class="number">0</span>)   </span><br><span class="line">&#123;</span><br><span class="line">   Point3d::~Point3d(<span class="built_in">origin</span>);</span><br><span class="line">   _delete(<span class="built_in">origin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new运算符实际上总是以标准的C malloc()完成，虽然并没有规定一定得这么做不可。相同情况，delete运算符总是以标准的C free()完成。</p><h4 id="3-3-针对数组的new语意"><a href="#3-3-针对数组的new语意" class="headerlink" title="3.3 针对数组的new语意"></a>3.3 针对数组的new语意</h4><ul><li>对于像<strong>int *p_array = new int[5];</strong>这样的语句，vec_new()不会真正被调用，因为它 的主要功能是把default constructor施行于class objects所组成的数组的每一个元素身上。</li><li>对于<strong>simple_aggr *p_aggr = new simple_aggr[5];</strong>,vec_new()也不会被调用，因为simple_aggr并没有定义一个constructor或destructor，所以配置数组以及清除p_aggr数组的操作，只是单纯地获得内存和释放内存而已，这些操作由new和delete运算符来完成就绰绰有余了。</li></ul><p>然而如果class定义有一个default constructo，某些版本的vec_new()就会被调用，配置并构 造class objects所组成的数组，如第一节中所示那样。  </p><ul><li>寻找数组维度，对于delete运算符的效率带来极大的冲击，所以才导致这样的妥协：只有在中括号出现时，编译器才寻找数组的维度，否则它便假设只有单独一个objects要被删除。</li></ul><h4 id="3-4-Placement-Operator-new的语意"><a href="#3-4-Placement-Operator-new的语意" class="headerlink" title="3.4 Placement Operator new的语意"></a>3.4 Placement Operator new的语意</h4><p>有一个预先定义好的重载的(overloaded) new运算符，称为placement operator new，它需要第二个参数，类型为void*，调用方式如下：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2w *ptw = <span class="keyword">new</span> (arena) Point2w;</span><br></pre></td></tr></table></figure></p><p>其中arena指向内存中的一个区块，用以放置新产生出来的Point2w object。这个预先定义好的placement operator new的实现方法很简单，它只要将“获得的指针”(上例为arena)所指的地址传回，可以用来在指定地址初始化一个对象。</p><h3 id="四、临时性对象"><a href="#四、临时性对象" class="headerlink" title="四、临时性对象"></a>四、临时性对象</h3><h4 id="4-1-编译器什么时候产生临时性对象和摧毁临时性对象？"><a href="#4-1-编译器什么时候产生临时性对象和摧毁临时性对象？" class="headerlink" title="4.1 编译器什么时候产生临时性对象和摧毁临时性对象？"></a>4.1 编译器什么时候产生临时性对象和摧毁临时性对象？</h4><p>是否会导致一个临时性对象，视编译器的进取性以及程序上下语境而定。C++ Standard允许编译器对于临时性对象的产生有完全的自由度。<br>c++标准指出，临时性对象的被摧毁，应该是对完整表达式求值过程中的最后一个步骤，该完整表达式造成临时性对象的产生。</p><h4 id="4-2-什么是完整表达式？"><a href="#4-2-什么是完整表达式？" class="headerlink" title="4.2 什么是完整表达式？"></a>4.2 什么是完整表达式？</h4><p>非正式地说，完整表达式是被涵括的表达式中最外围的那个。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">objA</span> &gt; <span class="number">1024</span>) <span class="symbol">&amp;&amp;</span> (<span class="name">objB</span> &gt; <span class="number">1024</span>) ? objA + objB : foo(<span class="name">objA</span>, objB))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>对于上述表达式，一共有五个子算式，内带一个”? : 完整表达式”中。任何一个子表达式所产生的任何一个临时对象，都应该在完整表达式被求值完成后，才可以毁去。</p><h4 id="4-3-关于临时性对象生命规则的的两个例外。"><a href="#4-3-关于临时性对象生命规则的的两个例外。" class="headerlink" title="4.3 关于临时性对象生命规则的的两个例外。"></a>4.3 关于临时性对象生命规则的的两个例外。</h4><p>临时性对象的生命规则有两个例外：</p><ul><li>第一个例外发生在表达式被用来初始化一个object时，C++ Standard要求说：凡含有表 达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。</li><li>临时性对象的生命规则的第二个例外是”当一个临时性对象被一个reference绑定”时。如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之reference的生命结束，或直到临时对象的生命范畴(scope)结束——视哪一种情况先到达而定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（五）构造、析构、拷贝语意学</title>
      <link href="/2018/11/20/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2018/11/20/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章的的主题是构造、析构、拷贝语意学。主要是讨论如何支持class模型，探讨object的整个生命周期。<br><a id="more"></a></p><hr><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-1-class-data-member应该何时被初始化？"><a href="#1-1-class-data-member应该何时被初始化？" class="headerlink" title="1.1 class data member应该何时被初始化？"></a>1.1 class data member应该何时被初始化？</h4><p>一般而言，class的data member应该被初始化，并且只在constructor中或是在class的其他member functions中指定初值。其他任何操作都将破坏封装性质，使class的维护和修改更加困难。</p><h4 id="1-2-关于纯虚函数的几点认识。"><a href="#1-2-关于纯虚函数的几点认识。" class="headerlink" title="1.2 关于纯虚函数的几点认识。"></a>1.2 关于纯虚函数的几点认识。</h4><ul><li>c++中可以定义和调用(invoke)一个pure virtual function：不过它只能被<strong>静态地调用</strong>(用类名调用)，不能经由虚拟机制调用。</li><li>class设计者如果声明就一定要定义pure virtual destructor，因为每一个 derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏 任何一个base class destructor的定义，就会导致链接失败。<strong>最好的方式就是不要把virtual destructor声明为pure。</strong></li></ul><h4 id="1-3-关于虚拟机制的几点认识。"><a href="#1-3-关于虚拟机制的几点认识。" class="headerlink" title="1.3 关于虚拟机制的几点认识。"></a>1.3 关于虚拟机制的几点认识。</h4><ul><li>类中设计虚函数时应先考虑清楚，不会被derived class改写的函数最好被设计 为virtual function。总靠编译器进行优化并不是好的设计理念。</li><li>决定一个virtual function是否为const需要先想清楚，不必要的地方别用。</li></ul><h3 id="二、“无继承”情况下的对象构造"><a href="#二、“无继承”情况下的对象构造" class="headerlink" title="二、“无继承”情况下的对象构造"></a>二、“无继承”情况下的对象构造</h3><h4 id="2-1-对象的生命周期。"><a href="#2-1-对象的生命周期。" class="headerlink" title="2.1 对象的生命周期。"></a>2.1 对象的生命周期。</h4><p>一个object的生命，是该object的一个执行期属性。local object的生命对应其所 在的scope。global object的生命和整个程序的生命相同。heap object的生命从 它被new运算符配置出来开始，到它被delete运算符摧毁为止。</p><h4 id="2-2-Plain-OI’-Data-和其相关处理"><a href="#2-2-Plain-OI’-Data-和其相关处理" class="headerlink" title="2.2 Plain OI’ Data 和其相关处理"></a>2.2 Plain OI’ Data 和其相关处理</h4><p>形如下列的结构，被C++标准称为Plain OI’ Data。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure></p><ul><li>如果以C++ 来编译这段码，理论上编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator。但实际上，编译器会分析这个声明，并为它贴上Plain of Data标签。</li><li>对于<strong>Point global;</strong>理论上,constructor在程序起始处被调用而destructor 在程序的exit()处被调用。然而，事实上那些tirvial members要不是没被定义， 就是没被调用，程序的行为一如它在C中的表现一样。此外，C++ 的所有全局对象都被当作“初始化过的数据”来对待。</li><li>对于<strong>Point *heap = new Point;</strong>会被转换为对new运算符的调用。但并没有default constructor施行与new运算符所传回的Point object身上。</li><li><strong>*heap = local;</strong>理论上，这样的指定操作会触发trivial copy assignment operator进行拷贝搬运操作。然而实际上此object是一个Plain old data，所以赋值操作(assignment)将只是像C那样的纯粹位搬移操作。</li><li><strong>delete heap;</strong>会被转换为对delete运算符的调用,观念上，这样的操作会触发Point的trivial destructor。但是一如我们所见，destructor要不是没有被产生就是没有被调用。</li></ul><h4 id="2-3-抽象数据类型-Abstract-Data-Type-和其相关处理"><a href="#2-3-抽象数据类型-Abstract-Data-Type-和其相关处理" class="headerlink" title="2.3 抽象数据类型(Abstract Data Type)和其相关处理"></a>2.3 抽象数据类型(Abstract Data Type)和其相关处理</h4><p>以下是Point的第二次声明，在public接口之下多了private数据，提供完整的封装性，但是没有提供virtual function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>): _x(x), _y(y),_z(y) &#123; &#125;</span><br><span class="line">    <span class="comment">//no copy constructor, copy operator or destructor defined</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>对于Point，我们不需要定义一个copy constructor或copy assignment operator，因为默认的位拷贝已经足够，也不需要destructor,因为默认的内存管理方法也已经足够，如果我们不自己定义，编译器也因为判断不会用到而不会产生的函数。</li><li>对于<strong>Point global;</strong>default constructor作用于其上。由于global被定义在全局范畴中，其初始化操作将延迟到程序激活时才开始，扩展调用default constructor。如果要将class中的所有成员都设定常 量初值，那么给予一个explicit initialization list会比较有效率些 。</li><li>对于<strong>Point *heap = new Point;</strong>`会被转换为对new运算符的调用。然后调用default Point Constructor并自行扩展。</li><li><strong>*heap = local;</strong>理论上，这样的指定操作会触发trivial copy assignment operator进行拷贝搬运操作。然而并没有，只进行简单的位拷贝操作。</li><li><strong>delete heap;</strong>，由于没有destrucor,同样不会被调用。</li></ul><h4 id="2-4-在上述情况中加入虚函数又将怎么处理？"><a href="#2-4-在上述情况中加入虚函数又将怎么处理？" class="headerlink" title="2.4 在上述情况中加入虚函数又将怎么处理？"></a>2.4 在上述情况中加入虚函数又将怎么处理？</h4><p>将人虚函数之后，class object除了多负担一个vptr之外，也引发编译器对Point class产生膨胀作用。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>): _x(x), _y(y) &#123; &#125;</span><br><span class="line">    <span class="comment">//no destructor, copy constructor or copy operator</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><p>首先constructor将需要附加一些代码用于将vptr初始化。这些代码位于base class构造函数和用户代码之间。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point* Point::Point(Point *<span class="keyword">this</span>, float x, float y): _x(x), _y(y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point = _vtbl_Point; <span class="comment">//设定object的virtual table pointer</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = x; <span class="comment">//扩展member initialization list</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_y = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//传回this对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其次需要合成一个copy constructor和一个copy assignment operator，因为直接bitwise操作对于vptr可能是非法的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy constructor的内部合成</span></span><br><span class="line"><span class="keyword">inline</span> Point* Point::Point(Point* <span class="keyword">this</span>, <span class="keyword">const</span> Point&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point = _vtbl_Point;<span class="comment">//设定object的vptr</span></span><br><span class="line">    <span class="comment">//将rhs坐标中的位连续拷贝到this对象</span></span><br><span class="line">    <span class="comment">//或是经由member assignment提供一个member...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一般而言，如果你的设计之中有许多函数都需要以传值方式传回一个local class object，此时提供一个copy constructor就比较合理，它的出现会触发NRV优化。NRV 优化后就不再需要调用copy constructor，因为运算结果已经被直接置于“将被传回 的object”体内了。(有它-&gt;NRV-&gt;不用它？？？？)</p></li></ul><h3 id="三、继承体系下的对象构造"><a href="#三、继承体系下的对象构造" class="headerlink" title="三、继承体系下的对象构造"></a>三、继承体系下的对象构造</h3><h4 id="3-1-编译器会对constructor做什么？"><a href="#3-1-编译器会对constructor做什么？" class="headerlink" title="3.1 编译器会对constructor做什么？"></a>3.1 编译器会对constructor做什么？</h4><p>像这样<strong>T object</strong>定义一个对象时,会调用constructor,其内部做的工作包括：</p><ul><li>（1）记录在member initialization list中的data members初始化操作会被放进constructor的函数本身，并以members的声明顺序为顺序。</li><li>（2）如果有一个member并没有出现在member initialization list中，但它有一个default constructor，那么该default constructor必须被调用。</li><li>（3）在那之前，如果class object有virtual functions, 它们必须被设定初值，指向适当的virtual tables.</li><li>（4）在那之前，所有上一层的base class constructors必须被调用，以base class生声明顺序为顺序(与member initialization list中的顺序没有关联)：</li><li><ul><li>如果base class被列于member initialization list中，那么任何明确指定的参数都应该被传递进去。、</li></ul></li><li><ul><li>如果base class没有被列于member initialization list中，而它有default constructor(或default memberwise copy constructor),那么就调用之。</li></ul></li><li><ul><li>如果base class是多重继承下的第二或后继的base class，那么this指针必须有所调整。</li></ul></li><li>（5）在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅</li><li><ul><li>如果class被列于member initialization list中，那么如果有任何显式指定的参数，都应该传递过去。若没有列于list之中，而class有一个default constructor，亦应该调用之</li></ul></li><li><ul><li>此外，class中的每一个virtual base class subobject的偏移位置(offset)必须在执行期可被存取</li></ul></li><li><ul><li>如果class object是最底层(most-derived)的class，其constructors可能被调用，某些用以支持这一行为的机制必须被放进来。</li></ul></li></ul><h4 id="3-2-一个实例说明编译器在对象构造的过程中所做的操作。"><a href="#3-2-一个实例说明编译器在对象构造的过程中所做的操作。" class="headerlink" title="3.2 一个实例说明编译器在对象构造的过程中所做的操作。"></a>3.2 一个实例说明编译器在对象构造的过程中所做的操作。</h4><p>有一个基类和其对应的派生类如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp;);     <span class="comment">//copy constructor</span></span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);   <span class="comment">//copy assignment operator</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Point();       <span class="comment">//virtual destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point _begin, _end;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    Line(<span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp;);</span><br><span class="line">    draw();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>（1）对于<strong>Line::Line(const Point&amp; begin, const Point&amp; end): _end(end), _begin(begin) {}</strong>,它会被编译器扩充并转换为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line* Line::Line(Line *<span class="keyword">this</span>, <span class="keyword">const</span> Point&amp; <span class="keyword">begin</span>, <span class="keyword">const</span> Point&amp; <span class="keyword">end</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="number">_</span><span class="keyword">begin</span><span class="variable">.Point</span>::Point(<span class="keyword">begin</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="number">_</span><span class="keyword">end</span><span class="variable">.Point</span>::Point(<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>（2）对于<strong>Line a;</strong>implicit Line destructor会被合成出来(如果Line派生自Point,那么合成出来的destructor将会是virtual。然而由于Line只是内带Point objects而非继承自Point，所以被合成出来的destructor只是nontrivial而已)。在其中，它的member class objects的destructor会被调用(与其构造的相反顺序):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Line::~Line(Line *<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_end.Point::~Point();</span><br><span class="line">    <span class="keyword">this</span>-&gt;_begin.Point::~Point();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(3) 对于<strong>Line b=a;</strong>implicit Line copy constructor会被合成出来，成为一个inline public member; </p></li><li>(4) 对于<strong>a=b;</strong>同样，implicit assignment operator会被合成出来，成为一个inline public member;</li></ul><h4 id="3-3-虚拟继承：constructor怎么处理virtual-base-class的构造？"><a href="#3-3-虚拟继承：constructor怎么处理virtual-base-class的构造？" class="headerlink" title="3.3 虚拟继承：constructor怎么处理virtual base class的构造？"></a>3.3 虚拟继承：constructor怎么处理virtual base class的构造？</h4><p>试想下面三种类派生情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d, <span class="keyword">public</span> Vertex&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PVertex</span> :</span> <span class="keyword">public</span> Vertex3d &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>Vertex的constructor必须调用Point的constructor。然而当Point3d和Vertex同为Vertetx3d的subobjects时，它们对Point constructor的调用操作一定不可以发生，取而代之的是，作为一个最底层的class，Vertex3d有责任将Point初始化，而更往后(往下)继承，则由PVertex来负责完成“被共享之Point subobject”的构造。<br>对于Vertex3d，当调用Point3d和Vertex的constructor时，可以通过如下扩展，把_most_derived参数设为flase从而不调用Point的构造函数。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在virtual base class情况下的constructor扩充内容</span></span><br><span class="line">Point3d* Point3d::Point3d(Point3d* <span class="keyword">this</span>, bool _most_derived, float x, float y, float z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_most_derived != <span class="literal">false</span>) <span class="keyword">this</span>-&gt;Point::Point(x, y);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point3d = _vtbl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vptr_Point3d_Point = _vpbl_Point3d_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>“virtual base class constructors的被调用”有着明确的定义：只有当一个完整的class object被定义出来时，它才会被调用；如果object只是某个完整object的subject，它就不会被调用。</strong></p><h4 id="3-4-vptr初始化语意学：什么时候设置vptr合适？"><a href="#3-4-vptr初始化语意学：什么时候设置vptr合适？" class="headerlink" title="3.4 vptr初始化语意学：什么时候设置vptr合适？"></a>3.4 vptr初始化语意学：什么时候设置vptr合适？</h4><p>constructor的执行算法通常如下：</p><ul><li>(1) 在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructors会被调用</li><li>(2) 上述完成之后，对象的vptrs被初始化，指向相关的virtual tables</li><li>(3) 如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。</li><li>(4) 最后，执行程序员所提供的代码。      </li></ul><h3 id="四、对象复制语意学-Object-Copy-Semantics"><a href="#四、对象复制语意学-Object-Copy-Semantics" class="headerlink" title="四、对象复制语意学(Object Copy Semantics)"></a>四、对象复制语意学(Object Copy Semantics)</h3><h4 id="4-1-怎样显式地拒绝将一个class-object指定给另一个class-object？"><a href="#4-1-怎样显式地拒绝将一个class-object指定给另一个class-object？" class="headerlink" title="4.1 怎样显式地拒绝将一个class object指定给另一个class object？"></a>4.1 怎样显式地拒绝将一个class object指定给另一个class object？</h4><p>如果想要禁止将一个class object指定给另一个class object，那么只要将copy assignment operator声明为private,并且不提供其定义即可。</p><h4 id="4-2-关于copy-assignment-operator。"><a href="#4-2-关于copy-assignment-operator。" class="headerlink" title="4.2 关于copy assignment operator。"></a>4.2 关于copy assignment operator。</h4><p>对于编译器来说，class如果有了bitwise copy语意，implicit copy assignment copy就会被视为无用的，从而也不会被合并出来。<br>一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意：</p><ul><li>（1）当class内含一个member object，而其class有一个copy assignment operator时</li><li>（2）当一个class的base class有一个copy assignment operator时</li><li>（3）当一个class声明了任何virtual functions(我们一定不要拷贝右端class object的vptr地址，因为它可能是一个derived class object)时</li><li>（4）当class继承自一个virtual base class(不论base class有没有copy operator)时<blockquote><p>copy assignment operator需要考虑的是需不需要被合成？什么时候被合成？当多重继承遇到virtual base class共享时，如何避免中间base class对最上层base class的subobject的多重拷贝？<br><strong>书籍作者的建议是不允许virtual base class的拷贝操作，尽量不要在任何virtual base class中声明数据。</strong></p></blockquote></li></ul><h2 id="五、析构语义学-Semantics-of-Destruction"><a href="#五、析构语义学-Semantics-of-Destruction" class="headerlink" title="五、析构语义学(Semantics of Destruction)"></a>五、析构语义学(Semantics of Destruction)</h2><h4 id="5-1-什么时候需要合成destructor"><a href="#5-1-什么时候需要合成destructor" class="headerlink" title="5.1 什么时候需要合成destructor?"></a>5.1 什么时候需要合成destructor?</h4><p>如果class没有定义destructor，那么只有在class内含的member object或base class拥有destructor的情况下，编译器才会自动合成一个出来。否则，destructor被视为不需要，也就不需被合成。</p><blockquote><p>事实上，我们应该拒绝那种被我们称为“对称策略”的奇怪想法：“你已经定义了一个constructor,所以你应该提供一个destructor也是天经地义的事”。我们应该因为“需要”而非“感觉”来提供destructor,更不要因为你不确定是否需要一个destructor，于是就提供它。（取自作者原话）</p></blockquote><h4 id="5-2-如果没有destructor-编译会在需要时自动合成，那如果有destructor-编译器又是怎么进行扩展的呢"><a href="#5-2-如果没有destructor-编译会在需要时自动合成，那如果有destructor-编译器又是怎么进行扩展的呢" class="headerlink" title="5.2 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?"></a>5.2 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?</h4><p>一个由程序员定义的destructor被扩展的方式类似constructors被扩展的方式，但顺序相反：</p><ul><li>（1） destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设(reset)</li><li>（2）如果object内含一个vptr，那么首先重设(reset)相关的virtual table</li><li>（3）如果class拥有member class objects。而后者拥有destructors，那么它们会以其声明的顺序的相反顺序被调用</li><li>（4）如果有任何直接的(上一层)nonvirtual base classes拥有destructors，它们会以其声明顺序的相反顺序被调用</li><li>（5）如果有任何virtual base classes拥有destructor，而目前讨论的这个class是最尾端(most-derived)的class，那么它们会以其原来的构造顺序的相反顺序被调用。</li></ul><p>就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实体：</p><ul><li>一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructors。</li><li>一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。</li></ul><p>一个object的生命结束于其destructor开始执行之时。由于每一个base class constructor都轮番被调用，所以derived object实际上变成了一个完整的object。例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象、一个Point3d对象，最后成为一个Point对象。当我们在destructor中调用member functiions时，对象的蜕变会因为vptr的重新设定而受到影响。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（四）Function语意学</title>
      <link href="/2018/11/19/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2018/11/19/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Function是c++中的又一大重要部分， 本章的的主题是Function语意学，主要是探究编译器对class中的static member function、nonstatic member function和virtual member function所做的处理，并用实际测试分析其使用对代码效率的影响。同时也会进一步探究“指向member function”的指针和Inline function的原理和效率。<br><a id="more"></a></p><hr><h3 id="一、Member-function的各种调用方式"><a href="#一、Member-function的各种调用方式" class="headerlink" title="一、Member function的各种调用方式"></a>一、Member function的各种调用方式</h3><h4 id="1-1-Nonstatic-Member-Function是怎么被调用的？"><a href="#1-1-Nonstatic-Member-Function是怎么被调用的？" class="headerlink" title="1.1 Nonstatic Member Function是怎么被调用的？"></a>1.1 Nonstatic Member Function是怎么被调用的？</h4><p>C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。<br>在c++中，member function会被被编译器转化为nonmember function，然后执行期被调用，转化过程如下：</p><ul><li><ol><li>改写函数原型，以安插一个额外的参数(this指针)到member function中，用以提供一个存取管道，使class object得以将此函数调用。</li></ol></li><li><ol start="2"><li>将每一个“对nonstatic data member的存取操作”改为经由this指针来存取。</li></ol></li><li><ol start="3"><li>将member function重新写成一个外部函数。将函数名称经过“mangling”处理，使它在程序中称为独一无二的词汇。</li></ol></li></ul><h4 id="1-2-编译器为什么要进行名称处理（name-mangling）？怎么处理？"><a href="#1-2-编译器为什么要进行名称处理（name-mangling）？怎么处理？" class="headerlink" title="1.2 编译器为什么要进行名称处理（name mangling）？怎么处理？"></a>1.2 编译器为什么要进行名称处理（name mangling）？怎么处理？</h4><p>继承所带来的重复变量名、函数的重载等都需要编译器能唯一识别，这时候就需要就需要进行名称处理。一般而言，member的名称前面会加上class的名称，形成独一无二的命名，有时候member function的名称也需要加上参数类型等。    </p><h4 id="1-3-Virtual-Member-Functions是如何被调用的？"><a href="#1-3-Virtual-Member-Functions是如何被调用的？" class="headerlink" title="1.3 Virtual Member Functions是如何被调用的？"></a>1.3 Virtual Member Functions是如何被调用的？</h4><p>编译器内部会对virtual member function进行如下转换：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;f();   //f()为virtual member function</span><br><span class="line"></span><br><span class="line">（*ptr-&gt;vptr[<span class="string">1</span>](<span class="link">ptr</span>);//内部转化结果</span><br></pre></td></tr></table></figure></p><ul><li>vptr表示编译器产生的指针，指向virtual table。  </li><li>1 是virtual table slot的索引值，关联到normalize()函数。   </li><li>第二个ptr表示this指针。  </li></ul><h4 id="1-4-Static-Member-Functions有什么特性？如何被调用的？"><a href="#1-4-Static-Member-Functions有什么特性？如何被调用的？" class="headerlink" title="1.4 Static Member Functions有什么特性？如何被调用的？"></a>1.4 Static Member Functions有什么特性？如何被调用的？</h4><p>static member functions的主要特性是它没有this指针。以下的次要特性统统根源于其主要特性：</p><ul><li>它不能够直接存取其class中的nonstatic members</li><li>它不能够被声明为const、volatile或virtual</li><li>它不需要经由class object才被调用，虽然大部分时候它是这样被调用的。    </li></ul><p>如果取一个static member function的地址，获得的将是其在内存中的位置，也就是其地址。由于static member function没有this指针，所以其地址的类型并不是一个“指向class member of function的指针”，而是一个“nonmember函数指针”。</p><h3 id="二、Virtual-Member-function"><a href="#二、Virtual-Member-function" class="headerlink" title="二、Virtual Member function"></a>二、Virtual Member function</h3><h4 id="2-1-什么是多态？"><a href="#2-1-什么是多态？" class="headerlink" title="2.1 什么是多态？"></a>2.1 什么是多态？</h4><p>C++中，多态表示以“一个public base class 的指针（或reference)，寻址出一个derived class object”。</p><blockquote><p>runtime type identification(RTTI)</p></blockquote><h4 id="2-2-为了能方便class指针在执行期找到对应的函数实例，就需要编译器决定是否需要给class添加额外信息，那么，到底何时才需要这份信息？"><a href="#2-2-为了能方便class指针在执行期找到对应的函数实例，就需要编译器决定是否需要给class添加额外信息，那么，到底何时才需要这份信息？" class="headerlink" title="2.2 为了能方便class指针在执行期找到对应的函数实例，就需要编译器决定是否需要给class添加额外信息，那么，到底何时才需要这份信息？"></a>2.2 为了能方便class指针在执行期找到对应的函数实例，就需要编译器决定是否需要给class添加额外信息，那么，到底何时才需要这份信息？</h4><p>答案是在必须支持某种形式之“执行期多态”的时候，要鉴定哪些classes展现多态特性，就需要额外的执行期信息。<br>识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtual function。只要class拥有一个virtual function，它就需要这份额外的执行期信息。</p><h4 id="2-3-什么样的额外信息是我们需要存储起来的？"><a href="#2-3-什么样的额外信息是我们需要存储起来的？" class="headerlink" title="2.3 什么样的额外信息是我们需要存储起来的？"></a>2.3 什么样的额外信息是我们需要存储起来的？</h4><p>在实现上，编译器可以做到在每一个多态对象的class object身上增加两个members:     </p><ul><li>一个字符串或数字，表示class的类型</li><li>一个指针，指向表格，表格中带有程序的virtual function的执行期地址。</li></ul><h4 id="2-4-执行期如何找到对应的virtual-function地址？"><a href="#2-4-执行期如何找到对应的virtual-function地址？" class="headerlink" title="2.4 执行期如何找到对应的virtual function地址？"></a>2.4 执行期如何找到对应的virtual function地址？</h4><p>执行期要做的，只是在特定的virtual table slot中激活virtual function。这些active virtual function包括：</p><ul><li>这一class所定义的函数实例。它会改写(overriding)一个可能存在的base class virtual function函数实例。</li><li>继承自base class的函数实例。这是在derived class决定不改写virtual function时才会出现的情况</li><li>一个pure_virtual_called()函数实例，它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数(有时候会用到)。  </li></ul><p>每一个virtual function都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的virtual function的关系。执行期通过vptr和对应的slot获得对应的virtual function地址并进行调用。</p><blockquote><p>在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承中，对virtual function的支持就没有那么美好了。</p></blockquote><h4 id="2-5-多重继承下virtual-function编译器需要做什么？"><a href="#2-5-多重继承下virtual-function编译器需要做什么？" class="headerlink" title="2.5 多重继承下virtual function编译器需要做什么？"></a>2.5 多重继承下virtual function编译器需要做什么？</h4><p>当把一个从heap中配置而得的Derived对象的地址，指定给一个Base2指针时，编译器需要如下处理：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> <span class="type">Derived</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器会做的处理</span></span><br><span class="line">Derived *tmp = <span class="keyword">new</span> <span class="type">Derived</span>;</span><br><span class="line">Base2 *pbase2 = tmp ? tmp + sizeof(Base1) : <span class="type">0</span>;<span class="comment">//转移以支持第二个base class</span></span><br></pre></td></tr></table></figure></p><p>当要删除pbase2所指的对象时，指针必须被再一次调整，以求再一次指向Derived对象的起始处(推测它还指向Derived对象)。然而上述的offset加法却不能够在编译时期直接设定，因为pbase2所指的真正对象只有在执行期才能确定。</p><h4 id="2-6-多重继承下virtual-function带来的负担是什么？"><a href="#2-6-多重继承下virtual-function带来的负担是什么？" class="headerlink" title="2.6 多重继承下virtual function带来的负担是什么？"></a>2.6 多重继承下virtual function带来的负担是什么？</h4><p>在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的个数(因此，单一继承将不会有额外的virtual tables)。<br>针对每一个virtual tables，Derived对象中有对应的vptr。vptrs将在constructor(s)中被设定初值。</p><h4 id="2-7-Thunk技术是什么？用来做什么？"><a href="#2-7-Thunk技术是什么？用来做什么？" class="headerlink" title="2.7 Thunk技术是什么？用来做什么？"></a>2.7 Thunk技术是什么？用来做什么？</h4><p>offset的大小，以及把offset加到this指针上头的那一小段<strong>程序代码</strong>，必须经由编译器在某个地方插入。较有效率的解决办法是利用所谓的thunk。所谓thunk是以小段assembly代码，用来：</p><ul><li>(1) 以适当的offset值调整this指针</li><li>(2) 跳到virtual function去。<br>Thunk技术允许virtual table slot继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。Slots中的地址可以直接指向virtual function，也可以指向一个相关的thunk(如果需要调整this指针的话)。</li></ul><h4 id="2-8-哪些情况，第二或后继的base-class会影响对virtual-functions的支持？"><a href="#2-8-哪些情况，第二或后继的base-class会影响对virtual-functions的支持？" class="headerlink" title="2.8 哪些情况，第二或后继的base class会影响对virtual functions的支持？"></a>2.8 哪些情况，第二或后继的base class会影响对virtual functions的支持？</h4><p>有以下三种情况，第二或后继的base class会影响对virtual functions的支持。</p><ul><li><p>第一种情况是，通过一个”指向第二个base class”的指针，调用derived class virtual function。例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Derived::~Derived</span></span><br><span class="line"><span class="comment">//ptr指向Derived对象中的Base2 subobject；</span></span><br><span class="line"><span class="comment">//为了能够正确执行，ptr必须调整指向Derived对象的起始处。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></li><li><p>第二种情况是第一种情况的变化，通过一个“指向derived class”的指针，调用第二个base class中一个继承而来的virtual function。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> <span class="type">Derived</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Base2::mumble()</span></span><br><span class="line"><span class="comment">//在此情况下，derived class指针必须再次调整，以指向第二个base subobject。</span></span><br><span class="line">pder-&gt;mumble();</span><br></pre></td></tr></table></figure></li><li><p>第三种情况发生于一个语言扩充性质之下：允许一个virtual function的返回值类型有所变化，可能是base type，也可能是publicly derived type。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb = <span class="keyword">new</span> <span class="type">Derived</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Derived * Derived::clone()</span></span><br><span class="line"><span class="comment">//当进行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址</span></span><br><span class="line"><span class="comment">//于是clone()的Derived版会被调用；</span></span><br><span class="line"><span class="comment">//它会传回一个指针，指向一个新的Derived对象，该对象的地址在被指定给pb2之前</span></span><br><span class="line"><span class="comment">//必须先经过调整，以指向Base2 subobject。</span></span><br><span class="line">Base2 *pb2 = pb-&gt;clone();</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-9-虚拟继承下virtual-functions呢？"><a href="#2-9-虚拟继承下virtual-functions呢？" class="headerlink" title="2.9 虚拟继承下virtual functions呢？"></a>2.9 虚拟继承下virtual functions呢？</h4><p>当一个virtual base class从另一个virtual base class派生而来，并且两者都支持virtual functions和nonstatic data members时，编译器对于virtual base class的支持简直就像进了迷宫一样。<strong>不要在一个virtual base class中声明nonstatic data members</strong>，否则你将距离复杂的深渊越来越近。</p><h3 id="三、函数的效率"><a href="#三、函数的效率" class="headerlink" title="三、函数的效率"></a>三、函数的效率</h3><p>nonmemeber、static member或nonstatic member函数都被转换为完全相同形式，所以三者效率完全相同。<br>导入virtual function之后，class constructor将获得参数以设定virtual table指针。所以每多一层继承，就会多增加一个额外的vptr设定。</p><blockquote><p>constructor的额外操作在多次调用的情况下可能会拖低效率，减少常用函数中的局部对象可以在一定程度上提高效率。</p></blockquote><h2 id="四、指向Member-Function的指针"><a href="#四、指向Member-Function的指针" class="headerlink" title="四、指向Member Function的指针"></a>四、指向Member Function的指针</h2><h4 id="4-1-指向nonstatic-member-function的指针是如何工作的？"><a href="#4-1-指向nonstatic-member-function的指针是如何工作的？" class="headerlink" title="4.1 指向nonstatic member function的指针是如何工作的？"></a>4.1 指向nonstatic member function的指针是如何工作的？</h4><p>取一个nonstatic data member的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。然而这个值也是不完全的。它也需要被绑定于某个class object的地址上，才能够通过它调用该函数。所有的nonstatic member functions都需要对象的地址(以参数this指出)。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double  ( <span class="symbol">Point::</span>*pmf)(); <span class="comment">//member function的指针名</span></span><br><span class="line">pmf = &amp;<span class="symbol">Point::</span>y; <span class="comment">//获得对应的member function地址</span></span><br><span class="line">(origin.*coord)(); <span class="comment">//调用方式,origin是一个object,指针(ptr-&gt;*corrd)();</span></span><br><span class="line">(coord)(<span class="variable">&amp;origin</span>); <span class="comment">//编译器内部转化</span></span><br></pre></td></tr></table></figure></p><h4 id="4-2-指向nonstatic-member-function的指针会带来负担吗？"><a href="#4-2-指向nonstatic-member-function的指针会带来负担吗？" class="headerlink" title="4.2 指向nonstatic member function的指针会带来负担吗？"></a>4.2 指向nonstatic member function的指针会带来负担吗？</h4><p>看情况，如果并不用于virtual function、多重继承、virtual base class等情况的话，并不会比使用一个“nonmember function指针”的成本高。<br>但上述三种情况对于“member function指针”的类型以及调用都太过于复杂。</p><h4 id="4-3-虚拟机制能在使用“指向member-function的指针”的情况下运行吗？如果能，又是怎样实现的？"><a href="#4-3-虚拟机制能在使用“指向member-function的指针”的情况下运行吗？如果能，又是怎样实现的？" class="headerlink" title="4.3 虚拟机制能在使用“指向member function的指针”的情况下运行吗？如果能，又是怎样实现的？"></a>4.3 虚拟机制能在使用“指向member function的指针”的情况下运行吗？如果能，又是怎样实现的？</h4><p>对一个nonstatic member function取其地址，将获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，取其地址所能获得的只是其在virtual table中的索引值。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;Point::x();  <span class="comment">//x()为非虚函数，得其内存地址 </span></span><br><span class="line">&amp;Point::z();  <span class="comment">//z()为虚函数，得其索引值</span></span><br><span class="line"></span><br><span class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf])(ptr);<span class="comment">//pmf指向virtual函数时的调用方式</span></span><br></pre></td></tr></table></figure></p><p>为了使pmf能支持上述两种情况，编译器必须定义函数指针使它能够(1)含有两种数值,(2)更重要的是其数值可以被区别代表内存地址还是virtual table中的索引值。</p><h4 id="4-4-在多重继承下，指向Member-Functions的指针如何工作？"><a href="#4-4-在多重继承下，指向Member-Functions的指针如何工作？" class="headerlink" title="4.4 在多重继承下，指向Member Functions的指针如何工作？"></a>4.4 在多重继承下，指向Member Functions的指针如何工作？</h4><p>为了让指向member functions的指针也能够支持多重继承和虚拟继承，Stroustrup设计了下面一个结构体：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_mptr</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int delta; <span class="regexp">//delta</span>字段表示this指针的offset值</span><br><span class="line">    int index; <span class="regexp">//virtual</span> table索引,不用时设为-<span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        protofunc faddr; <span class="regexp">//nonvirtual</span> member function地址</span><br><span class="line">        int v_offset; <span class="regexp">//v</span>_offset字段放的是一个virtual base <span class="class"><span class="keyword">class</span>的<span class="title">vptr</span>位置。</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(ptr-&gt;*pmf)();<span class="regexp">//</span>原始调用</span><br><span class="line">/<span class="regexp">/ 编译器转换</span></span><br><span class="line"><span class="regexp">(pmf.index &lt; 0) ? ( *pmf.faddr )( ptr) : (* ptr-&gt;vptr[pmf.index](ptr));</span></span><br></pre></td></tr></table></figure></p><p>Microsoft就供应了三种风味，以减少不必要的字段：</p><ul><li><ol><li>一个单一继承实例(其中带有vcall thunk地址或是faddr)</li></ol></li><li><ol start="2"><li>一个多重继承实例(其中带有faddr和delta、vcall thunk地址)</li></ol></li><li><ol start="3"><li>一个虚拟继承实例(其中带有四个members)</li></ol></li></ul><h3 id="五、Inline-Functions"><a href="#五、Inline-Functions" class="headerlink" title="五、Inline Functions"></a>五、Inline Functions</h3><h4 id="5-1-Inline-Function有什么优点？"><a href="#5-1-Inline-Function有什么优点？" class="headerlink" title="5.1 Inline Function有什么优点？"></a>5.1 Inline Function有什么优点？</h4><p>为了处理类内部数据，有时候会用friend function进行操作。然而如果我们将这些函数声明为inline，我们就可以保持直接存取members 的那种高效率，同时也能兼顾函数的封装性，此外，也不用再用friend。</p><h4 id="5-2-Inline-Function什么时候被展开？"><a href="#5-2-Inline-Function什么时候被展开？" class="headerlink" title="5.2 Inline Function什么时候被展开？"></a>5.2 Inline Function什么时候被展开？</h4><p>编译器会决定是否将Inline Functiong按照一个expression进行展开。处理一个inline函数，有两个阶段：</p><ul><li><ol><li>分析函数定义，以决定函数的“intrinsic inline ability”。“intrinsic” (本质的，固有的)一词在这里意指“与编译器相关”，如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个static函数，并在“被编译模块”内产生对应的函数语义。</li></ol></li><li><ol start="2"><li>真正的inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作(evaluation)以及临时性对象的管理。<br>同样在扩展点上，编译器将决定这个调用是否“不可为inline”。</li></ol></li></ul><h4 id="5-3-Inline-Function如何处理形式参数？"><a href="#5-3-Inline-Function如何处理形式参数？" class="headerlink" title="5.3 Inline Function如何处理形式参数？"></a>5.3 Inline Function如何处理形式参数？</h4><p>扩展Inline function时，每一个形式参数都会被对应的实际参数取代。如果实际参数是一个常量表达式，我们可以在替换之前先完成其求值操作；后继的inline替换，就可以把常量直接“绑”上去。如果既不是常量表达式，也不是带有副作用的表达式，那么就直接替换之。<br>例如：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> bar()&#123;</span><br><span class="line">    <span class="keyword">int</span> minval;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">    </span><br><span class="line">    minval = <span class="built_in">min</span>(val1, val2);  <span class="comment">/*(1)*/</span> </span><br><span class="line">    minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);  <span class="comment">/*(2)*/</span></span><br><span class="line">    minval = <span class="built_in">min</span>(foo(), bar() + <span class="number">1</span>); <span class="comment">/*(3)*/</span></span><br><span class="line">    <span class="built_in">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(1) 处形参无副作用，直接展开：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">minval = val1 &lt; val2 ? val1 :</span> val2<span class="comment">; </span></span><br><span class="line">```     </span><br><span class="line">(<span class="number">2</span>) 处那一行直接拥抱常量：</span><br><span class="line">``` </span><br><span class="line">minval = <span class="number">1024</span><span class="comment">;  </span></span><br><span class="line">```      </span><br><span class="line"><span class="symbol">(3) 处那一行则引发参数的副作用，它需要导入一个临时对象，以避免重复求值:</span></span><br></pre></td></tr></table></figure></p><p>int t1;<br>int t2;<br>minval = (t1 = foo()), (t2 = bar() + 1),t1 &lt; t2 ? t1 : t2;<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### <span class="number">5.4</span> Inline Function如何处理局部变量？</span><br><span class="line">一般而言，<span class="keyword">inline</span>函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。</span><br><span class="line">如果<span class="keyword">inline</span>函数以单一表达式扩展多次，则每次扩展都需要自己的一组局部变量。如果<span class="keyword">inline</span>函数以分离的多个式子被扩展多次，那么只需一组局部变量，就可以重复使用(译注：因为它们被放在一个封闭区段中，有自己的scope)</span><br></pre></td></tr></table></figure></p><p>minval=min(val1,val2)+min(foo(),foo()+1);//这就是单一表达式，进行两次扩展，多出两组变量<br><code>`</code></p><h4 id="5-5-Inline-Function的缺点。"><a href="#5-5-Inline-Function的缺点。" class="headerlink" title="5.5 Inline Function的缺点。"></a>5.5 Inline Function的缺点。</h4><p>一个inline函数如果被调用太多次，会产生大量的扩展码，使程序大小暴涨。参数带有副作用或者以一个单一表达式做多重调用、或者其本身有多个局部变量，都会产生大量局部变量，当然，编译器有可能帮你处理，也可能不会。     </p><p><strong>对于既要安全又要效率的程序，inline函数提供了一个强有力的工具。然而，与non-inline函数比起来，他们需要更加小心地处理。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（三）Data语意学</title>
      <link href="/2018/11/18/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/11/18/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。<br><a id="more"></a></p><h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote><p>本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。</p></blockquote><hr><p>参考书籍及链接：《深度探索c++对象模型》    </p><hr><h3 id="一、本章基础"><a href="#一、本章基础" class="headerlink" title="一、本章基础"></a>一、本章基础</h3><h4 id="1-1-空类对象的大小是多少？"><a href="#1-1-空类对象的大小是多少？" class="headerlink" title="1.1 空类对象的大小是多少？"></a>1.1 空类对象的大小是多少？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; &#125;;<span class="comment">//空类</span></span><br></pre></td></tr></table></figure><p>对于空类，它有一个隐藏的1byte大小，那个被编译器安插进去的一个char,这使得这一class的两个objects得以在内存中配置独一无二的地址。</p><h4 id="1-2-class-object的size会受到哪些因素的影响？"><a href="#1-2-class-object的size会受到哪些因素的影响？" class="headerlink" title="1.2 class object的size会受到哪些因素的影响？"></a>1.2 class object的size会受到哪些因素的影响？</h4><p>会影响class object的size的因素有如下三个，编译器：</p><ul><li><ol><li>语言本身所造成的额外负担：当语言支持virtual base classes时，就会导致一些额外负担。需要一个指针，它或者指向virtual base class subobject,或者指向一个相关的表格，表格用于存储subobject地址或偏移值。</li></ol></li><li><ol start="2"><li>编译器对于特殊情况所提供的优化处理：Virtual base class subobject的1 byte大小也会出现在derived class上。</li></ol></li><li><ol start="3"><li>Alignment（边界对齐）的限制：在大部分的机器上，聚合的结构体大小会受到alignment的限制，使他们能够更有效率地在内存中被存取。比如32机器字上就是4的整数倍。</li></ol></li></ul><h4 id="1-3-各种类型data-member的存放。"><a href="#1-3-各种类型data-member的存放。" class="headerlink" title="1.3 各种类型data member的存放。"></a>1.3 各种类型data member的存放。</h4><p>nonstatic直接放在class object之中。static data member放置在程序的一个global data segment中，不会影响个别class object的大小。无论class产生多少个object,甚至是0个，其static data members永远也只存在一份实例。<strong>但是一个template classs的static data members的行为稍有不同。</strong></p><h3 id="二、Data-member的绑定"><a href="#二、Data-member的绑定" class="headerlink" title="二、Data member的绑定"></a>二、Data member的绑定</h3><h4 id="2-1-member-function取用的是global还是local-data-member"><a href="#2-1-member-function取用的是global还是local-data-member" class="headerlink" title="2.1 member function取用的是global还是local data member?"></a>2.1 member function取用的是global还是local data member?</h4><p>当member funtion取用Data时，优先考虑member data,人们称这种情况为“member rewriting rule”，意思是对于member functions本身的分析，会直到整个class的声明都出现了才开始。在一个inline member function躯体之内的一个data member绑定操作，会在整个class声明之后才发生。</p><blockquote><p>以前人们提倡两种程序设计风格，即将所有的data members放在class声明起始处，或者把所有的inline  function都放在class声明之外。就是为解决绑定问题，但这种情况在c++ 2.0之后已经解决了。 </p></blockquote><h4 id="2-2-member-function的argument-list的情况又是怎么样的呢"><a href="#2-2-member-function的argument-list的情况又是怎么样的呢" class="headerlink" title="2.2 member function的argument list的情况又是怎么样的呢?"></a>2.2 member function的argument list的情况又是怎么样的呢?</h4><p>与取用data member不同的是，argument list中的名称还是会在它们第一次 遭遇时被适当地决议（resolved）完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span> </span>&#123; _val=val;&#125; <span class="comment">//length被决议为global</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;<span class="comment">//这样的声明将使先前的参考操作不合法</span></span><br><span class="line">    length _val;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>虽然编译器能处理，但还是提倡一种防御性程序风格：即总是把“nested（嵌套的） type声明”放在class的起始处。    </p></blockquote><h3 id="三、Data-member的布局"><a href="#三、Data-member的布局" class="headerlink" title="三、Data member的布局"></a>三、Data member的布局</h3><h4 id="3-1-Data-member是怎样被放置的？"><a href="#3-1-Data-member是怎样被放置的？" class="headerlink" title="3.1 Data  member是怎样被放置的？"></a>3.1 Data  member是怎样被放置的？</h4><p>关于data member的布局，记住以下三点：</p><ul><li>nonstatic data members在class object中的排列顺序和其被声明的顺序一样，任何中间介入的static data members都不会被放进对象布局之中。       </li><li>C++ standard允许编译器将多个access sections(也就是private、public、protected等区段)之中的data members整体自由排列，不必在乎他们的出现在class中的声明顺序（连续的两个privata也算两个section）。 </li><li>编译器还可能会合成一些内部使用的data members，以支持整个对象模型，vptr就是这样的东西，当前所有的编译器都把它安插在每一个“内含virtual function之class”的object内。</li></ul><h3 id="四、Data-member的存取"><a href="#四、Data-member的存取" class="headerlink" title="四、Data member的存取"></a>四、Data member的存取</h3><h4 id="4-1-经由一个class-object和一个指针存取data-member，有重大差异吗？"><a href="#4-1-经由一个class-object和一个指针存取data-member，有重大差异吗？" class="headerlink" title="4.1 经由一个class object和一个指针存取data member，有重大差异吗？"></a>4.1 经由一个class object和一个指针存取data member，有重大差异吗？</h4><p>答案是显然的，这跟data member的类型和class的继承等都有关系，分如下两种情况讨论：</p><ul><li><p><strong>data member 为 static</strong><br>static data members会被编译器提出于class之外，并被视为一个global变量(但只在class生命范围内可见)。每一个static data member只有一个实例，存放在程序的data segment之中，通过一个指针和通过一个对象来存取data member都是一样的。  </p><p>若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其class member的指针，因为static member并不内含在一个class object之中。   </p><p>如果有两个classes，每一个都声明了一个同名的static member，编译器就会暗中对每一个static data member编码(对于这种手法有个很美的名称：name-mangling)，以获得一个独一无的程序识别代码。</p></li><li><p><strong>data member 为 nonstatic</strong><br>Nonstatic data members直接存放在每一个class object之中。只有经过class object才能存取它们（implicit 存取如this指针）。欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置(offset)。     </p><p>每一个nonstatic data member的偏移位置(offset)在编译时期即可获知，甚至如果member属于一个base class subobject(派生自单一或多重继承串链)也是一样的。因此，存取一个nonstatic data member，其效率和存取一个C struct member或一个nonderived class的member是一样的。</p><p>但是如果该data member是一个virtual base class 的member,那么通过<strong>指针</strong>的存取速度会稍慢一点。（指针的真正class type 只有在执行器才真正确定）。  </p><blockquote><p>对于静态成员来说没有区别，对于非静态成员来说，指针会慢一点，其需要取对象的地址，并处理偏移才能访问到访问到目标。  </p></blockquote></li></ul><h3 id="五、“继承”与Data-Member"><a href="#五、“继承”与Data-Member" class="headerlink" title="五、“继承”与Data Member"></a>五、“继承”与Data Member</h3><p>C++ standard未强制指定derived class members和base class members的排列顺序，理论上编译器可以自由安排之。在大部分编译器上头，base class members总是先出现，但属于virtual base class的除外。“继承”会对Data Member的布局有什么影响？接下来分四种情况进行讨论。</p><h4 id="5-1-第一种情况：只要继承不要多态。"><a href="#5-1-第一种情况：只要继承不要多态。" class="headerlink" title="5.1 第一种情况：只要继承不要多态。"></a>5.1 第一种情况：只要继承不要多态。</h4><p>这种情况不会存储时间上的额外负担，由于base class和derived class的objects都是从相同的地址开始，其差异只在于derived object 比较大，用以容纳自建的nonstatic data members，把一个derived class object指定给base class 的指针或引用，并不需要编译器去调停或修改地址，可以提供了最佳执行效率。</p><h4 id="5-2-第二种情况：加上多态。"><a href="#5-2-第二种情况：加上多态。" class="headerlink" title="5.2 第二种情况：加上多态。"></a>5.2 第二种情况：加上多态。</h4><p>加上virtual function接口后，弹性增加了，但也同时增加了空间和存取时间上的额外负担，如何取舍，视多态程序所带来的利益。可能带来的额外负担如下：</p><ul><li>导入一个和virtual table ，用来存储它所声明的每一个virtual functions的地址。再加上一两个slots(type_info)。</li><li>在每一个class object中导入一个vptr,提供执行期的链接，使每一个object能够找到相应的virtual table。</li><li>加强constructor，使它能够为vptr设定初始值，让它指向class所对应的virtual table。</li><li>加强destructor，使它能够消抹“指向class 相关virtual table”的vptr。</li></ul><h4 id="5-3-第三种情况：多重继承。"><a href="#5-3-第三种情况：多重继承。" class="headerlink" title="5.3 第三种情况：多重继承。"></a>5.3 第三种情况：多重继承。</h4><p>对于单一继承，如果没有virtual function，那么编译器就不需要做其他工作;但如果base class没有virtual function而derived class有，并且vptr放在object首部，那么当把一个derived object转换为其base object时，就需要编译器对vptr进行调整。在既是多重继承又是虚拟继承的情况下，编译器的需要做的会更多。<br>对一个多重派生对象，将其地址指定给“最左端(也就是第一个)base class的指针”，情况将和单一继承时相同，因为二者都指向相同的起始地址。至于第二个或后继的base class的地址指定操作，则需要将地址修改为：加上(或减去)介于中间的base class subobjects大小。比较需要注意的是，如果在取drived class object的地址时进行偏移计算时，若其为指针，就需要判断其是否为0，若为0则基类object的地址也应为0。<strong>当然，这些都是编译器的工作，我们需要了解，但不需要自己去实现。</strong></p><blockquote><p>如果要存取第二个(或后继)base class中的一个data member会是怎样的情况？需要付出额外的成本吗？ 不，members的位置在编译期就固定了，因此，存取members只是一个简单的offset运算，就像单一继承一样简单，不管是经由一个指针，一个reference或是一个object来存取。</p></blockquote><h4 id="5-4-第四种情况：虚拟继承。"><a href="#5-4-第四种情况：虚拟继承。" class="headerlink" title="5.4 第四种情况：虚拟继承。"></a>5.4 第四种情况：虚拟继承。</h4><p>虚拟继承的出现是为了避免多个相同base class subobject的出现，将其只保留一份，从而减少空间浪费。<br>class如果含有一个或多个virtual base class subobjects将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，总是能有固定的offset，这部分可以被直接存取，至于共享部分，所表现的就是virtual base class subobject ，这个部分数据，其位置因为每次派生操作而有变化，所以只能间接存取。</p><blockquote><p>一般而言，virtual base class最有效的一种运用形式就是：一个抽象的virtual base class，没有任何data members。</p></blockquote><blockquote><p>程序员如果只关心起程序效率，应该实际测试，不能光凭推论、常识判断或假设。参考书籍作者所做的测试表明，虚拟继承所造成确实会严重影响data member的存取效率。</p></blockquote><h3 id="六、指向Data-members的指针-Pointer-to-Data-Members"><a href="#六、指向Data-members的指针-Pointer-to-Data-Members" class="headerlink" title="六、指向Data members的指针(Pointer to Data Members)"></a>六、指向Data members的指针(Pointer to Data Members)</h3><h4 id="6-1-如果获取Data-member的偏移值？偏移值应该为多少？"><a href="#6-1-如果获取Data-member的偏移值？偏移值应该为多少？" class="headerlink" title="6.1 如果获取Data member的偏移值？偏移值应该为多少？"></a>6.1 如果获取Data member的偏移值？偏移值应该为多少？</h4><p>通过如（&amp;Point3d::z）这样的操作可以获得data member的偏移值。实际测试表明所获得的offset比预想大1，这是为什么？实际上这样做的目的是为了区分一个“没有指向任何data member”的指针，和一个指向“第一个data member”的指针的情况。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;<span class="comment">//“没有指向任何data member”的指针</span></span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::x;<span class="comment">//指向“第一个data member”的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1 == p2) <span class="comment">//如何区分?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 &amp; p2 contain the same value --"</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" they must address the same member!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，不论编译器或使用者都必须记住，在真正使用该值以指出一个member之前，请先减掉1。</p><h4 id="6-2-“指向Member的指针”对数据的存取有什么影响？"><a href="#6-2-“指向Member的指针”对数据的存取有什么影响？" class="headerlink" title="6.2 “指向Member的指针”对数据的存取有什么影响？"></a>6.2 “指向Member的指针”对数据的存取有什么影响？</h4><p>无继承时，指向member的指针对数据的存取操作，首先需要计算offset-1,其次具体的object需要用offset计算地址，会极大地降低效率，但目前的一些编译器提供了对应的优化，可以使其像直接通过对象取值一下快速。<br>有继承时，data member是直接放在class object中的，理论上不会影响代码的效率，但继承的使用会妨碍优化的效果。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（二）构造函数语意学</title>
      <link href="/2018/11/17/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/11/17/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章的的主题是构造函数语意学，主要是讨论constructor如何工作，以及它什么时候被合成，同时挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。<br><a id="more"></a></p><hr><h3 id="一、Default-Constructor的构造操作"><a href="#一、Default-Constructor的构造操作" class="headerlink" title="一、Default Constructor的构造操作"></a>一、Default Constructor的构造操作</h3><h4 id="1-1-什么时候才会合成一个default-construct呢？"><a href="#1-1-什么时候才会合成一个default-construct呢？" class="headerlink" title="1.1 什么时候才会合成一个default construct呢？"></a>1.1 什么时候才会合成一个default construct呢？</h4><p>   答案是当编译器需要的时候，default constructor会被合成出来，只执行编译器所需要的任务。另外要注意程序的需要和编译器的需要之间的区别，如果程序有需要，那是程序员的责任，就需要自己实现constructor。<br>   对于class X，如果没有任何user-declared constructor，那么会有一个default constructor被隐式(implicitly)声明出来…一个被隐式声明出来的default constructor将是一个trivial(浅薄而无能，没啥用的)constructor…<br>   一个nontrivial default constructor在ARM的术语中就是编译器需要的那种，必要的话由编译器合成出来。下面4小节分别讨论nontrivial default constructor的4种情况</p><h4 id="1-2-几种对象构建时的区别。"><a href="#1-2-几种对象构建时的区别。" class="headerlink" title="1.2 几种对象构建时的区别。"></a>1.2 几种对象构建时的区别。</h4><p>   Global objects的内存保证会在程序启动的时候被清0。Local objects配置于程序的堆栈中，heap objects配置于自由空间，都不一定会被清零，它们的内容将是内存上次被使用的遗迹。</p><h4 id="1-3-第一种情况：“带有Default-Constructor”的member-class-object"><a href="#1-3-第一种情况：“带有Default-Constructor”的member-class-object" class="headerlink" title="1.3 第一种情况：“带有Default Constructor”的member class object"></a>1.3 第一种情况：“带有Default Constructor”的member class object</h4><p>如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是“nontrivial”，编译器为该class合成出一个default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。</p><p>编译器的处理是：如果一个class A内含一个或者一个以上member class objects，那么class A的每一个constructor必须调用每一个member classes 的default constructor。编译器会扩张已存在的constructors,在其中安插一些代码，使得user code在被执行之前，先调用必要的default constructors。<strong>调用顺序与member objects在class中的声明次序一致</strong>。</p><h4 id="1-4-第二种情况：“带有Default-constructor”的base-class。"><a href="#1-4-第二种情况：“带有Default-constructor”的base-class。" class="headerlink" title="1.4 第二种情况：“带有Default constructor”的base class。"></a>1.4 第二种情况：“带有Default constructor”的base class。</h4><p>如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。对于一个后继派生的class而言，这个合成的constructor和一个“被显式提供的default constructor”并没有差异。</p><blockquote><p>注意一点，如果有constructor,但没有default constructor,那就会对每一个constructors进行扩充。如果亦存在Member Class Object，那些default constructor也会在base class constructor都被调用之后调用。</p></blockquote><h4 id="1-5-第三种情况：“带有一个Virtual-Funtion”的class。"><a href="#1-5-第三种情况：“带有一个Virtual-Funtion”的class。" class="headerlink" title="1.5 第三种情况：“带有一个Virtual Funtion”的class。"></a>1.5 第三种情况：“带有一个Virtual Funtion”的class。</h4><p>如果class声明(或继承)一个virtual function，编译器也需要合成出default constructor或扩充construtor。下面两个扩张行动会在编译期间发生：</p><ul><li>一个virtual function table(在cfront中被称为vtbl)会被编译期产生出来，内放class的virtual functions地址。</li><li>在每一个class object中，一个额外的pointer member(也就是vptr)会被编译期合成出来，内含相关之class vtbl的地址。</li></ul><blockquote><p>编译器会为每一个含有virtual function的class objects的vptr进行适当的初始化，以放置适当的virtual table地址。</p></blockquote><h4 id="1-6-第四种情况：“带有一个virtual-base-class”的class。"><a href="#1-6-第四种情况：“带有一个virtual-base-class”的class。" class="headerlink" title="1.6 第四种情况：“带有一个virtual base class”的class。"></a>1.6 第四种情况：“带有一个virtual base class”的class。</h4><p>如果class派生自一个继承串链，其中有一个或更多的virtual base classes编译器也需要合成出default constructor或扩充construtor。其目的在于必须使 virtual base class 在其每一个derived class object中的位置能够在执行期准备妥当。对于class所定义的每一个constructor。编译器都会安插那些“允许每一个virtual base class 的执行期存取操作”的代码。</p><h4 id="1-7-总结。"><a href="#1-7-总结。" class="headerlink" title="1.7 总结。"></a>1.7 总结。</h4><p>除以上四种情况外，在没有声明constructor时就默认其是无用的， 其default constructor也就不会被合成出来的。<br>在合成的default constructor中，只有base class subobjects和member class objects会被初始化。所有其他的nonstatic data member ，如整数，整数指针，整数数组等是不会被初始化的，这些初始化操作对程序是必须的，但对编译器则并非需要的。<br>C++新手一般有两个误解：</p><ul><li>任何class 如果没有定义default constructor ，就会被合成出来一个。</li><li>编译器合成出来的default constructor 会明确设定 class 内每一个data member的默认值。</li></ul><h3 id="二、Copy-Constructor的构造操作"><a href="#二、Copy-Constructor的构造操作" class="headerlink" title="二、Copy Constructor的构造操作"></a>二、Copy Constructor的构造操作</h3><h4 id="2-1-哪些情况需要有copy-constructor？"><a href="#2-1-哪些情况需要有copy-constructor？" class="headerlink" title="2.1 哪些情况需要有copy constructor？"></a>2.1 哪些情况需要有copy constructor？</h4><p>有三种情况，会以一个object的内容作为另一class object的初值，即需要有 copy constructor。</p><ul><li><ol><li>把一个object直接赋值给另一个object进行初值。</li></ol></li><li><ol start="2"><li>当object被当做参数交给某个函数</li></ol></li><li><ol start="3"><li>当函数返回一个class object。</li></ol></li></ul><blockquote><p>一个class object可用两种方式复制得到，一种是被初始化，另一种是赋值。从概念上看，这两种操作分别是以copy constructor和copy assignment operator完成的。<br>Default constructors和copy constructor在<strong>必要的时候</strong>才由编译器产生，这里的“必要”意指当class不展现bitwise copy sematics时。</p></blockquote><h4 id="2-2-Default-Memberwise-Initialization"><a href="#2-2-Default-Memberwise-Initialization" class="headerlink" title="2.2 Default Memberwise Initialization"></a>2.2 Default Memberwise Initialization</h4><p>当class object以“<strong>相同</strong>的另一个object作为初值是，其内部是以所谓的default memberwise initialization方式完成的。也就是把每一个内建的或派生的data member（例如一个数组或指针）的值，从某个object拷贝一份到另一个object上，但不拷贝其具体内容。例如只拷贝指针地址，不拷贝一份新的指针指向的对象，这也就是<strong>浅拷贝</strong>，不过它并不会拷贝其中member class object，而是以递归的方式实行memberwise initialization。</p><h4 id="2-3-递归的memberwise-initialization是如何实现的呢？"><a href="#2-3-递归的memberwise-initialization是如何实现的呢？" class="headerlink" title="2.3 递归的memberwise initialization是如何实现的呢？"></a>2.3 递归的memberwise initialization是如何实现的呢？</h4><p>答案就是Bitwise Copy Semantics和default copy constructor。如果class展现了Bitwise Copy Semantics，则使用bitwise copy（bitwise copy semantics编译器生成的伪代码是memcpy函数），否则编译器会生成default copy constructor。</p><h4 id="2-4-Memberwise-copy-深拷贝-与Bitwise-copy-浅拷贝-的区别"><a href="#2-4-Memberwise-copy-深拷贝-与Bitwise-copy-浅拷贝-的区别" class="headerlink" title="2.4 Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别"></a>2.4 Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别</h4><p>Memberwise copy: 在初始化一个对象期间,基类的构造函数被调用,成员变量被调用,如果它们有构造函数的时候,它们的构造函数被调用,这个过程是一个递归的过程。<br>Bitwise copy: 原内存拷贝。例子,给定一个对象object,它的类型是class Base。对象object占用10字节的内存,地址从0x0到0x9.如果还有一个对象objectTwo,类型也是class Base。那么执行objectTwo = object;如果使用Bitwise拷贝语义,那么将会拷贝从0x0到0x9的数据到objectTwo的内存地址，也就是说Bitwise是字节到字节的拷贝。</p><p>对于默认的拷贝构造函数不会使用深拷贝,它只是使用浅拷贝。这意味着类的所有的成员是一层深度的拷贝而已。如果你的类或结构体成员中只是包含基本的数据类型例如int, float, char,那么Memberwise copy与Bitwise copy基本是相同的。但如果类中有指针存在,那么你可能会遇到问题。<br>例如下面的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> m;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line">   <span class="keyword">char</span> *Str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你创建两个这样的类对象,class A  a, b;并且你给a赋值      </span></span><br><span class="line">a.m = <span class="number">6</span>;   </span><br><span class="line">a.d = <span class="number">10.123</span>;   </span><br><span class="line">a.Str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];   </span><br><span class="line">a.<span class="built_in">strcpy</span>(a.Str, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果执行b = a;那么会把对象a的每一个成员的值赋值给b的每个成员。   </span></span><br><span class="line">b.m = a.m;    </span><br><span class="line">b.d = a.d;   </span><br><span class="line">b.Str = a.Str;<span class="comment">//这里是浅拷贝，现在对象a和b的成员Str都指向相同的内存,删除任一个内存都会析放另一个对象的内存。</span></span><br></pre></td></tr></table></figure></p><p>所以你需要自己实现深拷贝,它不是拷贝的内存地址而是拷贝内存地址的内容。一个默认的拷贝构造函数经常执行浅拷贝,只有拥有自己的拷贝函数才可以实现深拷贝。</p><h4 id="2-5-什么时候一个class不展现出“bitwise-copy-semantics”呢？"><a href="#2-5-什么时候一个class不展现出“bitwise-copy-semantics”呢？" class="headerlink" title="2.5 什么时候一个class不展现出“bitwise copy semantics”呢？"></a>2.5 什么时候一个class不展现出“bitwise copy semantics”呢？</h4><p>有四种情况：</p><ul><li><ol><li>当class内含有一个member class object，而这个member class内有一个默认的copy构造函数(不论是class设计者明确声明，或者被编译器合成)</li></ol></li><li><ol start="2"><li>当class继承自一个base class，而base class有copy构造函数(不论显式声明或是被编译器合成]</li></ol></li><li><ol start="3"><li>当一个类声明了一个或多个virtual 函数</li></ol></li><li><ol start="4"><li>当class派生自一个继承串链，其中一个或者多个virtual base class</li></ol></li></ul><h4 id="2-6-重新设定Virtual-Table的指针（virtual-funtion的情况）"><a href="#2-6-重新设定Virtual-Table的指针（virtual-funtion的情况）" class="headerlink" title="2.6 重新设定Virtual Table的指针（virtual funtion的情况）"></a>2.6 重新设定Virtual Table的指针（virtual funtion的情况）</h4><p>当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。<br>当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作也必须要保证安全（非pointer和reference)。也就是说，合成出来的基类构造函数会显式设定object的vptr指向基类对应的virtual table，而不是直接将右手边的class object中将其vptr现值拷贝过来。</p><h4 id="2-7-如何处理virtual-base-class-subobject的情况？"><a href="#2-7-如何处理virtual-base-class-subobject的情况？" class="headerlink" title="2.7 如何处理virtual base class subobject的情况？"></a>2.7 如何处理virtual base class subobject的情况？</h4><p>virtual base class的存在需要特别处理。一个class object如果以另一个object作为初值，而后者有一个virtual base class subobject，那么也会使“bitwise copy semantics”失效。       </p><p>这时需要合成一个copy constructor,从而安插一些代码以设定virtualbase class pointer/offset的初值，对每一个members执行必要的memberwise初始化操作，以及执行其他的内存相关工作。</p><h3 id="三、程序转化语意学-Program-Transformation-Semantics"><a href="#三、程序转化语意学-Program-Transformation-Semantics" class="headerlink" title="三、程序转化语意学(Program Transformation Semantics)"></a>三、程序转化语意学(Program Transformation Semantics)</h3><h4 id="3-1-class-object的显式初始化操作。"><a href="#3-1-class-object的显式初始化操作。" class="headerlink" title="3.1 class object的显式初始化操作。"></a>3.1 class object的显式初始化操作。</h4><p>初始化object时，必要的程序转化有以下两个阶段：</p><ul><li>重写每一个定义，其中的初始化操作会被剥除，在c++中，“定义”指占用内存的行为。</li><li>class的copy constructor调用操作会被安插进去。</li></ul><h4 id="3-2-参数的初始化所做的程序转换。"><a href="#3-2-参数的初始化所做的程序转换。" class="headerlink" title="3.2 参数的初始化所做的程序转换。"></a>3.2 参数的初始化所做的程序转换。</h4><p>C++ Standard说，把一个class object当做参数传给一个函数(或是作为一个函数的返回值)，相当于以下形式的初始化操作:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X xx = arg;<span class="comment">//其中xx代表形式参数(或返回值)而arg代表真正的参数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，若已知如下函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X xo)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//转换的结果为：</span></span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">//xo以memberwise的方式将xx当作初值...</span></span><br><span class="line">foo(xx);</span><br></pre></td></tr></table></figure></p><p>有一种策略是导入所谓的临时性object，并调用copy constructor将它初始化，然后将此临时性object交给函数，临时性object会在函数结束处被析构。</p><h4 id="3-3-返回值的初始化所做的程序转换。"><a href="#3-3-返回值的初始化所做的程序转换。" class="headerlink" title="3.3 返回值的初始化所做的程序转换。"></a>3.3 返回值的初始化所做的程序转换。</h4><p>函数bar()的返回值为一个对象，那该怎么把局部对象xx拷贝过来？ Stroustrup在cfront中的解决办法是一个双阶段的转化：</p><ul><li><ol><li>首先加上一个额外参数，其类型是class object的一个reference，这个参数将被用来放置被“拷贝建构”而得的返回值。</li></ol></li><li><ol start="2"><li>在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。函数也对应变为void类型。</li></ol></li></ul><h4 id="3-4-在编译器层面所做的优化。"><a href="#3-4-在编译器层面所做的优化。" class="headerlink" title="3.4 在编译器层面所做的优化。"></a>3.4 在编译器层面所做的优化。</h4><p>编译器会以result参数取代name return val。这样的编译器优化操作，有时被称为Named Return Value(NRV)优化。NRV优化如今被视为是标准C++编译器的一个义不容辞的优化操作。<strong>NRV需要一定的条件，即对应的类要有copy constructor</strong>。<br>一般而言，面对“以一个class object作为另一个class object的初值”的情形，语言允许编译器有大量的自由发挥空间。其优点当然是导致机器码产生时有明显的效率提升。缺点则是你不能安全地规划你的copy constructor的副作用，必须视其执行而定。</p><blockquote><p>NRV与返回值初始化的区别在于：NRV中不产生local object，直接以_result带入其中进行各种处理，减少调用copy constructor。而返回值初始化则是在最后用copy constructor将local object的值拷贝给_result, 中间不处理_result。一个是优化，一个是程序转换。</p></blockquote><h4 id="3-5-那Copy-Constructor要还是不要？"><a href="#3-5-那Copy-Constructor要还是不要？" class="headerlink" title="3.5 那Copy Constructor要还是不要？"></a>3.5 那Copy Constructor要还是不要？</h4><p>copy constructor的应用，迫使编译器多多少少对你的程序代码做部分优化。尤其当一个函数以传值(by value)的方式传回一个class object，而该class有一个copy constructor(不论是明确定义出来的，或是合成的)时。这将导致深奥的程序转化——不论在函数的定义或使用上，此外编译器也将copy constructor的调用操作优化，以一个额外的第一参数(数值被直接存放在其中)取代NRV。  </p><ul><li>如果编译器能自动为你实施了最好的行为,那就没有必要实现一个自己的copy constructor。</li><li>如果class需要大量的memberwise初始化操作，例如以传值的方式传回object，此时提供一个explicit inline copy constructor就是非常合理的（在有NRV的前提下）。</li></ul><h3 id="四、成员们的初始化队伍-Memeber-Initialization-List"><a href="#四、成员们的初始化队伍-Memeber-Initialization-List" class="headerlink" title="四、成员们的初始化队伍(Memeber Initialization List)"></a>四、成员们的初始化队伍(Memeber Initialization List)</h3><h4 id="4-1-在下列情况下，为了让你的程序能够顺利编译，你必须使用member-initialization-list"><a href="#4-1-在下列情况下，为了让你的程序能够顺利编译，你必须使用member-initialization-list" class="headerlink" title="4.1 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list:"></a>4.1 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list:</h4><ul><li>当初始化一个reference member时</li><li>当初始化一个const member时</li><li>当调用一个base class的constructor，而它拥有一组参数时</li><li>当调用一个member class的constructor，而它拥有一组参数时</li></ul><h4 id="4-2-member-initialization-list中到底会发生什么事情？"><a href="#4-2-member-initialization-list中到底会发生什么事情？" class="headerlink" title="4.2 member initialization list中到底会发生什么事情？"></a>4.2 member initialization list中到底会发生什么事情？</h4><p>编译器会一一操作initialization list，以适当顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。<br>initialization list中的项目顺序是由class中的members声明顺序决定的，不是由initialization list中的排列顺序决定的。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索c++对象模型》（一）关于对象</title>
      <link href="/2018/11/16/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/11/16/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>看完《深度探索c++对象模型》，心中对c++编译器在编译期间所做的处理有了更深入的认识，我想，除了对编译器本身有深入认识的作者之外，应该很少有人对c++的对象模型有这么深的认识。能接触了这本书，是我们的幸运，是作者让我们有机会能一窥其貌，感谢作者。</p><p>其实第一遍读这本书，我的收获还不算多，这可能是我对c++的使用还不够多的缘故，但通过这本书，我以后使用c++的时候，就会心里有更多的底气，也会有更多需要注意的地方，在经过更多的实践之后，我一定还会回来拜读这本书的。</p><p>现在，我想就本书所学到的的知识做一些总结。<br><a id="more"></a></p><hr><h3 id="一、关于对象"><a href="#一、关于对象" class="headerlink" title="一、关于对象"></a>一、关于对象</h3><h4 id="1-1-C-在加入封装后-只含有数据成员和普通成员函数）的布局成本增加了多少？"><a href="#1-1-C-在加入封装后-只含有数据成员和普通成员函数）的布局成本增加了多少？" class="headerlink" title="1.1 C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？"></a>1.1 C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？</h4><p>答案是并没有增加布局成本。就像C struct一样，memeber functions虽然含在class的声明之内，却不出现在object中。每一个non-inline member function只会诞生一个函数实体。至于每一个“拥有零个或一个定义的” inline function则会在其每一个使用者(模块)身上产生一个函数实体。</p><h4 id="1-2-C-在布局以及存取时间上主要的额外负担是由virtual引起的，包括："><a href="#1-2-C-在布局以及存取时间上主要的额外负担是由virtual引起的，包括：" class="headerlink" title="1.2 C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括："></a>1.2 C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括：</h4><ul><li>virtual funciton机制，用以支持一个有效率的“执行期绑定”</li><li>virtual base class，用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体”</li></ul><h3 id="二、C-对象模式-The-C-Object-Model"><a href="#二、C-对象模式-The-C-Object-Model" class="headerlink" title="二、C++ 对象模式(The C++ Object Model)"></a>二、C++ 对象模式(The C++ Object Model)</h3><h4 id="2-1-在C-中，有两种class-data-members：static-和-nonstatic，以及三种class-member-functions：static、nonstatic和virtual。"><a href="#2-1-在C-中，有两种class-data-members：static-和-nonstatic，以及三种class-member-functions：static、nonstatic和virtual。" class="headerlink" title="2.1 在C++中，有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。"></a>2.1 在C++中，有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。</h4><h4 id="2-2-C-对象模型中，nonstatic-data-members被配置于每一个class-object之内。"><a href="#2-2-C-对象模型中，nonstatic-data-members被配置于每一个class-object之内。" class="headerlink" title="2.2 C++对象模型中，nonstatic data members被配置于每一个class object之内。"></a>2.2 C++对象模型中，nonstatic data members被配置于每一个class object之内。</h4><p>static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual function则以两个步骤支持之：</p><ul><li><ol><li>每个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为virtual table(vtbl)</li></ol></li><li><ol start="2"><li>每一个class object被安插一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object(用以支持runtime type identification, RTTI)也经由virtual table被指出来，通常放在表格的第一个slot处。  </li></ol></li></ul><p>这个模型的主要优点在于它的空间和存取时间的效率。<br>主要缺点是：如果应用程序代码未曾改变，但所用到的class objects的nonstatic data members有所修改(有可能是增加、移除或更改)，那么应用程序代码同样得重新编译。</p><h4 id="2-3-继承关系可以指定为虚拟-virtual，也就是共享的意思-："><a href="#2-3-继承关系可以指定为虚拟-virtual，也就是共享的意思-：" class="headerlink" title="2.3 继承关系可以指定为虚拟(virtual，也就是共享的意思)："></a>2.3 继承关系可以指定为虚拟(virtual，也就是共享的意思)：</h4><p>在虚拟继承的情况下，base class不管在继承链中被派生(derived)多少次，永远只会存在一个实例(称为subobject)。</p><h3 id="三、关键词带来的差异"><a href="#三、关键词带来的差异" class="headerlink" title="三、关键词带来的差异"></a>三、关键词带来的差异</h3><h4 id="3-1-什么时候一个人应该在c-程序中以struct取代class"><a href="#3-1-什么时候一个人应该在c-程序中以struct取代class" class="headerlink" title="3.1 什么时候一个人应该在c++程序中以struct取代class?"></a>3.1 什么时候一个人应该在c++程序中以struct取代class?</h4><p>答案之一是当他让人感觉比较好的时候。单独来看，关键词本身并不提供任何差异，c++编译器对二者都提供了相同支持，我们可以认为支持struct只是为了方便将c程序迁移到c++中。</p><h4 id="3-2-那为什么我们要引入class关键词？"><a href="#3-2-那为什么我们要引入class关键词？" class="headerlink" title="3.2 那为什么我们要引入class关键词？"></a>3.2 那为什么我们要引入class关键词？</h4><p>这是因为引入的不只是class这个关键词，更多的是它所支持的封装和继承的哲学。</p><h4 id="3-3-怎么在c-中用好struct？"><a href="#3-3-怎么在c-中用好struct？" class="headerlink" title="3.3 怎么在c++中用好struct？"></a>3.3 怎么在c++中用好struct？</h4><p>将struct和class组合起来，组合，而非继承，才是把c和c++结合在一起的唯一可行的方法。另外，当你要传递“一个复杂的class object的全部或部分”到某个c函数去时，struct声明可以将数据封装起来，并保证拥有与c兼容的空间布局。</p><h3 id="四、对象的差异"><a href="#四、对象的差异" class="headerlink" title="四、对象的差异"></a>四、对象的差异</h3><h4 id="4-1-C-程序设计模型直接支持三种程序设计典范（programming-paradigms）："><a href="#4-1-C-程序设计模型直接支持三种程序设计典范（programming-paradigms）：" class="headerlink" title="4.1 C++程序设计模型直接支持三种程序设计典范（programming paradigms）："></a>4.1 C++程序设计模型直接支持三种程序设计典范（programming paradigms）：</h4><ul><li>程序模型：数据和函数分开。 </li><li>抽象数据类型模型：数据和函数一起封装以来提供。</li><li>面向对象模型：可通过一个抽象的base class封装起来，用以提供共同接口，需要付出的就是额外的间接性。<blockquote><p>虽然你可以直接或间接处理继承体系中的一个base class object,但只有通过pointer或reference的间接处理，才支持OO程序设计所需的多态性质。<strong>c++通过class的pointers和reference来支持多态，这种程序设计风格就称为面向对象</strong></p></blockquote></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Liberary_materials thing1<span class="comment">;//基类</span></span><br><span class="line">Book book<span class="comment">;//派生类</span></span><br><span class="line"><span class="attribute">thing1</span>=book<span class="comment">;</span></span><br><span class="line">thing1.check_in()<span class="comment">;//这种情况下，调用的是基类的check_in()</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Liberary_materials <span class="meta">&amp;thing2=book</span></span><br><span class="line">thing2.check_in();<span class="comment">//这种情况下调用的才是book的check_in()</span></span><br></pre></td></tr></table></figure><h4 id="4-2-C-以下列方法支持多态："><a href="#4-2-C-以下列方法支持多态：" class="headerlink" title="4.2 C++以下列方法支持多态："></a>4.2 C++以下列方法支持多态：</h4><ul><li><ol><li>经由一组隐式的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape *ps=<span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>经由virtual function机制<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ps</span>-&gt;</span>rotate();</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>经由dynamic_cast和typeid运算符<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(<span class="built_in">circle</span> *pc=<span class="keyword">dynamic_cast</span>&lt;<span class="built_in">circle</span> *&gt;(ps))...</span><br></pre></td></tr></table></figure></li></ol></li></ul><blockquote><p><strong>多态的主要用途是经由一个共同的接口来影响类型的封装</strong>，这个接口通常被定义在一个抽象的base class中。这个共享接口是以virtual function机制引发的，它可以在执行期根据object的真正类型解析出到底是哪一个函数实体被调用。</p></blockquote><h4 id="4-3-需要多少内存才能表现一个class-object"><a href="#4-3-需要多少内存才能表现一个class-object" class="headerlink" title="4.3 需要多少内存才能表现一个class object?"></a>4.3 需要多少内存才能表现一个class object?</h4><ul><li>其nonstatic data members的总和大小</li><li>加上任何由于aliginment的需求而填补上去的空间(可能存在于members之间，也可能存在于集合体边界),aliginement就是将数值调整到某数的倍数，如在32位的计算机上为4。</li><li>加上为了支持virtual而由内部产生的任何额外负担</li></ul><h4 id="4-4-一个指针-引用-，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的-一个机器字-。"><a href="#4-4-一个指针-引用-，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的-一个机器字-。" class="headerlink" title="4.4 一个指针(引用)，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的(一个机器字)。"></a>4.4 一个指针(引用)，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的(一个机器字)。</h4><p>例如：一个指向ZooAnimal的指针是如何地与一个指向整数得指针或一个指向template Array的指针有所不同的呢？<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal *px<span class="comment">;</span></span><br><span class="line">int *pi<span class="comment">;</span></span><br><span class="line">Array&lt;string&gt; *pta<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>以内存需求的观点来说，没有什么不同！它们三个都需要足够的内存来放置一个机器地址(通常是个word)。<strong>“指向不同类型的各指针”间的差异，既不在其指针表示法不同，也不在其内容(代表一个地址)不同，而是在其所寻址出来的object类型不同</strong>，也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小。</p><h4 id="4-5-转型-cast-其实是一种编译器指令。"><a href="#4-5-转型-cast-其实是一种编译器指令。" class="headerlink" title="4.5 转型(cast)其实是一种编译器指令。"></a>4.5 转型(cast)其实是一种编译器指令。</h4><p>大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存大大小和其内容”的<strong>解释方式</strong>。</p><blockquote><p>如一个类型为void *的指针只能够持有一个地址，但不能 通过它操作所指object。</p></blockquote><h4 id="4-6-一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）"><a href="#4-6-一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）" class="headerlink" title="4.6 一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）"></a>4.6 一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）</h4><p>二者都指向基类对象的第一个byte,其间的差别是，派生类指针涵盖的地址包含整个派生类对象，而一个基类指针所涵盖的地址只包含派生类对象的基类子对象部分。</p><blockquote><p>但基类指针可以通过virtual机制访问派生类对象的函数。</p></blockquote><h4 id="4-7-当一个base-class-object被直接初始化为-或被指定为-一个derived-class-object时。"><a href="#4-7-当一个base-class-object被直接初始化为-或被指定为-一个derived-class-object时。" class="headerlink" title="4.7 当一个base class object被直接初始化为(或被指定为)一个derived class object时。"></a>4.7 当一个base class object被直接初始化为(或被指定为)一个derived class object时。</h4><p>derived object就会被切割(sliced)以塞入较小的base type内存中，derived type将没有留下任何蛛丝马迹。多态于是不再呈现，而一个严格的编译器可以在编译器解析一个“通过此object而触发的virtual function调用操作”，因而回避virtual机制。如果virtual function被定义为inline，则更有效率上的大收获。</p><h4 id="4-8-C-也支持具体的ADT程序风格，如今被称为object-based-OB-。"><a href="#4-8-C-也支持具体的ADT程序风格，如今被称为object-based-OB-。" class="headerlink" title="4.8 C++也支持具体的ADT程序风格，如今被称为object-based(OB)。"></a>4.8 C++也支持具体的ADT程序风格，如今被称为object-based(OB)。</h4><p>一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象构建起来时不需要设置virtual机制。空间紧凑是因为每一个class object不需要负担传统上为了支持virtual机制儿需要的额外负荷。不过，<strong>OB设计比较没有弹性。</strong><br>在弹性（OO）和（OB）之间常常存在着取舍。一个人能够有效选择其一之前，必须先清楚了解两者的行为和应用领域的需求。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中的仓库崩溃后的如何恢复</title>
      <link href="/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93%E5%B4%A9%E6%BA%83%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/"/>
      <url>/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E4%B8%AD%E7%9A%84%E4%BB%93%E5%BA%93%E5%B4%A9%E6%BA%83%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="解决git仓库崩溃问题"><a href="#解决git仓库崩溃问题" class="headerlink" title="解决git仓库崩溃问题"></a>解决git仓库崩溃问题</h1><hr><blockquote><p>不知道是不是虚拟机的问题，最近修改代码后git仓库总崩溃，导致的结果就是很多时候自己刚修改的代码不得不放弃，最近找到一种比较好的解决方式，链接如下：<a href="https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty" target="_blank" rel="noopener">https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty</a></p></blockquote><h3 id="1-git仓库崩溃表现"><a href="#1-git仓库崩溃表现" class="headerlink" title="1.git仓库崩溃表现"></a>1.git仓库崩溃表现</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dengwen@ubuntu:~/project_DW/selog$ git status</span><br><span class="line"><span class="keyword">error: </span>object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is empty</span><br><span class="line"><span class="keyword">error: </span>object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is empty</span><br><span class="line">fatal: loose object a9761932a220991b0490c2715f218f814d39b876 (stored in .git/objects/a9/761932a220991b0490c2715f218f814d39b876) is corrupt</span><br></pre></td></tr></table></figure><h3 id="2-常规解决方案"><a href="#2-常规解决方案" class="headerlink" title="2.常规解决方案"></a>2.常规解决方案</h3><p>git仓库崩溃后，常规的解决方案是在其他目录git clone之前版本的项目，然后将<br>当前版本的项目拷贝过去进行覆盖，再进行提交，但是这样做的结果就是可能会丢失部分git commit信息，除此之外基本没什么问题。</p><h3 id="3-推荐方法"><a href="#3-推荐方法" class="headerlink" title="3.推荐方法"></a>3.推荐方法</h3><p>这种方法的好处在于可以恢复git log信息，同时也不用重新clone项目、切换分支、替换等操作，相对来说，git管理的完整度和效率会更高，具体步骤如下：</p><ul><li><p>（1）删除全部空文件: <strong>注意在.git目录下进行</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="title">@ubuntu</span>:~/project_DW/selog/.git$ find . -<span class="keyword">type</span> f -empty -delete -print</span><br><span class="line">./objects/<span class="number">0</span>d/e<span class="number">32</span>d<span class="number">3</span>b<span class="number">8</span>d<span class="number">0399414</span><span class="keyword">c</span><span class="number">0</span><span class="keyword">c</span><span class="number">8</span>fc<span class="number">47</span>a<span class="number">56069e9821615</span>a</span><br><span class="line">./objects/<span class="number">14</span>/<span class="number">540</span>f<span class="number">9</span>dda<span class="number">3</span><span class="keyword">c</span><span class="number">30044e2</span>dbe<span class="number">4629</span>d<span class="number">22</span><span class="keyword">c</span><span class="number">715145</span>f<span class="number">212</span></span><br><span class="line">./objects/<span class="number">19</span>/b<span class="number">98</span><span class="keyword">c</span><span class="number">74</span>bc<span class="number">6</span><span class="keyword">c</span><span class="number">2e372887</span>af<span class="number">410301</span>a<span class="number">0</span>a<span class="number">80495725</span><span class="keyword">c</span></span><br><span class="line">./objects/<span class="number">55</span>/<span class="number">14</span>f<span class="number">9022e0</span>e<span class="number">39</span>a<span class="number">29</span>d<span class="number">0e25</span>cdf<span class="number">15</span>cecac<span class="number">1</span>f<span class="number">2</span>f<span class="number">479</span><span class="keyword">c</span></span><br><span class="line">./objects/<span class="number">84</span>/<span class="number">0103</span>bdd<span class="number">9538473</span>baab<span class="number">19520</span>eda<span class="number">11</span>b<span class="number">88</span>b<span class="number">40</span><span class="keyword">c</span><span class="number">953</span></span><br><span class="line">./FETCH_HEAD</span><br></pre></td></tr></table></figure></li><li><p>（2）获取最后两条reflog：注意自己要恢复的分支，此处为develop</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>tail -n <span class="number">2</span> .git/logs/refs/heads/develop</span><br><span class="line"><span class="number">41867</span>ca4ab8d60979e804ee7f4640a2e9231d96b f815821a9c4e4833be898dace675916f3cad0124 dengwen &lt;<span class="number">15680482464</span><span class="variable">@163</span>.com&gt; <span class="number">1539335482</span> +080<span class="number">0</span>        <span class="symbol">commit:</span> add manage</span><br></pre></td></tr></table></figure></li><li><p>（3）恢复对应的日志<br>由上一步我们知道最新的日志节点为f815821a9c4e4833be898dace675916f3cad0124，我们可以查看这个节点的信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>git show f815821a9c4e4833be898dace675916f3cad0124</span><br><span class="line">commit f815821a9c4e4833be898dace675916f3cad0124</span><br><span class="line"><span class="symbol">Author:</span> dengwen &lt;<span class="number">15680482464</span><span class="variable">@163</span>.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Fri Oct <span class="number">12</span> <span class="number">17</span><span class="symbol">:</span><span class="number">11</span><span class="symbol">:</span><span class="number">22</span> <span class="number">2018</span> +080<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    add manage</span><br></pre></td></tr></table></figure></li></ul><p>接下来要做的就是恢复日志,同样，需要注意分支和日志节点。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dengwen<span class="variable">@ubuntu</span><span class="symbol">:~/project_DW/selog</span><span class="variable">$ </span>git update-ref develop f815821a9c4e4833be898dace675916f3cad0124</span><br></pre></td></tr></table></figure></p><ul><li>（4）提交最新的git log<br>执行上述步骤后，用git status可以查看仓库的状态了，也就意味着git仓库恢复成功了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 中的SSH key的生成</title>
      <link href="/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E4%B9%8B%E7%94%9F%E6%88%90ssh%20key/"/>
      <url>/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E4%B9%8B%E7%94%9F%E6%88%90ssh%20key/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-中的SSH-key的生成"><a href="#Git-中的SSH-key的生成" class="headerlink" title="Git 中的SSH key的生成"></a><strong>Git 中的SSH key的生成</strong></h2><h4 id="1-1-emsp-安装git："><a href="#1-1-emsp-安装git：" class="headerlink" title="1.1&emsp;安装git："></a>1.1&emsp;安装git：</h4><p>&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： <a href="http://msysgit.github.com/" target="_blank" rel="noopener">http://msysgit.github.com/</a> </p><h4 id="1-2-emsp-查看是否经有SSH-key："><a href="#1-2-emsp-查看是否经有SSH-key：" class="headerlink" title="1.2&emsp;查看是否经有SSH key："></a>1.2&emsp;查看是否经有SSH key：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa<span class="selector-class">.pub</span> <span class="comment">//git bash中输入这个命令</span></span><br></pre></td></tr></table></figure><h4 id="1-3-emsp-生成SSH-key："><a href="#1-3-emsp-生成SSH-key：" class="headerlink" title="1.3&emsp;生成SSH key："></a>1.3&emsp;生成SSH key：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your.email@example.com"</span> -<span class="selector-tag">b</span> <span class="number">4096</span> <span class="comment">//git bash中输入这个命令，修改对应的邮箱</span></span><br></pre></td></tr></table></figure><p>  <strong><em>如果已经存在SSH key,则直接复制即可，否则需要重新生成。</em></strong><br>  <strong><em>生成SSH key时需要设置对应的文件存放路径和密码，为了方便，直接回车默认即可。</em></strong>   </p><h4 id="1-3-emsp-查看生成的SSH-key，复制到git中即可："><a href="#1-3-emsp-查看生成的SSH-key，复制到git中即可：" class="headerlink" title="1.3&emsp;查看生成的SSH key，复制到git中即可："></a>1.3&emsp;查看生成的SSH key，复制到git中即可：</h4>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xclip -sel <span class="keyword">clip</span> &lt; ~/.ssh/id_rsa.pub <span class="comment">//GNU/Linux (requires the xclip package)</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub | <span class="keyword">clip</span> <span class="comment">//Git Bash on Windows / Windows PowerShell</span></span><br><span class="line">type %userprofile%\.ssh\id_rsa.pub | <span class="keyword">clip</span> <span class="comment">//Windows Command Line</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本命令详解</title>
      <link href="/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/16/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近刚开始学习git，总结一下git的各个命令，方便以后查阅。<br>学习环境：windows10<br> <strong>参考链接：</strong></p><blockquote><ul><li>Pro Git（中文版）<a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">http://git.oschina.net/progit/</a></li><li>沉浸式学 Git<a href="http://igit.linuxtoy.org/contents.html" target="_blank" rel="noopener">http://igit.linuxtoy.org/contents.html</a></li></ul></blockquote><h2 id="1-git的安装及初始配置"><a href="#1-git的安装及初始配置" class="headerlink" title="1. git的安装及初始配置"></a><strong>1. git的安装及初始配置</strong></h2><h3 id="1-1-git-安装"><a href="#1-1-git-安装" class="headerlink" title="1.1 git 安装"></a><strong>1.1 git 安装</strong></h3><p>&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： <a href="http://msysgit.github.com/" target="_blank" rel="noopener">http://msysgit.github.com/</a>   </p><h3 id="1-2-git-初始化配置"><a href="#1-2-git-初始化配置" class="headerlink" title="1.2 git 初始化配置"></a><strong>1.2 git 初始化配置</strong></h3><p>&emsp; &emsp; 1.2.1&emsp;配置用户名和户邮箱：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   git<span class="built_in"> config </span>--global user.name <span class="string">"deng wen"</span> </span><br><span class="line">git<span class="built_in"> config </span>--global user.email 156XXXXXXX@163.com</span><br></pre></td></tr></table></figure></p><p>&emsp; &emsp; 1.2.2&emsp;查看初始配置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--list</span><br></pre></td></tr></table></figure></p><h2 id="2-git的基础命令"><a href="#2-git的基础命令" class="headerlink" title="2.git的基础命令"></a><strong>2.git的基础命令</strong></h2><h3 id="2-1-新建仓库"><a href="#2-1-新建仓库" class="headerlink" title="2.1 新建仓库"></a><strong>2.1 新建仓库</strong></h3><p>&emsp; Git 新建项目仓库的方法有两种。分别为：<br>&emsp; &emsp;  2.1.1&emsp; 第一种：在现存的目录下，用如下命令得到一个.git仓库目录，资源对应添加到其中：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure></p><p>&emsp; &emsp;  2.1.2&emsp; 第二种：从已有的 Git 仓库克隆出一个新的镜像仓库来。[URL]       如：<a href="http://uestclab307.kmdns.net:808/dengwen/SAIC_SecMonitor.git，mygitname可省略：" target="_blank" rel="noopener">http://uestclab307.kmdns.net:808/dengwen/SAIC_SecMonitor.git，mygitname可省略：</a><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">[URL</span>] mygitname</span><br></pre></td></tr></table></figure></p><h3 id="2-2-文件基本处理"><a href="#2-2-文件基本处理" class="headerlink" title="2.2 文件基本处理"></a><strong>2.2 文件基本处理</strong></h3><p>&emsp; &emsp;  2.2.1&emsp;检查当前文件状态：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    git status</span><br><span class="line">``` </span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 将新文件或更新文件加入跟踪：</span><br></pre></td></tr></table></figure></p><pre><code>git add  filenamegit add  —A //将所有新文件一次加入跟踪git checkout -- filename // 对所做的更改进行忽略git reset HEAD filename //撤销加入跟踪的文件 </code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.3</span><span class="variable">&amp;emsp</span>; 文件提交：</span><br></pre></td></tr></table></figure><pre><code>git commit  —m  &quot;your comment&quot; //-m表示注释git commit --amend //撤销刚做的提交git commit  —a  //所有跟踪文件一次提交</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.4</span><span class="variable">&amp;emsp</span>; 删除文件：</span><br></pre></td></tr></table></figure><pre><code>git rm --cached filename //跟踪目录删除、本地不删除git rm -f filename //跟踪目录、本地目录皆删除：</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.5</span><span class="variable">&amp;emsp</span>; 在仓库中移动文件：</span><br></pre></td></tr></table></figure><pre><code>git mv file_from file_to</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.2</span><span class="number">.6</span><span class="variable">&amp;emsp</span>; 查看提交历史，- -pretty按固定格式显示,--graph 选项用 ASCII 字符串形象地展示了每个提交所在的分支及其分化衍合情况：</span><br></pre></td></tr></table></figure><pre><code>git loggit log --pretty=format:&quot;%h - %an, %ar : %s&quot;git log --pretty=format:&quot;%h %s&quot; --graph</code></pre><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;**选项 说明**</span><br><span class="line"><span class="tag">    %<span class="selector-tag">H</span></span> 提交对象（commit）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">h</span></span> 提交对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">T</span></span> 树对象（tree）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">t</span></span> 树对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">P</span></span> 父对象（parent）的完整哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">p</span></span> 父对象的简短哈希字串</span><br><span class="line"><span class="tag">    %<span class="selector-tag">an</span></span> 作者（author）的名字</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ae</span></span> 作者的电子邮件地址</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ad</span></span> 作者修订日期（可以用 -date= 选项定制格式）</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ar</span></span> 作者修订日期，按多久以前的方式显示</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cn</span></span> 提交者(committer)的名字</span><br><span class="line"><span class="tag">    %<span class="selector-tag">ce</span></span> 提交者的电子邮件地址</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cd</span></span> 提交日期</span><br><span class="line"><span class="tag">    %<span class="selector-tag">cr</span></span> 提交日期，按多久以前的方式显示</span><br><span class="line"><span class="tag">    %<span class="selector-tag">s</span></span> 提交说明</span><br><span class="line">    </span><br><span class="line">### **2.3 远程仓库的使用**</span><br><span class="line"> &amp;emsp; &amp;emsp;  2.3.1&amp;emsp; 查看当前的远程库,-v 选项显示对应的克隆地址：</span><br></pre></td></tr></table></figure><pre><code>git remote //查看当前仓库对应的远程库,一般为origingit remote -v //查看当前仓库对应的远程库及相应地址</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.3</span><span class="number">.2</span><span class="variable">&amp;emsp</span>;远程仓库处理：</span><br></pre></td></tr></table></figure><pre><code>git remote add yourname [url] //yourname是你的本地仓库名，相当于赋值yourname为URLgit fetch yourname  //从远程仓库抓取数据到本地，到如果要查看需要合并到当前分支git remote show [remote-name] //查看远程仓库信息，如显示了有哪些远端分支还没有同步到本地等git remote rename old-name new-name //重命名git remote rm paul //删除</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **2.4 标签**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.4</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 新建标签：</span><br></pre></td></tr></table></figure><pre><code>git tag //查看已有标签git tag -a yourtagname -m &apos;your comment&apos; //打标签git show yourtagname //查看版本信息 git tag -a yourtagname hist //后期加标签,hist表校验和</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.4</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 标签远程共享：</span><br></pre></td></tr></table></figure><pre><code>git push origin yourtagname //推送标签git push origin --tags //推送所有标签</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **2.5 Git 命令别名**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">2.5</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 简写git命令：</span><br></pre></td></tr></table></figure><pre><code>git config --global alias.shortname gitcommandname eg: git config --global alias.unstage &apos;reset HEAD&apos;    git unstage filename //撤销加入跟踪的文件 </code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **<span class="number">3.</span>git分支处理**</span><br><span class="line">### **<span class="number">3.1</span> Git 查看分支**</span><br><span class="line"> &amp;emsp; &amp;emsp;  <span class="number">3.1</span><span class="number">.1</span>&amp;emsp; 查看分支：</span><br></pre></td></tr></table></figure><pre><code>git branch git branch -a //查看所有分支，包括远程分支git branch -v //查看分支最后一个提交对象的信息git branch --merged/--no--merge //查看已经（或尚未）合并的分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **3.2 Git 分支切换、合并和删除**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.1</span><span class="variable">&amp;emsp</span>; 切换分支：</span><br></pre></td></tr></table></figure><pre><code>git branch branchname  //在当前分支下创建分支git checkout branchname //切换到已有的分支git checkout -b &apos;branchname&apos; //创建分支并切换</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.2</span><span class="variable">&amp;emsp</span>; 合并分支：</span><br></pre></td></tr></table></figure><pre><code>git merge branchname //将分支合并到当前分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.2</span><span class="number">.3</span><span class="variable">&amp;emsp</span>; 删除分支：</span><br></pre></td></tr></table></figure><pre><code>git branch -d branchname  //删除分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### **3.3 Git 远程分支处理**</span></span><br><span class="line"> <span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.1</span><span class="variable">&amp;emsp</span>;跟踪远程分支：</span><br></pre></td></tr></table></figure><pre><code>git checkout -b [分支名] [远程仓库名]/[分支名]  //跟踪分支是一种和某个远程分支有直接联系的本地分支git pull  //新建跟踪分支后用该命令直接将远程分支合并进来git push  //将本地跟踪分支推送到远程分支git push --set-upstream [远程仓库名] [分支名]  //将当前的分支设置为跟踪某个远程分支</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.2</span><span class="variable">&amp;emsp</span>;抓取和合并远程分支：</span><br></pre></td></tr></table></figure><pre><code>git fetch origin  //同步远程origin/master数据到本地，指针移到它最新的位置上。git merge origin/remotename  //将远程分支的内容合并到当前分支，用于远程分支已同步而又不能直接访问时。</code></pre><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">&amp;emsp</span>; <span class="variable">&amp;emsp</span>;  <span class="number">3.3</span><span class="number">.3</span><span class="variable">&amp;emsp</span>;推送分支和删除远程分支：</span><br></pre></td></tr></table></figure><pre><code>git push origin name1:name2  //把本地分支name1推送到远程分支name2中，如果远程仓库没有这个分支，会生成这样一个新的分支。用这种方式可以远程创建分支。  git push origin name //将本地分支推到远程同名分支。git push origin :remotename //把空白远程远程分支，即删除远程分支。</code></pre><p><code>`</code></p><p><br><br><br></p><p><strong><em>这些就是基本的git命令，更多待进一步学习</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find、grep、awk、sed 学习</title>
      <link href="/2018/06/02/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/find%E3%80%81grep%E3%80%81awk%E3%80%81sed%20%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/06/02/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/find%E3%80%81grep%E3%80%81awk%E3%80%81sed%20%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文主要是总结了一下常见的文本操作命令，并进行了实践。<br><a id="more"></a></p><h3 id="1、find命令"><a href="#1、find命令" class="headerlink" title="1、find命令"></a>1、find命令</h3><p>find主要用于查找文件。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> /home/ -<span class="built_in">name</span> <span class="string">"text.txt"</span> <span class="comment">//寻找名为text.txt的文件，会输出所有文件及其路径名。</span></span><br><span class="line"><span class="built_in">find</span> /home/ -<span class="built_in">name</span> <span class="string">"*.txt"</span>   <span class="comment">//查找home目录下所有的.txt 字符串结尾的文件。</span></span><br><span class="line"><span class="built_in">find</span> /home/ -<span class="built_in">name</span> <span class="string">"text.txt"</span> | more <span class="comment">//当显示的内容太多时，可以加上管道符more 进行分页查看 ，space就是翻页，enter就是下一行。</span></span><br><span class="line"></span><br><span class="line">因为显示出来的既会包含文件，也会包含目录，所以要区分，通过-<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> /home/ -<span class="built_in">name</span> <span class="string">"*.txt"</span> -<span class="built_in">type</span> d  <span class="comment">//这个显示出来的都是目录directory</span></span><br><span class="line"><span class="built_in">find</span> /home/ -<span class="built_in">name</span> <span class="string">"*.txt"</span> -<span class="built_in">type</span> f  <span class="comment">//这个显示出来的都是文件file</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f  <span class="comment">//用.来表示相对路径，在当前目录下寻找。</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime +<span class="number">30</span>  <span class="comment">//30天之前修改的文件</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime -<span class="number">1</span> <span class="comment">//1天内修改的文件</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime -<span class="number">1</span> |xargs rm -rf &#123;&#125; \ <span class="comment">//将find出来的内容替换到rm -rf后的大括号，通过xargs管道符进行连接。 这样的话就把find出来的文件全部删除了。</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime -<span class="number">1</span> -<span class="built_in">exec</span> cp -r &#123;&#125; \tmp\ \  <span class="comment">// 把find出来的文件拷贝到\tmp\目录下。cp的-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span></span><br></pre></td></tr></table></figure><blockquote><p>xargs:  只支持rm<br>exec:  支持 cp,mv,chmod,chown</p></blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime -<span class="number">1</span> -<span class="built_in">size</span> +<span class="number">1</span>k   <span class="comment">//修改时间在一天内，同时大小大于1k的才会显示出来。千字节要小写k，兆要大写M。</span></span><br><span class="line"><span class="built_in">find</span> . <span class="string">"*.txt"</span> -<span class="built_in">type</span> f -mtime -<span class="number">1</span> -<span class="built_in">size</span> +<span class="number">1</span>k -perm <span class="number">755</span> <span class="comment">//加上权限为755的限制</span></span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f <span class="string">"*.log"</span> -mtime +<span class="number">30</span> -<span class="built_in">exec</span> rm -rf &#123;&#125; \  <span class="comment">//删除服务器30天之前的日志</span></span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">exec</span> chmod -R <span class="number">644</span> &#123;&#125; \  <span class="comment">//在当前目录下把所有文件的权限改为644</span></span><br></pre></td></tr></table></figure><p>关于文件目录权限的基础知识普及：<br><img src="https://pic4.zhimg.com/v2-8c1176b648cab2dc138e19aea200cc0b_b.jpg" alt></p><h3 id="2、grep命令"><a href="#2、grep命令" class="headerlink" title="2、grep命令"></a>2、grep命令</h3><p>grep本意为过滤查询的意思,主要用于查找文件里的内容。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"root"</span> <span class="string">/etc/passwd</span>   <span class="string">//</span>查询passwd文件里带有root字符串的行</span><br><span class="line">grep <span class="params">--color</span> <span class="string">"root"</span> <span class="string">/etc/passwd</span>    <span class="string">//</span>把显示出来的root用颜色标记。</span><br><span class="line">grep -n <span class="params">--color</span> <span class="string">"root"</span> <span class="string">/etc/passwd</span>  <span class="string">//</span>再加上行号显示。</span><br><span class="line">grep -n <span class="params">--color</span> <span class="string">"^root"</span> <span class="string">/etc/passwd</span> <span class="string">//</span>找以root开头的行，就是在root前面加个尖括号。</span><br><span class="line">grep -n <span class="params">--color</span> <span class="string">"root$"</span> <span class="string">/etc/passwd</span>  <span class="string">//</span>以root结尾的那一行</span><br><span class="line">grep <span class="string">"#"</span> <span class="string">/nginx.conf.default</span> <span class="string">//</span>只显示带有<span class="comment">#号的行。</span></span><br><span class="line">grep -v <span class="string">"#"</span> <span class="string">/nginx.conf.default</span> <span class="string">//</span>把不包含<span class="comment">#号的行显示出来,加了个-v</span></span><br><span class="line">grep -v <span class="string">"#"</span> <span class="string">/nginx.conf.default</span> | grep -v <span class="string">"^$"</span> <span class="string">//</span>先去掉注释行，然后去掉空行</span><br></pre></td></tr></table></figure><blockquote><p>注意参数： -i 是忽略大小写； -n是输出行号； -v是反向选择</p></blockquote><p>下面要匹配一个IP地址： 主要是grep匹配正则表达式。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep --<span class="attribute">color</span> "<span class="selector-attr">[0-9]</span><span class="selector-attr">[0-9]</span>" text<span class="selector-class">.txt</span>  <span class="comment">//匹配连续的数字，并加颜色显示</span></span><br><span class="line">egrep --<span class="attribute">color</span> "<span class="selector-attr">[0-9]</span>&#123;1&#125;" text<span class="selector-class">.txt</span> <span class="comment">//匹配一个数字。</span></span><br><span class="line">egrep --<span class="attribute">color</span> "<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\." text<span class="selector-class">.txt</span> <span class="comment">//匹配1到3个连续数字加上 "." ,这里注意加上转义符 \ 。如果没有转义符，一个“.”代表任意字符。</span></span><br><span class="line">egrep --<span class="attribute">color</span> "<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;" text<span class="selector-class">.txt</span> <span class="comment">//这样就匹配了IP的4部分了，但是后面如果有多的数字的话也会匹配进来</span></span><br><span class="line">egrep --<span class="attribute">color</span> "<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.<span class="selector-attr">[0-9]</span>&#123;1，3&#125;$" text<span class="selector-class">.txt</span> <span class="comment">//后面加上通配符$，表示以什么结尾，这样就会把后面有多余的排除掉。</span></span><br><span class="line">egrep --<span class="attribute">color</span> "(<span class="selector-attr">[0-9]</span>&#123;1，3&#125;\.)&#123;3&#125;<span class="selector-attr">[0-9]</span>&#123;1，3&#125;$" text<span class="selector-class">.txt</span> <span class="comment">//这样加个小括号括起来就可以省略掉很多字符串了，大括号表示匹配的次数。</span></span><br></pre></td></tr></table></figure></p><p><img src="https://pic3.zhimg.com/v2-af23da0b2d45588fcdeaf3a5c101e096_b.jpg" alt></p><h3 id="3、awk命令"><a href="#3、awk命令" class="headerlink" title="3、awk命令"></a>3、awk命令</h3><p>awk主要用于数据统计，日志分析：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="variable">$1&#125;</span>' /etc/passwd | <span class="keyword">more</span>   <span class="comment">//把文件的第一列打出来</span></span><br></pre></td></tr></table></figure></p><p>这里要<strong>理解一列的意思，列是以空格作为分隔，没有空格，即使换行也是一列</strong>。比如：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="keyword">ant</span> 查看tcp连接</span><br></pre></td></tr></table></figure></p><p><img src="https://pic4.zhimg.com/v2-714df6e7c83da86974972091da38875f_b.jpg" alt></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | awk <span class="string">'&#123;print <span class="subst">$6</span>&#125;'</span> <span class="comment">//即把第六列输出</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://pic1.zhimg.com/v2-43d2e5c2b2489352ddfcc2a030acfd2c_b.jpg" alt></p><p>大家注意列的概念。再比如说： 如下，想把每列的开始的用户名取出来。<br><img src="https://pic3.zhimg.com/v2-bb85b4426ad5a73550ba866c8c7bcdaa_b.png" alt></p><p>这里采取的措施是把用户名后面的冒号去掉，就变成了列分隔了。如下：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">'&#123;print $1&#125;'</span> <span class="regexp">/etc/</span>passwd | head -<span class="number">5</span>  <span class="regexp">//</span>-F:即-F把后面的:换成<span class="string">" "</span>。head -<span class="number">5</span>取前<span class="number">5</span>行</span><br><span class="line">aawk -F: <span class="string">'&#123;print $1":"$NF&#125;'</span> <span class="regexp">/etc/</span>passwd | head -<span class="number">5</span>   <span class="regexp">//</span><span class="variable">$NF</span>则是最后一列。即只输出第一列和最后一列。</span><br></pre></td></tr></table></figure></p><p><img src="https://pic4.zhimg.com/v2-25fda2d24e29813460d23c07d18d2ce3_b.jpg" alt><br><img src="https://pic3.zhimg.com/v2-cc3a71211037db4f15814045f9a5dede_b.png" alt></p><p><strong>双引号在awk里面是添加的意思</strong>，这样就在第一列和最后一列中间加上了冒号。这里可以添加任意字符。</p><p>现在进行一个简单的实例：比如ifconfig得到网卡信息如下：</p><p><img src="https://pic2.zhimg.com/v2-26fa17f1404ccb8c4229c581781dde7d_b.jpg" alt></p><p><strong>然后想要把ip地址192.168.1.244输出并且变为 192-169-1-244</strong></p><p>第一步：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig <span class="string">| grep "</span>inet<span class="string">"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/v2-e5569174feb22b11b35c4fa89fca2fe5_b.png" alt></p><p>然后把第一个和第三个去掉<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | <span class="type">grep</span> <span class="string">"inet"</span>| <span class="type">grep</span> -v <span class="string">"127"</span> |<span class="type">grep</span> -v <span class="string">"0.0.0.0"</span></span><br></pre></td></tr></table></figure></p><p><img src="https://pic3.zhimg.com/v2-5c140f1052fa2322ffc76ff525d6b0a6_b.png" alt></p><p>然后这里要区分出有几列，很明显，有4列。然后取出第二列。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | <span class="type">grep</span> <span class="string">"inet"</span>| <span class="type">grep</span> -v <span class="string">"127"</span> |<span class="type">grep</span> -v <span class="string">"0.0.0.0"</span> | <span class="type">awk</span> '&#123;print $<span class="number">2</span>&#125;'</span><br></pre></td></tr></table></figure></p><p><img src="https://pic1.zhimg.com/v2-6e67847e1412b653c4dc3f8270a0bda0_b.png" alt></p><p>然后转换格式：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep <span class="string">"inet"</span>| grep -v <span class="string">"127"</span> |grep -v <span class="string">"0.0.0.0"</span> | awk '&#123;<span class="keyword">print</span> <span class="variable">$2&#125;</span>' | awk -F. '&#123;<span class="keyword">print</span> <span class="variable">$1</span><span class="string">"-"</span><span class="variable">$2</span><span class="string">"-"</span><span class="variable">$3</span><span class="string">"-"</span><span class="variable">$4&#125;</span>'</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-3d8f932a65e3be34b16b26e3f4f21243_b.png" alt></p><p>把前面输出的东西当作主机名：也就是   hostname  `名称`</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname  `  ifconfig | grep <span class="string">"inet"</span>| grep -v <span class="string">"127"</span> |grep -v <span class="string">"0.0.0.0"</span> | awk '&#123;<span class="keyword">print</span> <span class="variable">$2&#125;</span>' | awk -F. '&#123;<span class="keyword">print</span> <span class="variable">$1</span><span class="string">"-"</span><span class="variable">$2</span><span class="string">"-"</span><span class="variable">$3</span><span class="string">"-"</span><span class="variable">$4&#125;</span>'  `</span><br></pre></td></tr></table></figure><p>注意，这里有个<strong>反引号在外面包裹</strong>，这个符号在esc下面的地方，我的是和 ~ 在一起的。</p><h3 id="4、sed命令"><a href="#4、sed命令" class="headerlink" title="4、sed命令"></a>4、sed命令</h3><p>sed主要用于获取文件内容并修改显示，先是初始文件：</p><p><img src="https://pic2.zhimg.com/v2-70aec7aaa45221cca4974bdc0e05fa9d_b.jpg" alt></p><p>然后是我们的操作： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/jackhe/xiaohong/'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span>  <span class="comment">//单引号后面的s表示字符串替换，即把jackhe替换为xiaohong.</span></span><br></pre></td></tr></table></figure><p>最开始的  这里注意是有3个斜杠，而且它只是把文件的输出进行替换，并不进行文件的修改。</p><p><img src="https://pic4.zhimg.com/v2-0058420a1b0ce8dbd237a791f68916e3_b.jpg" alt></p><p>但是上面的只会把第一个出现的修改，而如果需要修改后面的则需要如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/jackhe/xiaohong/2'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span>  <span class="comment">//这是修改第二个。</span></span><br><span class="line">sed <span class="string">'s/jackhe/xiaohong/g'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span>  <span class="comment">//g是全部替换</span></span><br><span class="line">sed <span class="string">'s#jackhe#xiaohong#g'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span>  <span class="comment">//把斜杠改为井号也是可以的，这只是一个格式。</span></span><br><span class="line">sed <span class="string">'s#jackhe#xiao///.hong#g'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="comment">//也是可以的，这样#里面的都会变成字符处理。如果不是#号包裹，而是/，那么里面的/就需要进行转义，即 \/\/\/了</span></span><br><span class="line"></span><br><span class="line">sed -<span class="selector-tag">i</span> <span class="string">'s#jackhe#xiaohong#g'</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="comment">//如果要**真正的修改文件内容，那么就要加上个-i选项**。</span></span><br></pre></td></tr></table></figure></p><p><strong>如果sed里面有变量，则必须要用双引号了</strong>，不能使用单引号。</p>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
