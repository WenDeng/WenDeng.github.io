<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。"><title>《深度探索c++对象模型》（三）Data语意学 | 野渡 的博客</title><link rel="stylesheet" type="text/css" href="../../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="../../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../../atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《深度探索c++对象模型》（三）Data语意学</h1><a id="logo" href="../../../../../.">野渡 的博客</a><p class="description">路漫漫其修远兮 吾将上下而求索！</p></div><div id="nav-menu"><a class="current" href="../../../../../."><i class="fa fa-home"> 首页</i></a><a href="../../../../../archives/"><i class="fa fa-book"> 归档</i></a><a href="../../../../../timeline/"><i class="fa fa-edit"> 时间线</i></a><a href="../../../../../atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="../../../../../about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《深度探索c++对象模型》（三）Data语意学</h1><div class="post-meta">May 18, 2019<span> | </span><span class="category"><a href="../../../../../categories/C-基础/">C++基础</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前述"><span class="toc-text">前述</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#0、本章基础"><span class="toc-text">0、本章基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-空类对象的大小是多少？"><span class="toc-text">1. 空类对象的大小是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-class-object的size会受到哪些因素的影响？"><span class="toc-text">2. class object的size会受到哪些因素的影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-各种类型data-member的存放。"><span class="toc-text">3. 各种类型data member的存放。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Data-member的绑定"><span class="toc-text">一、Data member的绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-member-function取用的是global还是local-data-member"><span class="toc-text">1. member function取用的是global还是local data member?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-member-function的argument-list的情况又是怎么样的呢"><span class="toc-text">2. member function的argument list的情况又是怎么样的呢?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Data-member的布局"><span class="toc-text">二、Data member的布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Data-member是怎样被放置的？"><span class="toc-text">1. Data  member是怎样被放置的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Data-member的存取"><span class="toc-text">三、Data member的存取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-经由一个class-object和一个指针存取data-member，有重大差异吗？"><span class="toc-text">1. 经由一个class object和一个指针存取data member，有重大差异吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、“继承”与Data-Member"><span class="toc-text">四、“继承”与Data Member</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-第一种情况：只要继承不要多态。"><span class="toc-text">1. 第一种情况：只要继承不要多态。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-第二种情况：加上多态。"><span class="toc-text">2. 第二种情况：加上多态。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-第三种情况：多重继承。"><span class="toc-text">3. 第三种情况：多重继承。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-第四种情况：虚拟继承。"><span class="toc-text">4. 第四种情况：虚拟继承。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、对象成员的效率"><span class="toc-text">5、对象成员的效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、指向Data-members的指针-Pointer-to-Data-Members"><span class="toc-text">五、指向Data members的指针(Pointer to Data Members)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-如果获取Data-member的偏移值？偏移值应该为多少？"><span class="toc-text">1. 如果获取Data member的偏移值？偏移值应该为多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-“指向Member的指针”对数据的存取有什么影响？"><span class="toc-text">2.“指向Member的指针”对数据的存取有什么影响？</span></a></li></ol></li></div></div><div class="post-content"><p>本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。<br><a id="more"></a></p>
<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote>
<p>本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。</p>
</blockquote>
<hr>
<p>参考书籍及链接：《深度探索c++对象模型》    </p>
<hr>
<h2 id="0、本章基础"><a href="#0、本章基础" class="headerlink" title="0、本章基础"></a>0、本章基础</h2><h4 id="1-空类对象的大小是多少？"><a href="#1-空类对象的大小是多少？" class="headerlink" title="1. 空类对象的大小是多少？"></a>1. 空类对象的大小是多少？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; &#125;;<span class="comment">//空类</span></span><br></pre></td></tr></table></figure>
<p>对于空类，它有一个隐藏的1byte大小，那个被编译器安插进去的一个char,这使得这一class的两个objects得以在内存中配置独一无二的地址。</p>
<h4 id="2-class-object的size会受到哪些因素的影响？"><a href="#2-class-object的size会受到哪些因素的影响？" class="headerlink" title="2. class object的size会受到哪些因素的影响？"></a>2. class object的size会受到哪些因素的影响？</h4><p>会影响class object的size的因素有如下三个，编译器：</p>
<ul>
<li><ol>
<li>语言本身所造成的额外负担：当语言支持virtual base classes时，就会导致一些额外负担。需要一个指针，它或者指向virtual base class subobject,或者指向一个相关的表格，表格用于存储subobject地址或偏移值。</li>
</ol>
</li>
<li><ol start="2">
<li>编译器对于特殊情况所提供的优化处理：Virtual base class subobject的1 byte大小也会出现在derived class上。</li>
</ol>
</li>
<li><ol start="3">
<li>Alignment（边界对齐）的限制：在大部分的机器上，聚合的结构体大小会受到alignment的限制，使他们能够更有效率地在内存中被存取。比如32机器字上就是4的整数倍。</li>
</ol>
</li>
</ul>
<h4 id="3-各种类型data-member的存放。"><a href="#3-各种类型data-member的存放。" class="headerlink" title="3. 各种类型data member的存放。"></a>3. 各种类型data member的存放。</h4><p>nonstatic直接放在class object之中。static data member放置在程序的一个global data segment中，不会影响个别class object的大小。无论class产生多少个object,甚至是0个，其static data members永远也只存在一份实例。<strong>但是一个template classs的static data members的行为稍有不同。</strong></p>
<h2 id="一、Data-member的绑定"><a href="#一、Data-member的绑定" class="headerlink" title="一、Data member的绑定"></a>一、Data member的绑定</h2><h4 id="1-member-function取用的是global还是local-data-member"><a href="#1-member-function取用的是global还是local-data-member" class="headerlink" title="1. member function取用的是global还是local data member?"></a>1. member function取用的是global还是local data member?</h4><p>当member funtion取用Data时，优先考虑member data,人们称这种情况为“member rewriting rule”，意思是对于member functions本身的分析，会直到整个class的声明都出现了才开始。在一个inline member function躯体之内的一个data member绑定操作，会在整个class声明之后才发生。</p>
<blockquote>
<p>以前人们提倡两种程序设计风格，即将所有的data members放在class声明起始处，或者把所有的inline  function都放在class声明之外。就是为解决绑定问题，但这种情况在c++ 2.0之后已经解决了。 </p>
</blockquote>
<h4 id="2-member-function的argument-list的情况又是怎么样的呢"><a href="#2-member-function的argument-list的情况又是怎么样的呢" class="headerlink" title="2. member function的argument list的情况又是怎么样的呢?"></a>2. member function的argument list的情况又是怎么样的呢?</h4><p>与取用data member不同的是，argument list中的名称还是会在它们第一次 遭遇时被适当地决议（resolved）完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span> </span>&#123; _val=val;&#125; <span class="comment">//length被决议为global</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;<span class="comment">//这样的声明将使先前的参考操作不合法</span></span><br><span class="line">    length _val;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>虽然编译器能处理，但还是提倡一种防御性程序风格：即总是把“nested（嵌套的） type声明”放在class的起始处。    </p>
</blockquote>
<h2 id="二、Data-member的布局"><a href="#二、Data-member的布局" class="headerlink" title="二、Data member的布局"></a>二、Data member的布局</h2><h4 id="1-Data-member是怎样被放置的？"><a href="#1-Data-member是怎样被放置的？" class="headerlink" title="1. Data  member是怎样被放置的？"></a>1. Data  member是怎样被放置的？</h4><p>关于data member的布局，记住以下三点：</p>
<ul>
<li>nonstatic data members在class object中的排列顺序和其被声明的顺序一样，任何中间介入的static data members都不会被放进对象布局之中。       </li>
<li>C++ standard允许编译器将多个access sections(也就是private、public、protected等区段)之中的data members整体自由排列，不必在乎他们的出现在class中的声明顺序（连续的两个privata也算两个section）。 </li>
<li>编译器还可能会合成一些内部使用的data members，以支持整个对象模型，vptr就是这样的东西，当前所有的编译器都把它安插在每一个“内含virtual function之class”的object内。</li>
</ul>
<h2 id="三、Data-member的存取"><a href="#三、Data-member的存取" class="headerlink" title="三、Data member的存取"></a>三、Data member的存取</h2><h4 id="1-经由一个class-object和一个指针存取data-member，有重大差异吗？"><a href="#1-经由一个class-object和一个指针存取data-member，有重大差异吗？" class="headerlink" title="1. 经由一个class object和一个指针存取data member，有重大差异吗？"></a>1. 经由一个class object和一个指针存取data member，有重大差异吗？</h4><p>答案是显然的，这跟data member的类型和class的继承等都有关系，分如下两种情况讨论：</p>
<ul>
<li><p><strong>data member 为 static</strong><br>static data members会被编译器提出于class之外，并被视为一个global变量(但只在class生命范围内可见)。每一个static data member只有一个实例，存放在程序的data segment之中，通过一个指针和通过一个对象来存取data member都是一样的。  </p>
<p>若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其class member的指针，因为static member并不内含在一个class object之中。   </p>
<p>如果有两个classes，每一个都声明了一个同名的static member，编译器就会暗中对每一个static data member编码(对于这种手法有个很美的名称：name-mangling)，以获得一个独一无的程序识别代码。</p>
</li>
<li><p><strong>data member 为 nonstatic</strong><br>Nonstatic data members直接存放在每一个class object之中。只有经过class object才能存取它们（implicit 存取如this指针）。欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置(offset)。     </p>
<p>每一个nonstatic data member的偏移位置(offset)在编译时期即可获知，甚至如果member属于一个base class subobject(派生自单一或多重继承串链)也是一样的。因此，存取一个nonstatic data member，其效率和存取一个C struct member或一个nonderived class的member是一样的。</p>
<p>但是如果该data member是一个virtual base class 的member,那么通过<strong>指针</strong>的存取速度会稍慢一点。（指针的真正class type 只有在执行器才真正确定）。  </p>
</li>
</ul>
<h2 id="四、“继承”与Data-Member"><a href="#四、“继承”与Data-Member" class="headerlink" title="四、“继承”与Data Member"></a>四、“继承”与Data Member</h2><blockquote>
<p>C++ standard未强制指定derived class members和base class members的排列顺序，理论上编译器可以自由安排之。在大部分编译器上头，base class members总是先出现，但属于virtual base class的除外。“继承”会对Data Member的布局有什么影响？接下来分四种情况进行讨论。</p>
</blockquote>
<h4 id="1-第一种情况：只要继承不要多态。"><a href="#1-第一种情况：只要继承不要多态。" class="headerlink" title="1. 第一种情况：只要继承不要多态。"></a>1. 第一种情况：只要继承不要多态。</h4><p>这种情况不会存储时间上的额外负担，由于base class和derived class的objects都是从相同的地址开始，其差异只在于derived object 比较大，用以容纳自建的nonstatic data members，把一个derived class object指定给base class 的指针或引用，并不需要编译器去调停或修改地址，可以提供了最佳执行效率。</p>
<h4 id="2-第二种情况：加上多态。"><a href="#2-第二种情况：加上多态。" class="headerlink" title="2. 第二种情况：加上多态。"></a>2. 第二种情况：加上多态。</h4><p>加上virtual function接口后，弹性增加了，但也同时增加了空间和存取时间上的额外负担，如何取舍，视多态程序所带来的利益。可能带来的额外负担如下：</p>
<ul>
<li>导入一个和virtual table ，用来存储它所声明的每一个virtual functions的地址。再加上一两个slots(type_info)。</li>
<li>在每一个class object中导入一个vptr,提供执行期的链接，使每一个object能够找到相应的virtual table。</li>
<li>加强constructor，使它能够为vptr设定初始值，让它指向class所对应的virtual table。</li>
<li>加强destructor，使它能够消抹“指向class 相关virtual table”的vptr。</li>
</ul>
<h4 id="3-第三种情况：多重继承。"><a href="#3-第三种情况：多重继承。" class="headerlink" title="3. 第三种情况：多重继承。"></a>3. 第三种情况：多重继承。</h4><p>对于单一继承，如果没有virtual function，那么编译器就不需要做其他工作;但如果base class没有virtual function而derived class有，并且vptr放在object首部，那么当把一个derived object转换为其base object时，就需要编译器对vptr进行调整。在既是多重继承又是虚拟继承的情况下，编译器的需要做的会更多。<br>对一个多重派生对象，将其地址指定给“最左端(也就是第一个)base class的指针”，情况将和单一继承时相同，因为二者都指向相同的起始地址。至于第二个或后继的base class的地址指定操作，则需要将地址修改为：加上(或减去)介于中间的base class subobjects大小。比较需要注意的是，如果在取drived class object的地址时进行偏移计算时，若其为指针，就需要判断其是否为0，若为0则基类object的地址也应为0。<strong>当然，这些都是编译器的工作，我们需要了解，但不需要自己去实现。</strong></p>
<blockquote>
<p>如果要存取第二个(或后继)base class中的一个data member会是怎样的情况？需要付出额外的成本吗？ 不，members的位置在编译期就固定了，因此，存取members只是一个简单的offset运算，就像单一继承一样简单，不管是经由一个指针，一个reference或是一个object来存取。</p>
</blockquote>
<h4 id="4-第四种情况：虚拟继承。"><a href="#4-第四种情况：虚拟继承。" class="headerlink" title="4. 第四种情况：虚拟继承。"></a>4. 第四种情况：虚拟继承。</h4><p>虚拟继承的出现是为了避免多个相同base class subobject的出现，将其只保留一份，从而减少空间浪费。<br>class如果含有一个或多个virtual base class subobjects将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，总是能有固定的offset，这部分可以被直接存取，至于共享部分，所表现的就是virtual base class subobject ，这个部分数据，其位置因为每次派生操作而有变化，所以只能间接存取。</p>
<blockquote>
<p>一般而言，virtual base class最有效的一种运用形式就是：一个抽象的virtual base class，没有任何data members。</p>
</blockquote>
<h4 id="5、对象成员的效率"><a href="#5、对象成员的效率" class="headerlink" title="5、对象成员的效率"></a>5、对象成员的效率</h4><p>程序员如果只关心起程序效率，应该实际测试，不能光凭推论、常识判断或假设。<br>参考书籍作者所做的测试表明，虚拟继承所造成确实会严重影响data member的存取效率。</p>
<h2 id="五、指向Data-members的指针-Pointer-to-Data-Members"><a href="#五、指向Data-members的指针-Pointer-to-Data-Members" class="headerlink" title="五、指向Data members的指针(Pointer to Data Members)"></a>五、指向Data members的指针(Pointer to Data Members)</h2><h4 id="1-如果获取Data-member的偏移值？偏移值应该为多少？"><a href="#1-如果获取Data-member的偏移值？偏移值应该为多少？" class="headerlink" title="1. 如果获取Data member的偏移值？偏移值应该为多少？"></a>1. 如果获取Data member的偏移值？偏移值应该为多少？</h4><p>通过如（&amp;Point3d::z）这样的操作可以获得data member的偏移值。实际测试表明所获得的offset比预想大1，这是为什么？实际上这样做的目的是为了区分一个“没有指向任何data member”的指针，和一个指向“第一个data member”的指针的情况。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;<span class="comment">//“没有指向任何data member”的指针</span></span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::x;<span class="comment">//指向“第一个data member”的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1 == p2) <span class="comment">//如何区分?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 &amp; p2 contain the same value --"</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" they must address the same member!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，不论编译器或使用者都必须记住，在真正使用该值以指出一个member之前，请先减掉1。</p>
<h4 id="2-“指向Member的指针”对数据的存取有什么影响？"><a href="#2-“指向Member的指针”对数据的存取有什么影响？" class="headerlink" title="2.“指向Member的指针”对数据的存取有什么影响？"></a>2.“指向Member的指针”对数据的存取有什么影响？</h4><p>无继承时，指向member的指针对数据的存取操作，首先需要计算offset-1,其次具体的object需要用offset计算地址，会极大地降低效率，但目前的一些编译器提供了对应的优化，可以使其像直接通过对象取值一下快速。<br>有继承时，data member是直接放在class object中的，理论上不会影响代码的效率，但继承的使用会妨碍优化的效果。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>野渡</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/18/深度探索c++对象模型/《深度探索c++对象模型》（三）/">http://WenDeng.github.io/2019/05/18/深度探索c++对象模型/《深度探索c++对象模型》（三）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请务必获得作者的允许</li></ul></div><br><div class="tags"><a href="../../../../../tags/C-基础/">C++基础</a></div><div class="post-nav"><a class="pre" href="../../../19/深度探索c++对象模型/《深度探索c++对象模型》（四）/">《深度探索c++对象模型》（四）Function语意学</a><a class="next" href="../../../17/深度探索c++对象模型/《深度探索c++对象模型》（二）/">《深度探索c++对象模型》（二）构造函数语意学</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/C-基础/">C++基础</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/网络协议/">网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/项目工具/">项目工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../../tags/C-基础/" style="font-size: 15px;">C++基础</a> <a href="../../../../../tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="../../../../../tags/字典树/" style="font-size: 15px;">字典树</a> <a href="../../../../../tags/trie树/" style="font-size: 15px;">trie树</a> <a href="../../../../../tags/Iptabls/" style="font-size: 15px;">Iptabls</a> <a href="../../../../../tags/Netfilter/" style="font-size: 15px;">Netfilter</a> <a href="../../../../../tags/git使用/" style="font-size: 15px;">git使用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="../../../22/深度探索c++对象模型/《深度探索c++对象模型》（七）/">《深度探索c++对象模型》（七）站在对象模型的顶端</a></li><li class="post-list-item"><a class="post-list-link" href="../../../21/深度探索c++对象模型/《深度探索c++对象模型》（六）/">《深度探索c++对象模型》（六）执行期语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../20/深度探索c++对象模型/《深度探索c++对象模型》（五）/">《深度探索c++对象模型》（五）构造、析构、拷贝语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../19/深度探索c++对象模型/《深度探索c++对象模型》（四）/">《深度探索c++对象模型》（四）Function语意学</a></li><li class="post-list-item"><a class="post-list-link" href>《深度探索c++对象模型》（三）Data语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../17/深度探索c++对象模型/《深度探索c++对象模型》（二）/">《深度探索c++对象模型》（二）构造函数语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../17/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/项目工具/git中的仓库崩溃后的如何恢复/">git中的仓库崩溃后的如何恢复</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/算法与数据结构/1.保卫方案/">1.保卫方案</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/算法与数据结构/2.异或/">2.异或</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antfaiz5z.github.io/" title="antFaiz5z's Fantastic Fertilizer" target="_blank">antFaiz5z's Fantastic Fertilizer</a><ul></ul><a href="http://www.example1.com/" title="大城小爱" target="_blank">大城小爱</a><ul></ul><a href="http://www.example2.com/" title="大五四刘" target="_blank">大五四刘</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="../../../../../." rel="nofollow">野渡 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="../../../../../js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="../../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>