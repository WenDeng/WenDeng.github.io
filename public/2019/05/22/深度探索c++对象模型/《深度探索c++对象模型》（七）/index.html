<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。"><title>《深度探索c++对象模型》（七）站在对象模型的顶端 | 野渡 的博客</title><link rel="stylesheet" type="text/css" href="../../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="../../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../../atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《深度探索c++对象模型》（七）站在对象模型的顶端</h1><a id="logo" href="../../../../../.">野渡 的博客</a><p class="description">路漫漫其修远兮 吾将上下而求索！</p></div><div id="nav-menu"><a class="current" href="../../../../../."><i class="fa fa-home"> 首页</i></a><a href="../../../../../archives/"><i class="fa fa-book"> 归档</i></a><a href="../../../../../timeline/"><i class="fa fa-edit"> 时间线</i></a><a href="../../../../../atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="../../../../../about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《深度探索c++对象模型》（七）站在对象模型的顶端</h1><div class="post-meta">May 22, 2019<span> | </span><span class="category"><a href="../../../../../categories/C-基础/">C++基础</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前述"><span class="toc-text">前述</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Template"><span class="toc-text">一、Template</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-template的“实例化”行为"><span class="toc-text">1.template的“实例化”行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、效率有了，弹性呢？"><span class="toc-text">四、效率有了，弹性呢？</span></a></li></div></div><div class="post-content"><p>本章的的主题是站在对象模型的尖端，套路哦三个著名的c++语言扩充性质，它们都会影响c++对象，他们分别是exception handling（EH）、template support、runtime type identification(RTTI)。<br><a id="more"></a></p>
<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote>
<p>本章的的主题是站在对象模型的尖端，套路哦三个著名的c++语言扩充性质，它们都会影响c++对象，他们分别是exception handling（EH）、template support、runtime type identification(RTTI)。</p>
</blockquote>
<hr>
<h2 id="一、Template"><a href="#一、Template" class="headerlink" title="一、Template"></a>一、Template</h2><p>这一节的焦点放在template的语意上面，我们将讨论templates在编译系统中“何时”，“为什么”以及“如何”发挥其功能。下面是有关template的三个主要讨论方向：</p>
<ul>
<li>template的声明，基本上来说就是当你声明一个template class、template class member function等等，会发生什么事情。</li>
<li>如何”实例化”class object、inline nonmember以及member template functions，这些是”每一个编译单元都会拥有的一份实体”的东西。</li>
<li>如何“实例化”出nonmember、member templates functions以及static template class members，这些都是”每一个可执行文件中只需要一份实体”的东西，这也就是一般而言template所带来的问题。</li>
</ul>
<h4 id="1-template的“实例化”行为"><a href="#1-template的“实例化”行为" class="headerlink" title="1.template的“实例化”行为"></a>1.template的“实例化”行为</h4><p>对于如下template class:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123; unallocated, normalized &#125;;</span><br><span class="line">    </span><br><span class="line">    Point(Type x = <span class="number">0.0</span>, Type y = <span class="number">0.0</span>, Type z = <span class="number">0.0</span>);</span><br><span class="line">    ~Point();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span> )</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Point&lt;Type&gt; *freeList;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">    Type _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译器对于template class会根据type的不同而产生不同的实例class。</p>
<ul>
<li>enum Status、freeList、chunkSize以及object都必须进行实例化，如<figure class="highlight plain"><figcaption><span>```,而不能是```Point::freeList; ```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 定义一个指针，指向特定的实例。例如``` Point&lt;float&gt; *ptr=0;```因为一个指向class object的指针，本身并不是一个class object，编译器不需要知道与该class有关的任何member的数据或object的布局数据。所以不需要实例化。</span><br><span class="line">* 定义一个reference,例如```Point&lt;float&gt; &amp;refer=0; ```就需要产生一个Point的float实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.member function需要实例化吗？</span><br><span class="line">member functions(至少对于那些未被使用过的)不应该被“实体”化，只有在member functions被使用的时候，C++ Standard才要求它们被“实例化”。当前的编译器并不精 确遵循这项要求，之所以由使用者来主导“具现”规则，有两个主要原因：</span><br><span class="line">* 空间和时间效率的考虑。如果class中有100个member functions，但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中5个，那么其他193个函数都“具现”将花费大量的时间和空间。</span><br><span class="line">* 尚未实现的功能，并不是一个template实例化的所有类型就一定能够支持一组member functions所需要的所有运算符。如果只“具现”那些真正用到的memeber functions，template就能够支持那些原本可能会造成编译时期错误的类型(types)。</span><br><span class="line"></span><br><span class="line">#### 3.template的错误报告。</span><br><span class="line">目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行以有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让它通过了，只有在特定实例被定义之后，才能发出抱怨。这是目前实现技术上的一个大问题。</span><br><span class="line"></span><br><span class="line">#### 4.Template中的名称决议法。</span><br><span class="line">Template有两种语境，一种是C++ Standard所谓的&quot;Scope of the template definition&quot;，也就是“定义出template”的程序。另一种是C++ Standard所谓的&quot;scope of the template instantiation&quot;，也就是说“具现出template”的程序。        </span><br><span class="line">Template之中，对于一个nonmember name的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而设定的。如果其使用互不相关，那么就以“scope of the template declaration”来决定name。如果其使用互有关联，那么就以“scope of template instantiation”来决定name。例如：</span><br></pre></td></tr></table></figure></li>
</ul>
<p>//scope of the template definition<br>extern double foo(double); </p>
<p>template<class type><br>class ScopeRules{<br>public:<br>    void invariant() { _member = foo(val); }<br>    type type_dependent() {return foo(_member);}<br>    //…<br>private:<br>    int _val;<br>    type _member;<br>};</class></p>
<p>//scope of the template instantiation<br>extern int foo(int);<br>//…<br>ScopeRultes<int> sr0;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 对于```sr0.invariant(); ```由于被用来实例化这个<span class="keyword">template</span>的真正类型，对于 \_val的类型并没有影响。所以选中``` <span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure></int></p>
<ul>
<li>对于<figure class="highlight plain"><figcaption><span>```\_member与template参数有关,所以选中的foo()跟参数有关,所以选中```extern int foo(int);```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 5.Member function的实例化行为。</span><br><span class="line">对于template的支持，最困难的莫过于template function的实例化，目前的编译器提供了 两个策略：一个是编译时期策略，程序代码必须在program text file中备妥可用；另一个是链接时期策略，程序代码必须在meta-compliation工具可以导引编译器的实例化行为(instantiation)。       </span><br><span class="line">下面是编译器设计者必须回答的三个主要问题：</span><br><span class="line">* （1）编译器如何找出函数的定义？     </span><br><span class="line">答案之一是包含template program text file，就好像它是个header文件一样，Borland编译器就是遵循这个策略。另一种方法是要求一个文件命名规则，例如，我们可以要求，在Point.h文件中发现的函数声明，其template program text一定要放置于文件Point.c或者Point.cpp中，以此类推。cfront就是遵循这个策略。Edison Desigin Group编译器对此两种策略都支持。</span><br><span class="line">* （2）编译器如何能够只实例化出程序中用到的member functions?     </span><br><span class="line">解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的——虽然它也提供#pragmas让你压制(或具现出)特定实体。另一种策略就是仿真链接操作，检测看看哪一个函数真正需要，然后只为它(们)产生实体。cfront就是这么做的，Edison Design Group编译器对此两种策略都支持。</span><br><span class="line">* （3）编译器如何阻止member definitions在多个.o文件中都被实例化呢?       </span><br><span class="line">解决办法之一是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另外一个办法就是由使用者来导引“仿真链接阶段”的实例化策略，决定哪些实体(instances)才是所需求的。</span><br><span class="line"></span><br><span class="line">实际上，template instantiation似乎拒绝全面自动化，甚至居然没意见工作都对了，产生出来的object files的重新编译成本仍然可能很高。**以手动方式先在个别的object module中完成预先实例化操作，虽然沉闷，却是唯一有效率的方法。**</span><br><span class="line"></span><br><span class="line">## 二、异常处理</span><br><span class="line">#### 1.编译对异常处理的支持</span><br><span class="line">欲支持exception handling，编译器的主要工作就是找出catch子句，以处理被丢出来的exception。这多少需要追踪程序堆栈中的每一个函数当前作用区域(包括追踪函数中的local class objects当时的情况)。同时，编译器必须提供某种查询exception objects的方法，以知道其实际类型(这直接导致某种形式的执行期识别，也就是RTTI)。最后，还需要某种机制用以管理被丢出的object，包括它的产生、储存、可能的解构(如果有相关的destructor)、清理(clean up)以及一般存取，也可能有一个以上的objects同时起作用。      </span><br><span class="line"></span><br><span class="line">一般而言，exception handling机制需要与编译器所产生的数据结构以及执行期的一个exception library紧密合作，在程序大小和执行速度之间，编译器必须有所抉择：</span><br><span class="line">* 为了维持执行速度，编译器可以在编译时期建立起用于支持的数据结构，这会使程序大小膨胀，但编译器可以几乎忽略这些结构，直到有个exception被丢出来。</span><br><span class="line">* 为了维持程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构(并且可以抛弃之)。</span><br><span class="line"></span><br><span class="line">#### 2.Exception Handling 快速检阅</span><br><span class="line">C++的exception handing由三个主要的语汇组件构成：</span><br><span class="line">* 一个throw子句。它在程序某处发出一个exception。被抛出去的expection可以是內建类型，也可以是使用者自定类型。</span><br><span class="line">* 一个或多个catch子句。每一个catch子句都是一个exception handler。它用来表示说，这个子句准备处理某种类型的exception，并且在封闭的大括号区段中提供实际的处理程序</span><br><span class="line">* 一个try区段。它被围绕以一系列的叙述句(statements)，这些叙述句可能会引发catch子句起作用  </span><br><span class="line"></span><br><span class="line">当一个exception被丢出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate()会被调用。当控制权被抛弃后，堆栈中的每一个函数调用也就被推离(popped up)，这个程序称为unwinding the stack。**在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用。**</span><br><span class="line"></span><br><span class="line">#### 3.对Exception Handling的支持</span><br><span class="line">当一个exception发生时，编译系统必须完成以下事情：    </span><br><span class="line">（1）检验发生throw操作的函数；   </span><br><span class="line">（2）决定throw操场是否发生在try区段中；   </span><br><span class="line">（3）若是，编译系统必须把exception type拿来和每一个catch子句比较；   </span><br><span class="line">（4）如果比较吻合，流程控制应该交到catch子句手中；    </span><br><span class="line">（5）如果throw的发生并不在try区段中，并没有一个catch子句吻合，那么系统必须(a)摧毁所有active local objects，(b)从堆栈中将当前的函数&quot;unwind&quot;掉，(c)进行到程序堆栈中的下一个函数中去，然后重复上述步骤2~5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.当一个实际对象在程序执行时被丢出，会发生什么事？</span><br><span class="line">当一个exception被丢出时，exception object会被产生出来并通常放置在相同形式的exception数据堆栈中，从throw端传染给catch子句的是exception object的地址、类型描述器(或是一个函数指针，该函数会传回与该exception type有关的类型描述器对象)，以及可能会有的exception object描述器(如果有人定义它的话)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三、执行器类型识别（RTTI）</span><br><span class="line">RTTI是用于支持EH而获得的副产品，主要目的是处理和识别throw的object类型。</span><br><span class="line">#### 1.Type-Safe Downcast(保证安全的向下转型操作)</span><br><span class="line">一个type\-safe downcast(保证安全地向下转换操作)必须在执行期对指针有所查询，看看它是否指向它所展现(表达)之object的真正类型。因此，欲支持type-safe downcast在object空间和执行时间上都需要一些额外的负担：</span><br><span class="line">* 需要额外的空间以存储类型信息(type information)，通常是一个指针，指向某个类型信息节点</span><br><span class="line">* 需要额外的时间以决定执行期的类型(runtime type)，因为，正如其名所示，这需要再执行期才能决定。</span><br><span class="line"></span><br><span class="line">c\+\+的RTTI机制提供了一个安全的downcast设备,但只对那些展现“多态”的类型有效。c\+\+中，一个具备多态性质的class，正式内含着继承而来的virtual function。</span><br><span class="line"></span><br><span class="line">#### 2.Type-Safe Dynamic cast(保证安全的动态转型)</span><br><span class="line">dynamic\_cast运算符可以在执行期决定真正的类型。如果downcast是安全的，这个运算符会传回被适当转换过的指针。如果downcast不是安全地，这个运算符会传回0.</span><br><span class="line"></span><br><span class="line">#### 3.References并不是Pointers</span><br><span class="line">程序中对一个class指针类型施以dynamic_cast运算符，会获得true或false：</span><br><span class="line">* 如果传回真正的地址，表示这个object的动态类型被确认了，一些与类型相关的操作现在可以施行于其上。</span><br><span class="line">* 如果传回0，表示没有指向任何object，意味应该以另一种逻辑施行于这个动态类型未确定的object身上。</span><br><span class="line"></span><br><span class="line">dynamic_cast运算符也适用于reference身上。然而对于一个non-type-safe cast，其结果不会与施行于指针的情况相同。为什么？      </span><br><span class="line">一个reference不可以像指针那样&quot;把自己设为0就代表了&quot;no object&quot;；若将一个reference 设为0，会引起一个临时性对象(拥有被参考到的类型)被产生出来，该临时对象的初值为0，这个reference然后被设定成为该临时性对象的一个别名。   </span><br><span class="line">因此当dynamic_cast运算符施行于一个reference时，不能够提供对等于指针情况下的那一组true/false。取而代之的是，会发生下列事情：</span><br><span class="line">* 如果reference真正参考到适当的derived class(包括下一层或下下一层或下下下一层或...)，downcast会被执行而程序可以继续执行。</span><br><span class="line">* 如果reference并不真正是某一种derived class，那么，由于不能传回0，遂丢出一个bad_cast exception.</span><br><span class="line"></span><br><span class="line">#### 4.Typeid运算符</span><br><span class="line">typeid运算符传回一个const reference，类型为type_info。</span><br><span class="line">type_info object由什么组成？ C++ Standard中对type_info的定义如下：</span><br></pre></td></tr></table></figure></li>
</ul>
<p>class type_info{<br>public:<br>    virtual ~type_info();<br>    bool operator==(const type_info&amp; ) const;<br>    bool operator!=(const type_info&amp; ) const;<br>    bool before(const type_info&amp;) const;<br>    bool char* name() const;  //传回class原始名称<br>private:<br>    //prevent memberwise init and copy<br>    type_info(const type_info&amp; );<br>    type_info&amp; operator=(const type_info&amp; );<br>    //data members<br>};<br><code>`</code><br>编译器必须提供的最小量信息是class的真实名称、以及在type_info objects之间的某些排序算法(这就是before()函数目的)、以及某些形式的描述器，用以表现explicit class type和这个class的任何subtype。</p>
<h2 id="四、效率有了，弹性呢？"><a href="#四、效率有了，弹性呢？" class="headerlink" title="四、效率有了，弹性呢？"></a>四、效率有了，弹性呢？</h2><p>创痛的c++对对象模型提供有效率的执行期支持。这份效率，再加上与c之间的兼容性，造成了C++的广泛被接受。然而，在某些领域方面，像是动态共享库、共享内存以及分布式对象方面，这个对象模型的弹性还是不够。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>野渡</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/22/深度探索c++对象模型/《深度探索c++对象模型》（七）/">http://WenDeng.github.io/2019/05/22/深度探索c++对象模型/《深度探索c++对象模型》（七）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请务必获得作者的允许</li></ul></div><br><div class="tags"><a href="../../../../../tags/C-基础/">C++基础</a></div><div class="post-nav"><a class="next" href="../../../21/深度探索c++对象模型/《深度探索c++对象模型》（六）/">《深度探索c++对象模型》（六）执行期语意学</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/C-基础/">C++基础</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/网络协议/">网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/项目工具/">项目工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../../tags/C-基础/" style="font-size: 15px;">C++基础</a> <a href="../../../../../tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="../../../../../tags/字典树/" style="font-size: 15px;">字典树</a> <a href="../../../../../tags/trie树/" style="font-size: 15px;">trie树</a> <a href="../../../../../tags/Iptabls/" style="font-size: 15px;">Iptabls</a> <a href="../../../../../tags/Netfilter/" style="font-size: 15px;">Netfilter</a> <a href="../../../../../tags/git使用/" style="font-size: 15px;">git使用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href>《深度探索c++对象模型》（七）站在对象模型的顶端</a></li><li class="post-list-item"><a class="post-list-link" href="../../../21/深度探索c++对象模型/《深度探索c++对象模型》（六）/">《深度探索c++对象模型》（六）执行期语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../20/深度探索c++对象模型/《深度探索c++对象模型》（五）/">《深度探索c++对象模型》（五）构造、析构、拷贝语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../19/深度探索c++对象模型/《深度探索c++对象模型》（四）/">《深度探索c++对象模型》（四）Function语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../18/深度探索c++对象模型/《深度探索c++对象模型》（三）/">《深度探索c++对象模型》（三）Data语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../17/深度探索c++对象模型/《深度探索c++对象模型》（二）/">《深度探索c++对象模型》（二）构造函数语意学</a></li><li class="post-list-item"><a class="post-list-link" href="../../../17/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/项目工具/git中的仓库崩溃后的如何恢复/">git中的仓库崩溃后的如何恢复</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/算法与数据结构/1.保卫方案/">1.保卫方案</a></li><li class="post-list-item"><a class="post-list-link" href="../../../16/算法与数据结构/2.异或/">2.异或</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antfaiz5z.github.io/" title="antFaiz5z's Fantastic Fertilizer" target="_blank">antFaiz5z's Fantastic Fertilizer</a><ul></ul><a href="http://www.example1.com/" title="大城小爱" target="_blank">大城小爱</a><ul></ul><a href="http://www.example2.com/" title="大五四刘" target="_blank">大五四刘</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="../../../../../." rel="nofollow">野渡 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="../../../../../js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="../../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>