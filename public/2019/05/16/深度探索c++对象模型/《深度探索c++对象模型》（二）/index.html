<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。"><title>构造函数语意学 | 野渡 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">构造函数语意学</h1><a id="logo" href="/.">野渡 的博客</a><p class="description">路漫漫其修远兮 吾将上下而求索！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-book"> 归档</i></a><a href="/timeline/"><i class="fa fa-edit"> 时间线</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">构造函数语意学</h1><div class="post-meta">May 16, 2019<span> | </span><span class="category"><a href="/categories/C-基础/">C++基础</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前述"><span class="toc-text">前述</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Default-Constructor的构造操作"><span class="toc-text">一、Default Constructor的构造操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-什么时候才会合成一个default-construct呢？"><span class="toc-text">1. 什么时候才会合成一个default construct呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-几种对象构建时的区别。"><span class="toc-text">2. 几种对象构建时的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-第一种情况：“带有Default-Constructor”的member-class-object"><span class="toc-text">3. 第一种情况：“带有Default Constructor”的member class object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-多成员对象的情况。"><span class="toc-text">4. 多成员对象的情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-第二种情况：“带有Default-constructor”的base-class。"><span class="toc-text">5. 第二种情况：“带有Default constructor”的base class。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-第三种情况：“带有一个Virtual-Funtion”的class。"><span class="toc-text">6. 第三种情况：“带有一个Virtual Funtion”的class。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-第四种情况：“带有一个virtual-base-class”的class。"><span class="toc-text">7. 第四种情况：“带有一个virtual base class”的class。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-总结。"><span class="toc-text">8. 总结。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Copy-Constructor的构造操作"><span class="toc-text">二、Copy Constructor的构造操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-哪些情况需要有copy-constructor？"><span class="toc-text">1. 哪些情况需要有copy constructor？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Default-Memberwise-Initialization"><span class="toc-text">2. Default Memberwise Initialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-递归的memberwise-initialization是如何实现的呢？"><span class="toc-text">3. 递归的memberwise initialization是如何实现的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Memberwise-copy-深拷贝-与Bitwise-copy-浅拷贝-的区别"><span class="toc-text">4. Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-什么时候一个class不展现出“bitwise-copy-semantics”呢？"><span class="toc-text">5. 什么时候一个class不展现出“bitwise copy semantics”呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-重新设定Virtual-Table的指针（virtual-funtion的情况）"><span class="toc-text">6. 重新设定Virtual Table的指针（virtual funtion的情况）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-如何处理virtual-base-class-subobject的情况？"><span class="toc-text">7. 如何处理virtual base class subobject的情况？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、程序转化语意学-Program-Transformation-Semantics"><span class="toc-text">三、程序转化语意学(Program Transformation Semantics)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-class-object的显式初始化操作。"><span class="toc-text">1. class object的显式初始化操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-参数的初始化所做的程序转换。"><span class="toc-text">2. 参数的初始化所做的程序转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-返回值的初始化所做的程序转换。"><span class="toc-text">3. 返回值的初始化所做的程序转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-在编译器层面所做的优化。"><span class="toc-text">4. 在编译器层面所做的优化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-那Copy-Constructor要还是不要？"><span class="toc-text">5. 那Copy Constructor要还是不要？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、成员们的初始化队伍-Memeber-Initialization-List"><span class="toc-text">四、成员们的初始化队伍(Memeber Initialization List)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-在下列情况下，为了让你的程序能够顺利编译，你必须使用member-initialization-list"><span class="toc-text">1. 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-member-initialization-list中到底会发生什么事情？"><span class="toc-text">2.member initialization list中到底会发生什么事情？</span></a></li></ol></li></div></div><div class="post-content"><p>本章的的主题是构造函数语意学，主要是讨论constructor如何工作，以及它什么时候被合成，同时挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。<br><a id="more"></a></p>
<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote>
<p>本章的的主题是构造函数语意学，主要是讨论constructor如何工作，以及它什么时候被合成，同时挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。</p>
</blockquote>
<hr>
<p>参考书籍及链接：《深度探索c++对象模型》    </p>
<hr>
<h2 id="一、Default-Constructor的构造操作"><a href="#一、Default-Constructor的构造操作" class="headerlink" title="一、Default Constructor的构造操作"></a>一、Default Constructor的构造操作</h2><h4 id="1-什么时候才会合成一个default-construct呢？"><a href="#1-什么时候才会合成一个default-construct呢？" class="headerlink" title="1. 什么时候才会合成一个default construct呢？"></a>1. 什么时候才会合成一个default construct呢？</h4><p>   答案是当编译器需要的时候，default constructor会被合成出来，只执行编译器所需要的任务。另外要注意程序的需要和编译器的需要之间的区别，如果程序有需要，那是程序员的责任，就需要自己实现constructor。<br>   对于class X，如果没有任何user-declared constructor，那么会有一个default constructor被隐式(implicitly)声明出来…一个被隐式声明出来的default constructor将是一个trivial(浅薄而无能，没啥用的)constructor…<br>   一个nontrivial default constructor在ARM的术语中就是编译器需要的那种，必要的话由编译器合成出来。下面4小节分别讨论nontrivial default constructor的4种情况</p>
<h4 id="2-几种对象构建时的区别。"><a href="#2-几种对象构建时的区别。" class="headerlink" title="2. 几种对象构建时的区别。"></a>2. 几种对象构建时的区别。</h4><p>   Global objects的内存保证会在程序启动的时候被清0。Local objects配置于程序的堆栈中，heap objects配置于自由空间，都不一定会被清零，它们的内容将是内存上次被使用的遗迹。</p>
<h4 id="3-第一种情况：“带有Default-Constructor”的member-class-object"><a href="#3-第一种情况：“带有Default-Constructor”的member-class-object" class="headerlink" title="3. 第一种情况：“带有Default Constructor”的member class object"></a>3. 第一种情况：“带有Default Constructor”的member class object</h4><p>如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是“nontrivial”，编译器为该class合成出一个default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。</p>
<h4 id="4-多成员对象的情况。"><a href="#4-多成员对象的情况。" class="headerlink" title="4. 多成员对象的情况。"></a>4. 多成员对象的情况。</h4><p>编译器的处理是：如果一个class A内含一个或者一个以上member class objects，那么class A的每一个constructor必须调用每一个member classes 的default constructor。编译器会扩张已存在的constructors,在其中安插一些代码，使得user code在被执行之前，先调用必要的default constructors。<strong>调用顺序与member objects在class中的声明次序一致</strong>。</p>
<h4 id="5-第二种情况：“带有Default-constructor”的base-class。"><a href="#5-第二种情况：“带有Default-constructor”的base-class。" class="headerlink" title="5. 第二种情况：“带有Default constructor”的base class。"></a>5. 第二种情况：“带有Default constructor”的base class。</h4><p>如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。对于一个后继派生的class而言，这个合成的constructor和一个“被显式提供的default constructor”并没有差异。</p>
<blockquote>
<p>注意一点，如果有constructor,但没有default constructor,那就会对每一个constructors进行扩充。如果亦存在Member Class Object，那些default constructor也会在base class constructor都被调用之后调用。</p>
</blockquote>
<h4 id="6-第三种情况：“带有一个Virtual-Funtion”的class。"><a href="#6-第三种情况：“带有一个Virtual-Funtion”的class。" class="headerlink" title="6. 第三种情况：“带有一个Virtual Funtion”的class。"></a>6. 第三种情况：“带有一个Virtual Funtion”的class。</h4><p>如果class声明(或继承)一个virtual function，编译器也需要合成出default constructor或扩充construtor。下面两个扩张行动会在编译期间发生：</p>
<ul>
<li>一个virtual function table(在cfront中被称为vtbl)会被编译期产生出来，内放class的virtual functions地址。</li>
<li>在每一个class object中，一个额外的pointer member(也就是vptr)会被编译期合成出来，内含相关之class vtbl的地址。</li>
</ul>
<blockquote>
<p>编译器会为每一个含有virtual function的class objects的vptr进行适当的初始化，以放置适当的virtual table地址。</p>
</blockquote>
<h4 id="7-第四种情况：“带有一个virtual-base-class”的class。"><a href="#7-第四种情况：“带有一个virtual-base-class”的class。" class="headerlink" title="7. 第四种情况：“带有一个virtual base class”的class。"></a>7. 第四种情况：“带有一个virtual base class”的class。</h4><p>如果class派生自一个继承串链，其中有一个或更多的virtual base classes编译器也需要合成出default constructor或扩充construtor。其目的在于必须使 virtual base class 在其每一个derived class object中的位置能够在执行期准备妥当。对于class所定义的每一个constructor。编译器都会安插那些“允许每一个virtual base class 的执行期存取操作”的代码。</p>
<h4 id="8-总结。"><a href="#8-总结。" class="headerlink" title="8. 总结。"></a>8. 总结。</h4><p>除以上四种情况外，在没有声明constructor时就默认其是无用的， 其default constructor也就不会被合成出来的。<br>在合成的default constructor中，只有base class subobjects和member class objects会被初始化。所有其他的nonstatic data member ，如整数，整数指针，整数数组等是不会被初始化的，这些初始化操作对程序是必须的，但对编译器则并非需要的。<br>C++新手一般有两个误解：</p>
<ul>
<li>任何class 如果没有定义default constructor ，就会被合成出来一个。</li>
<li>编译器合成出来的default constructor 会明确设定 class 内每一个data member的默认值。</li>
</ul>
<h2 id="二、Copy-Constructor的构造操作"><a href="#二、Copy-Constructor的构造操作" class="headerlink" title="二、Copy Constructor的构造操作"></a>二、Copy Constructor的构造操作</h2><h4 id="1-哪些情况需要有copy-constructor？"><a href="#1-哪些情况需要有copy-constructor？" class="headerlink" title="1. 哪些情况需要有copy constructor？"></a>1. 哪些情况需要有copy constructor？</h4><p>有三种情况，会以一个object的内容作为另一class object的初值，即需要有 copy constructor。</p>
<ul>
<li><ol>
<li>把一个object直接赋值给另一个object进行初值。</li>
</ol>
</li>
<li><ol start="2">
<li>当object被当做参数交给某个函数</li>
</ol>
</li>
<li><ol start="3">
<li>当函数返回一个class object。</li>
</ol>
</li>
</ul>
<blockquote>
<p>一个class object可用两种方式复制得到，一种是被初始化，另一种是赋值。从概念上看，这两种操作分别是以copy constructor和copy assignment operator完成的。<br>Default constructors和copy constructor在<strong>必要的时候</strong>才由编译器 产生，这里的“必要”意指当class不展现bitwise copy sematics时。</p>
</blockquote>
<h4 id="2-Default-Memberwise-Initialization"><a href="#2-Default-Memberwise-Initialization" class="headerlink" title="2. Default Memberwise Initialization"></a>2. Default Memberwise Initialization</h4><p>当class object以“<strong>相同</strong>的另一个object作为初值是，其内部是以所谓的default memberwise initialization方式完成的。也就是把每一个内建的或派生的data member（例如一个数组或指针）的值，从某个object拷贝一份到另一个object上，但不拷贝其具体内容。例如只拷贝指针地址，不拷贝一份新的指针指向的对象，这也就是<strong>浅拷贝</strong>，不过它并不会拷贝其中member class object，而是以递归的方式实行memberwise initialization。</p>
<h4 id="3-递归的memberwise-initialization是如何实现的呢？"><a href="#3-递归的memberwise-initialization是如何实现的呢？" class="headerlink" title="3. 递归的memberwise initialization是如何实现的呢？"></a>3. 递归的memberwise initialization是如何实现的呢？</h4><p>答案就是Bitwise Copy Semantics和default copy constructor。如果class展现了Bitwise Copy Semantics，则使用bitwise copy（bitwise copy semantics编译器生成的伪代码是memcpy函数），否则编译器会生成default copy constructor。</p>
<h4 id="4-Memberwise-copy-深拷贝-与Bitwise-copy-浅拷贝-的区别"><a href="#4-Memberwise-copy-深拷贝-与Bitwise-copy-浅拷贝-的区别" class="headerlink" title="4. Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别"></a>4. Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别</h4><p>Memberwise copy: 在初始化一个对象期间,基类的构造函数被调用,成员变量被调用,如果它们有构造函数的时候,它们的构造函数被调用,这个过程是一个递归的过程。<br>Bitwise copy: 原内存拷贝。例子,给定一个对象object,它的类型是class Base。对象object占用10字节的内存,地址从0x0到0x9.如果还有一个对象objectTwo,类型也是class Base。那么执行objectTwo = object;如果使用Bitwise拷贝语义,那么将会拷贝从0x0到0x9的数据到objectTwo的内存地址，也就是说Bitwise是字节到字节的拷贝。</p>
<p>对于默认的拷贝构造函数不会使用深拷贝,它只是使用浅拷贝。这意味着类的所有的成员是一层深度的拷贝而已。如果你的类或结构体成员中只是包含基本的数据类型例如int, float, char,那么Memberwise copy与Bitwise copy基本是相同的。但如果类中有指针存在,那么你可能会遇到问题。<br>例如下面的例子:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">   int m<span class="comment">;</span></span><br><span class="line">   double d<span class="comment">;</span></span><br><span class="line">   char *Str<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">如果你创建两个这样的类对象,class A  a, <span class="keyword">b;并且你给a赋值, </span>     </span><br><span class="line">a.m = <span class="number">6</span><span class="comment">;   </span></span><br><span class="line">a.d = <span class="number">10</span>.<span class="number">123</span><span class="comment">;   </span></span><br><span class="line">a.Str = new char[<span class="number">10</span>]<span class="comment">;   </span></span><br><span class="line">astrcpy(a.Str, <span class="string">"test"</span>)<span class="comment">;//这里是浅拷贝   </span></span><br><span class="line">如果执行<span class="keyword">b </span>= a<span class="comment">;那么会把对象a的每一个成员的值赋值给b的每个成员。   </span></span><br><span class="line"><span class="keyword">b.m </span>= a.m<span class="comment">;    </span></span><br><span class="line"><span class="keyword">b.d </span>= a.d<span class="comment">;   </span></span><br><span class="line"><span class="keyword">b.Str </span>= a.Str<span class="comment">;//现在对象a和b的成员Str都执向相同的内存,删除任一个内存都会析放另一个对象的内存。</span></span><br></pre></td></tr></table></figure></p>
<p>所以你需要深拷贝,它不是拷贝的内存地址而是拷贝内存地址的内容。一个默认的拷贝构造函数经常执行浅拷贝,只有拥有自己的拷贝函数才可以实现深拷贝。</p>
<h4 id="5-什么时候一个class不展现出“bitwise-copy-semantics”呢？"><a href="#5-什么时候一个class不展现出“bitwise-copy-semantics”呢？" class="headerlink" title="5. 什么时候一个class不展现出“bitwise copy semantics”呢？"></a>5. 什么时候一个class不展现出“bitwise copy semantics”呢？</h4><p>有四种情况：</p>
<ul>
<li><ol>
<li>当class内含有一个member class object，而这个member class内有一个默认的copy构造函数(不论是class设计者明确声明，或者被编译器合成)</li>
</ol>
</li>
<li><ol start="2">
<li>当class继承自一个base class，而base class有copy构造函数(不论显式声明或是被编译器合成]</li>
</ol>
</li>
<li><ol start="3">
<li>当一个类声明了一个或多个virtual 函数</li>
</ol>
</li>
<li><ol start="4">
<li>当class派生自一个继承串链，其中一个或者多个virtual base class</li>
</ol>
</li>
</ul>
<h4 id="6-重新设定Virtual-Table的指针（virtual-funtion的情况）"><a href="#6-重新设定Virtual-Table的指针（virtual-funtion的情况）" class="headerlink" title="6. 重新设定Virtual Table的指针（virtual funtion的情况）"></a>6. 重新设定Virtual Table的指针（virtual funtion的情况）</h4><p>当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。<br>当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作也必须要保证安全（非pointer和reference)。也就是说，合成出来的基类构造函数会显式设定object的vptr指向基类对应的virtual table，而不是直接将右手边的class object中将其vptr现值拷贝过来。</p>
<h4 id="7-如何处理virtual-base-class-subobject的情况？"><a href="#7-如何处理virtual-base-class-subobject的情况？" class="headerlink" title="7. 如何处理virtual base class subobject的情况？"></a>7. 如何处理virtual base class subobject的情况？</h4><p>virtual base class的存在需要特别处理。一个class object如果以另一个object作为初值，而后者有一个virtual base class subobject，那么也会使“bitwise copy semantics”失效。<br>这时需要合成一个copy constructor,从而安插一些代码以设定virtualbase class pointer/offset的初值，对每一个members执行必要的memberwise初始化操作，以及执行其他的内存相关工作。</p>
<h2 id="三、程序转化语意学-Program-Transformation-Semantics"><a href="#三、程序转化语意学-Program-Transformation-Semantics" class="headerlink" title="三、程序转化语意学(Program Transformation Semantics)"></a>三、程序转化语意学(Program Transformation Semantics)</h2><h4 id="1-class-object的显式初始化操作。"><a href="#1-class-object的显式初始化操作。" class="headerlink" title="1. class object的显式初始化操作。"></a>1. class object的显式初始化操作。</h4><p>初始化object时，必要的程序转化有以下两个阶段：</p>
<ul>
<li>重写每一个定义，其中的初始化操作会被剥除，在c++中，“定义”指占用内存的行为。</li>
<li>class的copy constructor调用操作会被安插进去。</li>
</ul>
<h4 id="2-参数的初始化所做的程序转换。"><a href="#2-参数的初始化所做的程序转换。" class="headerlink" title="2. 参数的初始化所做的程序转换。"></a>2. 参数的初始化所做的程序转换。</h4><p>C++ Standard说，把一个class object当做参数传给一个函数(或是作为一个函数的返回值)，相当于以下形式的初始化操作:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X xx = arg;<span class="comment">//其中xx代表形式参数(或返回值)而arg代表真正的参数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，若已知如下函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X xo)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//转换的结果为：</span></span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">//xo以memberwise的方式将xx当作初值...</span></span><br><span class="line">foo(xx);</span><br></pre></td></tr></table></figure></p>
<p>有一种策略是导入所谓的临时性object，并调用copy constructor将它初始化，然后将此临时性object交给函数，临时性object会在函数结束处被析构。</p>
<h4 id="3-返回值的初始化所做的程序转换。"><a href="#3-返回值的初始化所做的程序转换。" class="headerlink" title="3. 返回值的初始化所做的程序转换。"></a>3. 返回值的初始化所做的程序转换。</h4><p>函数bar()的返回值为一个对象，那该怎么把局部对象xx拷贝过来？ Stroustrup在cfront中的解决办法是一个双阶段的转化：</p>
<ul>
<li><ol>
<li>首先加上一个额外参数，其类型是class object的一个reference，这个参数将被用来放置被“拷贝建构”而得的返回值。</li>
</ol>
</li>
<li><ol start="2">
<li>在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。函数也对应变为void类型。</li>
</ol>
</li>
</ul>
<h4 id="4-在编译器层面所做的优化。"><a href="#4-在编译器层面所做的优化。" class="headerlink" title="4. 在编译器层面所做的优化。"></a>4. 在编译器层面所做的优化。</h4><p>编译器会以result参数取代name return val。这样的编译器优化操作，有时被称为Named Return Value(NRV)优化。NRV优化如今被视为是标准C++编译器的一个义不容辞的优化操作。<strong>NRV需要一定的条件，即对应的类要有copy constructor</strong>。<br>一般而言，面对“以一个class object作为另一个class object的初值”的情形，语言允许编译器有大量的自由发挥空间。其优点当然是导致机器码产生时有明显的效率提升。缺点则是你不能安全地规划你的copy constructor的副作用，必须视其执行而定。</p>
<blockquote>
<p>NRV与返回值初始化的区别在于：NRV中不产生local object，直接以_result带入其中进行各种处理，减少调用copy constructor。而返回值初始化则是在最后用copy constructor将local object的值拷贝给_result, 中间不处理_result。一个是优化，一个是程序转换。</p>
</blockquote>
<h4 id="5-那Copy-Constructor要还是不要？"><a href="#5-那Copy-Constructor要还是不要？" class="headerlink" title="5. 那Copy Constructor要还是不要？"></a>5. 那Copy Constructor要还是不要？</h4><p>copy constructor的应用，迫使编译器多多少少对你的程序代码做部分优化。尤其当一个函数以传值(by value)的方式传回一个class object，而该class有一个copy constructor(不论是明确定义出来的，或是合成的)时。这将导致深奥的程序转化——不论在函数的定义或使用上，此外编译器也将copy constructor的调用操作优化，以一个额外的第一参数(数值被直接存放在其中)取代NRV。  </p>
<ul>
<li>如果编译器能自动为你实施了最好的行为,那就没有必要实现一个自己的copy constructor。</li>
<li>如果class需要大量的memberwise初始化操作，例如以传值的方式传回object，此时提供一个explicit inline copy constructor就是非常合理的（在有NRV的前提下）。</li>
</ul>
<h2 id="四、成员们的初始化队伍-Memeber-Initialization-List"><a href="#四、成员们的初始化队伍-Memeber-Initialization-List" class="headerlink" title="四、成员们的初始化队伍(Memeber Initialization List)"></a>四、成员们的初始化队伍(Memeber Initialization List)</h2><h4 id="1-在下列情况下，为了让你的程序能够顺利编译，你必须使用member-initialization-list"><a href="#1-在下列情况下，为了让你的程序能够顺利编译，你必须使用member-initialization-list" class="headerlink" title="1. 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list:"></a>1. 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list:</h4><ul>
<li>当初始化一个reference member时</li>
<li>当初始化一个const member时</li>
<li>当调用一个base class的constructor，而它拥有一组参数时</li>
<li>当调用一个member class的constructor，而它拥有一组参数时</li>
</ul>
<h4 id="2-member-initialization-list中到底会发生什么事情？"><a href="#2-member-initialization-list中到底会发生什么事情？" class="headerlink" title="2.member initialization list中到底会发生什么事情？"></a>2.member initialization list中到底会发生什么事情？</h4><p>编译器会一一操作initialization list，以适当顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。<br>initialization list中的项目顺序是由class中的members声明顺序决定的，不是由initialization list中的排列顺序决定的。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>野渡</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（二）/">http://WenDeng.github.io/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（二）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请务必获得作者的允许</li></ul></div><br><div class="tags"><a href="/tags/C-基础/">C++基础</a></div><div class="post-nav"><a class="pre" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（三）/">Data语意学</a><a class="next" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（五）/">构造、析构、拷贝语意学</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-基础/">C++基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目工具/">项目工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C-基础/" style="font-size: 15px;">C++基础</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/字典树/" style="font-size: 15px;">字典树</a> <a href="/tags/trie树/" style="font-size: 15px;">trie树</a> <a href="/tags/Iptabls/" style="font-size: 15px;">Iptabls</a> <a href="/tags/Netfilter/" style="font-size: 15px;">Netfilter</a> <a href="/tags/git使用/" style="font-size: 15px;">git使用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/1.保卫方案/">保卫方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（一）/">关于对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（三）/">Data语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（二）/">构造函数语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（五）/">构造、析构、拷贝语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（六）/">执行期语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（四）/">Function语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（七）/">站在对象模型的顶端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/2.异或/">异或</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/3.字典序/">字典序</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antfaiz5z.github.io/" title="antFaiz5z's Fantastic Fertilizer" target="_blank">antFaiz5z's Fantastic Fertilizer</a><ul></ul><a href="http://www.example1.com/" title="大城小爱" target="_blank">大城小爱</a><ul></ul><a href="http://www.example2.com/" title="大五四刘" target="_blank">大五四刘</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">野渡 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>