<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。"><title>构造、析构、拷贝语意学 | 野渡 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">构造、析构、拷贝语意学</h1><a id="logo" href="/.">野渡 的博客</a><p class="description">路漫漫其修远兮 吾将上下而求索！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-book"> 归档</i></a><a href="/timeline/"><i class="fa fa-edit"> 时间线</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">构造、析构、拷贝语意学</h1><div class="post-meta">May 16, 2019<span> | </span><span class="category"><a href="/categories/C-基础/">C++基础</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前述"><span class="toc-text">前述</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#0、基础"><span class="toc-text">0、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-class-data-member应该何时被初始化？"><span class="toc-text">1. class data member应该何时被初始化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-关于纯虚函数的几点认识。"><span class="toc-text">2. 关于纯虚函数的几点认识。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-关于虚拟机制的几点认识。"><span class="toc-text">3. 关于虚拟机制的几点认识。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、“无继承”情况下的对象构造"><span class="toc-text">一、“无继承”情况下的对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-对象的生命周期。"><span class="toc-text">1.对象的生命周期。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Plain-OI’-Data-和其相关处理"><span class="toc-text">2.Plain OI’ Data 和其相关处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-vptr初始化语意学：什么时候设置vptr合适？"><span class="toc-text">4. vptr初始化语意学：什么时候设置vptr合适？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、对象复制语意学-Object-Copy-Semantics"><span class="toc-text">三、对象复制语意学(Object Copy Semantics)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-怎样显式地拒绝将一个class-object指定给另一个class-object？"><span class="toc-text">1. 怎样显式地拒绝将一个class object指定给另一个class object？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-关于copy-assignment-operator。"><span class="toc-text">2. 关于copy assignment operator。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、析构语义学-Semantics-of-Destruction"><span class="toc-text">四、析构语义学(Semantics of Destruction)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-什么时候需要合成destructor"><span class="toc-text">1. 什么时候需要合成destructor?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-如果没有destructor-编译会在需要时自动合成，那如果有destructor-编译器又是怎么进行扩展的呢"><span class="toc-text">2. 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?</span></a></li></ol></li></div></div><div class="post-content"><p>本章的的主题是构造、析构、拷贝语意学。主要是讨论如何支持class模型，探讨object的整个生命周期。<br><a id="more"></a></p>
<h3 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h3><blockquote>
<p>本章的的主题是构造、析构、拷贝语意学。主要是讨论如何支持class模型，探讨object的整个生命周期。</p>
</blockquote>
<hr>
<p>参考书籍及链接：《深度探索c++对象模型》    </p>
<hr>
<h2 id="0、基础"><a href="#0、基础" class="headerlink" title="0、基础"></a>0、基础</h2><h4 id="1-class-data-member应该何时被初始化？"><a href="#1-class-data-member应该何时被初始化？" class="headerlink" title="1. class data member应该何时被初始化？"></a>1. class data member应该何时被初始化？</h4><p>一般而言，class的data member应该被初始化，并且只在constructor中或是在class的其他member functions中指定初值。其他任何操作都将破坏封装性质，使class的维护和修改更加困难。</p>
<h4 id="2-关于纯虚函数的几点认识。"><a href="#2-关于纯虚函数的几点认识。" class="headerlink" title="2. 关于纯虚函数的几点认识。"></a>2. 关于纯虚函数的几点认识。</h4><ul>
<li>c++中可以定义和调用(invoke)一个pure virtual function：不过它只能被<strong>静态地调用</strong>(用类名调用)，不能经由虚拟机制调用。</li>
<li>class设计者如果声明就一定要定义pure virtual destructor，因为每一个 derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏 任何一个base class destructor的定义，就会导致链接失败。<strong>最好的方式就是不要把virtual destructor声明为pure。</strong></li>
</ul>
<h4 id="3-关于虚拟机制的几点认识。"><a href="#3-关于虚拟机制的几点认识。" class="headerlink" title="3. 关于虚拟机制的几点认识。"></a>3. 关于虚拟机制的几点认识。</h4><ul>
<li>类中设计虚函数时应先考虑清楚，不会被derived class改写的函数最好被设计 为virtual function。总靠编译器进行优化并不是好的设计理念。</li>
<li>决定一个virtual function是否为const需要先想清楚，不必要的地方别用。</li>
</ul>
<h2 id="一、“无继承”情况下的对象构造"><a href="#一、“无继承”情况下的对象构造" class="headerlink" title="一、“无继承”情况下的对象构造"></a>一、“无继承”情况下的对象构造</h2><h4 id="1-对象的生命周期。"><a href="#1-对象的生命周期。" class="headerlink" title="1.对象的生命周期。"></a>1.对象的生命周期。</h4><p>一个object的生命，是该object的一个执行期属性。local object的生命对应其所 在的scope。global object的生命和整个程序的生命相同。heap object的生命从 它被new运算符配置出来开始，到它被delete运算符摧毁为止。</p>
<h4 id="2-Plain-OI’-Data-和其相关处理"><a href="#2-Plain-OI’-Data-和其相关处理" class="headerlink" title="2.Plain OI’ Data 和其相关处理"></a>2.Plain OI’ Data 和其相关处理</h4><p>形如下列的结构，被C++标准称为Plain OI’ Data。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果以C++ 来编译这段码，理论上编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator。但实际上，编译器会分析这个声明，并为它贴上Plain of Data标签。</li>
<li>对于<figure class="highlight plain"><figcaption><span>global; ```理论上,constructor在程序起始处被调用而destructor 在程序的exit()处被调用。然而，事实上那些tirvial members要不是没被定义， 就是没被调用，程序的行为一如它在C中的表现一样。此外，C++ 的所有全局对象都被当作“初始化过的数据”来对待。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 对于``` Point *heap = new Point; ```会被转换为对new运算符的调用。但并没有default constructor施行与new运算符所传回的Point object身上。</span><br><span class="line">* ```*heap = local; ```理论上，这样的指定操作会触发trivial copy assignment operator进行拷贝搬运操作。然而实际上此object是一个Plain old data，所以赋值操作(assignment)将只是像C那样的纯粹位搬移操作。</span><br><span class="line">* ```delete heap; ```会被转换为对delete运算符的调用,观念上，这样的操作会触发Point的trivial destructor。但是一如我们所见，destructor要不是没有被产生就是没有被调用。</span><br><span class="line"></span><br><span class="line">#### 3.抽象数据类型(Abstract Data Type)和其相关处理</span><br><span class="line">以下是Point的第二次声明，在public接口之下多了private数据，提供完整的封装性，但是没有提供virtual function:</span><br></pre></td></tr></table></figure></li>
</ul>
<p>class Point{<br>public:<br>    Point(float x = 0.0, float y = 0.0, float z = 0.0): _x(x), _y(y),_z(y) { }<br>    //no copy constructor, copy operator or destructor defined<br>private:<br>    float _x, _y, _z;<br>};<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 对于Point，我们不需要定义一个<span class="keyword">copy</span> <span class="function"><span class="keyword">constructor</span>或<span class="title">copy</span> <span class="title">assignment</span> <span class="title">operator</span>，因为默认的位拷贝已经足够，也不需要<span class="title">destructor</span>,因为默认的内存管理方法也已经足够，如果我们不自己定义，编译器也因为判断不会用到而不会产生的函数。</span></span><br><span class="line"><span class="function">* 对于```<span class="title">Point</span> <span class="title">global</span>;</span>  ```<span class="keyword">default</span> <span class="function"><span class="keyword">constructor</span>作用于其上。由于<span class="title">global</span>被定义在全局范畴中，其初始化操作将延迟到程序激活时才开始，扩展调用<span class="title">default</span> <span class="title">constructor</span>。如果要将<span class="title">class</span>中的所有成员都设定常 量初值，那么给予一个<span class="title">explicit</span> <span class="title">initialization</span> <span class="title">list</span>会比较有效率些 。</span></span><br><span class="line"><span class="function">* 对于``` <span class="title">Point</span> *<span class="title">heap</span> = <span class="title">new</span> <span class="title">Point</span>;</span> ```会被转换为对<span class="keyword">new</span>运算符的调用。然后调用<span class="keyword">default</span> Point <span class="function"><span class="keyword">Constructor</span>并自行扩展。</span></span><br><span class="line"><span class="function">* ```*<span class="title">heap</span> = <span class="title">local</span>;</span> ```理论上，这样的指定操作会触发trivial <span class="keyword">copy</span> assignment <span class="keyword">operator</span>进行拷贝搬运操作。然而并没有，只进行简单的位拷贝操作。</span><br><span class="line">* ```delete heap; ```，由于没有destrucor,同样不会被调用。</span><br><span class="line"></span><br><span class="line">#### <span class="number">4</span>.在上述情况中加入虚函数又将怎么处理？</span><br><span class="line">将人虚函数之后，<span class="keyword">class</span> object除了多负担一个vptr之外，也引发编译器对Point <span class="keyword">class</span>产生膨胀作用。例如：</span><br></pre></td></tr></table></figure></p>
<p>class Point{<br>public:<br>    Point(float x = 0.0, float y = 0.0): _x(x), _y(y) { }<br>    //no destructor, copy constructor or copy operator<br>    virtual float z();<br>protected:<br>    float _x, _y;<br>};<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 首先<span class="function"><span class="keyword">constructor</span>将需要附加一些代码用于将<span class="title">vptr</span>初始化。这些代码位于<span class="title">base</span> <span class="title">class</span>构造函数和用户代码之间。</span></span><br></pre></td></tr></table></figure></p>
<p>Point<em> Point::Point(Point </em>this, float x, float y): _x(x), _y(y)<br>{<br>    this-&gt;_vptr_Point = _vtbl_Point; //设定object的virtual table pointer<br>    this-&gt;_x = x; //扩展member initialization list<br>    this-&gt;_y = y;</p>
<pre><code>return this; //传回this对象
</code></pre><p>}<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 其次需要合成一个<span class="keyword">copy</span> <span class="function"><span class="keyword">constructor</span>和一个<span class="title">copy</span> <span class="title">assignment</span> <span class="title">operator</span>，因为直接<span class="title">bitwise</span>操作对于<span class="title">vptr</span>可能是非法的。</span></span><br></pre></td></tr></table></figure></p>
<p>//copy constructor的内部合成<br>inline Point<em> Point::Point(Point</em> this, const Point&amp; rhs)<br>{<br>    this-&gt;_vptr_Point = _vtbl_Point;//设定object的vptr<br>    //将rhs坐标中的位连续拷贝到this对象<br>    //或是经由member assignment提供一个member…<br>    return this;<br>}<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 一般而言，如果你的设计之中有许多函数都需要以传值方式传回一个local <span class="class"><span class="keyword">class</span> <span class="title">object</span>，此时提供一个<span class="title">copy</span> <span class="keyword">constructor</span>就比较合理，它的出现会触发<span class="title">NRV</span>优化。<span class="title">NRV</span> 优化后就不再需要调用<span class="title">copy</span> <span class="keyword">constructor</span>，因为运算结果已经被直接置于“将被传回 的<span class="title">object</span>”体内了。</span>(有它-&gt;NRV-&gt;不用它？？？？)</span><br><span class="line"></span><br><span class="line">## 二、继承体系下的对象构造</span><br><span class="line">#### <span class="number">1</span>. 编译器会对<span class="keyword">constructor</span>做什么？</span><br><span class="line">像这样```T <span class="keyword">object</span> ```定义一个对象时,会调用<span class="keyword">constructor</span>,其内部做的工作包括：</span><br><span class="line">* （<span class="number">1</span>）记录在member initialization list中的<span class="keyword">data</span> members初始化操作会被放进<span class="keyword">constructor</span>的函数本身，并以members的声明顺序为顺序。</span><br><span class="line">* （<span class="number">2</span>）如果有一个member并没有出现在member initialization list中，但它有一个<span class="keyword">default</span> <span class="keyword">constructor</span>，那么该<span class="keyword">default</span> <span class="keyword">constructor</span>必须被调用。</span><br><span class="line">* （<span class="number">3</span>）在那之前，如果<span class="class"><span class="keyword">class</span> <span class="title">object</span>有<span class="title">virtual</span> <span class="title">functions</span>, <span class="type">它们必须被设定初值，指向适当的virtual tables.</span></span></span><br><span class="line">* （<span class="number">4</span>）在那之前，所有上一层的base <span class="class"><span class="keyword">class</span> <span class="title">constructors</span>必须被调用，以<span class="title">base</span> <span class="title">class</span>生声明顺序为顺序</span>(与member initialization list中的顺序没有关联)：</span><br><span class="line">* * 如果base <span class="class"><span class="keyword">class</span>被列于<span class="title">member</span> <span class="title">initialization</span> <span class="title">list</span>中，那么任何明确指定的参数都应该被传递进去。、</span></span><br><span class="line">* * 如果base <span class="class"><span class="keyword">class</span>没有被列于<span class="title">member</span> <span class="title">initialization</span> <span class="title">list</span>中，而它有<span class="title">default</span> <span class="keyword">constructor</span></span>(或<span class="keyword">default</span> memberwise copy <span class="keyword">constructor</span>),那么就调用之。</span><br><span class="line">* * 如果base <span class="class"><span class="keyword">class</span>是多重继承下的第二或后继的<span class="title">base</span> <span class="title">class</span>，那么<span class="title">this</span>指针必须有所调整。</span></span><br><span class="line">* （<span class="number">5</span>）在那之前，所有virtual base <span class="class"><span class="keyword">class</span> <span class="title">constructors</span>必须被调用，从左到右，从最深到最浅</span></span><br><span class="line">* * 如果<span class="class"><span class="keyword">class</span>被列于<span class="title">member</span> <span class="title">initialization</span> <span class="title">list</span>中，那么如果有任何显式指定的参数，都应该传递过去。若没有列于<span class="title">list</span>之中，而<span class="title">class</span>有一个<span class="title">default</span> <span class="keyword">constructor</span>，亦应该调用之</span></span><br><span class="line">* * 此外，<span class="class"><span class="keyword">class</span>中的每一个<span class="title">virtual</span> <span class="title">base</span> <span class="title">class</span> <span class="title">subobject</span>的偏移位置</span>(offset)必须在执行期可被存取</span><br><span class="line">* * 如果<span class="class"><span class="keyword">class</span> <span class="title">object</span>是最底层</span>(most-derived)的<span class="class"><span class="keyword">class</span>，其<span class="title">constructors</span>可能被调用，某些用以支持这一行为的机制必须被放进来。</span></span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span>. 一个实例说明编译器在对象构造的过程中所做的操作。</span><br><span class="line">有一个基类和其对应的派生类如下：</span><br></pre></td></tr></table></figure></p>
<p>class Point<br>{<br>  public:<br>    Point(float x = 0.0, float y = 0.0);<br>    Point(const Point&amp;);     //copy constructor<br>    Point&amp; operator=(const Point&amp;);   //copy assignment operator<br>    virtual ~Point();       //virtual destructor<br>    virtual float z() { return 0.0; }<br>  protected:<br>    float _x, _y;<br>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point _begin, _end;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    Line(<span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp;);</span><br><span class="line">    draw();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>（1）对于 <figure class="highlight plain"><figcaption><span>Point& begin, const Point& end): _end(end), _begin(begin) &#123;&#125; ```,它会被编译器扩充并转换为：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Line* Line::Line(Line *this, const Point&amp; begin, const Point&amp; end)&#123;</span><br><span class="line">    this-&gt;_begin.Point::Point(begin);</span><br><span class="line">    this-&gt;_end.Point::Point(end);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>（2）对于<figure class="highlight plain"><figcaption><span>a;```implicit Line destructor会被合成出来(如果Line派生自Point,那么合成出来的destructor将会是virtual。然而由于Line只是内带Point objects而非继承自Point，所以被合成出来的destructor只是nontrivial而已)。在其中，它的member class objects的destructor会被调用(与其构造的相反顺序):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">inline Line::~Line(Line *this)&#123;</span><br><span class="line">    this-&gt;_end.Point::~Point();</span><br><span class="line">    this-&gt;_begin.Point::~Point();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>(3) 对于<figure class="highlight plain"><figcaption><span>b</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* (4) 对于``` a=b;``` 同样，implicit assignment operator会被合成出来，成为一个inline public member;</span><br><span class="line"></span><br><span class="line">#### 3. 虚拟继承：constructor怎么处理virtual base class的构造？</span><br><span class="line">试想下面三种类派生情况：</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>class Vertex : virtual public Point{ … }<br>class Vertex3d : public Point3d, public Vertex{ … }<br>class PVertex : public Vertex3d { … }<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vertex的<span class="function"><span class="keyword">constructor</span>必须调用<span class="title">Point</span>的<span class="title">constructor</span>。然而当<span class="title">Point3d</span>和<span class="title">Vertex</span>同为<span class="title">Vertetx3d</span>的<span class="title">subobjects</span>时，它们对<span class="title">Point</span> <span class="title">constructor</span>的调用操作一定不可以发生，取而代之的是，作为一个最底层的<span class="title">class</span>，<span class="title">Vertex3d</span>有责任将<span class="title">Point</span>初始化，而更往后<span class="params">(往下)</span>继承，则由<span class="title">PVertex</span>来负责完成“被共享之<span class="title">Point</span> <span class="title">subobject</span>”的构造。     </span></span><br><span class="line"><span class="function">对于<span class="title">Vertex3d</span>，当调用<span class="title">Point3d</span>和<span class="title">Vertex</span>的<span class="title">constructor</span>时，可以通过如下扩展，把\_<span class="title">most</span>\_<span class="title">derived</span>参数设为<span class="title">flase</span>从而不调用<span class="title">Point</span>的构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p>//在virtual base class情况下的constructor扩充内容<br>Point3d<em> Point3d::Point3d(Point3d</em> this, bool _most_derived, float x, float y, float z)<br>{<br>    if(_most_derived != false) this-&gt;Point::Point(x, y);</p>
<pre><code>this-&gt;_vptr_Point3d = _vtbl_Point3d;
this-&gt;vptr_Point3d_Point = _vpbl_Point3d_Point;
this-&gt;_z = rhs._z;
return this;
</code></pre><p>}<br><code>`</code></p>
<blockquote>
<p>“virtual base class constructors的被调用”有着明确的定义：只有当一个完整的class object被定义出来时，它才会被调用；如果object只是某个完整object的subject，它就不会被调用。</p>
</blockquote>
<h4 id="4-vptr初始化语意学：什么时候设置vptr合适？"><a href="#4-vptr初始化语意学：什么时候设置vptr合适？" class="headerlink" title="4. vptr初始化语意学：什么时候设置vptr合适？"></a>4. vptr初始化语意学：什么时候设置vptr合适？</h4><p>constructor的执行算法通常如下：</p>
<ul>
<li>(1) 在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructors会被调用</li>
<li>(2) 上述完成之后，对象的vptrs被初始化，指向相关的virtual tables</li>
<li>(3) 如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。</li>
<li>(4) 最后，执行程序员所提供的代码。      </li>
</ul>
<h2 id="三、对象复制语意学-Object-Copy-Semantics"><a href="#三、对象复制语意学-Object-Copy-Semantics" class="headerlink" title="三、对象复制语意学(Object Copy Semantics)"></a>三、对象复制语意学(Object Copy Semantics)</h2><h4 id="1-怎样显式地拒绝将一个class-object指定给另一个class-object？"><a href="#1-怎样显式地拒绝将一个class-object指定给另一个class-object？" class="headerlink" title="1. 怎样显式地拒绝将一个class object指定给另一个class object？"></a>1. 怎样显式地拒绝将一个class object指定给另一个class object？</h4><p>如果想要禁止将一个class object指定给另一个class object，那么只要将copy assignment operator声明为private,并且不提供其定义即可。</p>
<h4 id="2-关于copy-assignment-operator。"><a href="#2-关于copy-assignment-operator。" class="headerlink" title="2. 关于copy assignment operator。"></a>2. 关于copy assignment operator。</h4><p>对于编译器来说，class如果有了bitwise copy语意，implicit copy assignment copy就会被视为无用的，从而也不会被合并出来。<br>一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意：</p>
<ul>
<li>（1）当class内含一个member object，而其class有一个copy assignment operator时</li>
<li>（2）当一个class的base class有一个copy assignment operator时</li>
<li>（3）当一个class声明了任何virtual functions(我们一定不要拷贝右端class object的vptr地址，因为它可能是一个derived class object)时</li>
<li>（4）当class继承自一个virtual base class(不论base class有没有copy operator)时<blockquote>
<p>copy assignment operator需要考虑的是需不需要被合成？什么时候被合成？当多重继承遇到virtual base class共享时，如何避免中间base class对最上层base class的subobject的多重拷贝？<br><strong>书籍作者的建议是不允许virtual base class的拷贝操作，尽量不要在任何virtual base class中声明数据。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="四、析构语义学-Semantics-of-Destruction"><a href="#四、析构语义学-Semantics-of-Destruction" class="headerlink" title="四、析构语义学(Semantics of Destruction)"></a>四、析构语义学(Semantics of Destruction)</h2><h4 id="1-什么时候需要合成destructor"><a href="#1-什么时候需要合成destructor" class="headerlink" title="1. 什么时候需要合成destructor?"></a>1. 什么时候需要合成destructor?</h4><p>如果class没有定义destructor，那么只有在class内含的member object或base class拥有destructor的情况下，编译器才会自动合成一个出来。否则，destructor被视为不需要，也就不需被合成。</p>
<blockquote>
<p>事实上，我们应该拒绝那种被我们称为“对称策略”的奇怪想法：“你已经定义了一个constructor,所以你应该提供一个destructor也是天经地义的事”。我们应该因为“需要”而非“感觉”来提供destructor,更不要因为你不确定是否需要一个destructor，于是就提供它。（取自作者原话）</p>
</blockquote>
<h4 id="2-如果没有destructor-编译会在需要时自动合成，那如果有destructor-编译器又是怎么进行扩展的呢"><a href="#2-如果没有destructor-编译会在需要时自动合成，那如果有destructor-编译器又是怎么进行扩展的呢" class="headerlink" title="2. 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?"></a>2. 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?</h4><p>一个由程序员定义的destructor被扩展的方式类似constructors被扩展的方式，但顺序相反：</p>
<ul>
<li>（1） destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设(reset)</li>
<li>（2）如果object内含一个vptr，那么首先重设(reset)相关的virtual table</li>
<li>（3）如果class拥有member class objects。而后者拥有destructors，那么它们会以其声明的顺序的相反顺序被调用</li>
<li>（4）如果有任何直接的(上一层)nonvirtual base classes拥有destructors，它们会以其声明顺序的相反顺序被调用</li>
<li>（5）如果有任何virtual base classes拥有destructor，而目前讨论的这个class是最尾端(most-derived)的class，那么它们会以其原来的构造顺序的相反顺序被调用。</li>
</ul>
<p>就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实体：</p>
<ul>
<li>一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructors。</li>
<li>一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。</li>
</ul>
<p>一个object的生命结束于其destructor开始执行之时。由于每一个base class constructor都轮番被调用，所以derived object实际上变成了一个完整的object。例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象、一个Point3d对象，最后成为一个Point对象。当我们在destructor中调用member functiions时，对象的蜕变会因为vptr的重新设定而受到影响。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>野渡</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（五）/">http://WenDeng.github.io/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（五）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请务必获得作者的允许</li></ul></div><br><div class="tags"><a href="/tags/C-基础/">C++基础</a></div><div class="post-nav"><a class="pre" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（二）/">构造函数语意学</a><a class="next" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（六）/">执行期语意学</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-基础/">C++基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目工具/">项目工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C-基础/" style="font-size: 15px;">C++基础</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/字典树/" style="font-size: 15px;">字典树</a> <a href="/tags/trie树/" style="font-size: 15px;">trie树</a> <a href="/tags/Iptabls/" style="font-size: 15px;">Iptabls</a> <a href="/tags/Netfilter/" style="font-size: 15px;">Netfilter</a> <a href="/tags/git使用/" style="font-size: 15px;">git使用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/1.保卫方案/">保卫方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（一）/">关于对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（三）/">Data语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（二）/">构造函数语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（五）/">构造、析构、拷贝语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（六）/">执行期语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（四）/">Function语意学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/深度探索c++对象模型/《深度探索c++对象模型》（七）/">站在对象模型的顶端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/2.异或/">异或</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/算法与数据结构/3.字典序/">字典序</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://antfaiz5z.github.io/" title="antFaiz5z's Fantastic Fertilizer" target="_blank">antFaiz5z's Fantastic Fertilizer</a><ul></ul><a href="http://www.example1.com/" title="大城小爱" target="_blank">大城小爱</a><ul></ul><a href="http://www.example2.com/" title="大五四刘" target="_blank">大五四刘</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">野渡 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>