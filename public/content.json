{"meta":{"title":"野渡 的博客","subtitle":"路漫漫其修远兮 吾将上下而求索！","description":"而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。","author":"野渡","url":"http://WenDeng.github.io"},"pages":[{"title":"关于我","date":"2019-05-16T10:49:57.896Z","updated":"2019-05-16T05:31:07.499Z","comments":true,"path":"about/index.html","permalink":"http://WenDeng.github.io/about/index.html","excerpt":"","text":"我是一名后端开发工程师，专注高性能服务器、分布式服务器等的研发工作。热爱生活，热爱自己。"},{"title":"这里主要是记录一些喜欢的书和电影","date":"2019-05-17T07:33:46.000Z","updated":"2019-05-17T07:34:56.291Z","comments":true,"path":"bookandmovie/index.html","permalink":"http://WenDeng.github.io/bookandmovie/index.html","excerpt":"","text":""},{"title":"timeline","date":"2019-05-16T03:20:58.000Z","updated":"2019-05-16T03:32:56.058Z","comments":true,"path":"timeline/index.html","permalink":"http://WenDeng.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"十年一瞬，沧海之间","slug":"体会生活/回顾十年","date":"2019-05-17T07:44:12.000Z","updated":"2019-05-17T07:42:59.388Z","comments":true,"path":"2019/05/17/体会生活/回顾十年/","link":"","permalink":"http://WenDeng.github.io/2019/05/17/体会生活/回顾十年/","excerpt":"","text":"","categories":[{"name":"体会生活","slug":"体会生活","permalink":"http://WenDeng.github.io/categories/体会生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://WenDeng.github.io/tags/生活/"}],"keywords":[{"name":"体会生活","slug":"体会生活","permalink":"http://WenDeng.github.io/categories/体会生活/"}]},{"title":"深入理解netfilter的核心原理与实现","slug":"网络协议/深入理解netfilter的核心原理与实现","date":"2019-04-26T10:44:12.000Z","updated":"2019-05-17T07:43:45.841Z","comments":true,"path":"2019/04/26/网络协议/深入理解netfilter的核心原理与实现/","link":"","permalink":"http://WenDeng.github.io/2019/04/26/网络协议/深入理解netfilter的核心原理与实现/","excerpt":"本文旨在一探Iptables和Netfilter的关系，了解网络包经过网络协议栈的过程，从而对linux的防火墙机制有更深入的认识。","text":"本文旨在一探Iptables和Netfilter的关系，了解网络包经过网络协议栈的过程，从而对linux的防火墙机制有更深入的认识。 1、Iptables和Netfilter的关系iptables是用户用来管理和配置防火墙规则的一种策略，但是实际解析规则并按照规则实施产生作用的是Netfilter。 iptables与协议栈内有包过滤功能的hook交互来完成工作，这些内核hook构成了netfilter框架。每个进入网络系统的包（接收和发送）在经过协议栈的时候都会触发这些hook，程序可以通过注册hook函数的方式在一些关键路径上处理网络流量。iptables相关的内核模块在这些hook注册了处理函数，因此可以通过iptables规则来使得网络流量符合防火墙规则。 2、Netfilter Hooksnetfilter提供了5个关于IPv4的hook点，数据包经过协议栈时会触发内核模块注册在这里的处理函数。触发哪个hook取决于包的方向（接收还是接收）、包的目的地址、以及包在上一个hook点是被丢弃还accept等等。 下面几个hook是内核协议栈已经定义好的： NF_IP_PRE_ROUTING: 接收到的包进入协议栈立即触发此个hook（刚刚进行完版本号，校验和等检测），在进行任何路由判断之前 NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此hook NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此hook NF_IP_LOCAL_OUT：本机产生的准备发送的包，在进入协议栈后立即触发此hook NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由的判断之后，将触发此hook 注册处理函数时必须提供优先级，以便hook触发能按照优先级高低调用处理函数，这使得多个模块可以在同一个hook点注册，并且有确定的处理顺序，内核模块会依次被调用，每次返回一个结果给netfilter框架，提示该对这包做什么操作。 3、Hooks和Iptables table and chain的关系Iptable使用table来组织规则，分为以下5类table： Filter Table：是最常用的table之一，用于判断是否允许一个包通过。 NAT Table: 用于实现网络地址转换规则。当包进入协议栈的时候，这些规则决定是否以及如何修改包的源/目的地址，以改变包被 路由时的行为。nat table通常用于将包路由到无法直接访问的网络。 Mangle Table: 用于修改包的IP头。如可以修改包的TTL，增加或减少包可以经过的跳数。还可以对包打只在内核内有效的“标记”，后续的table或工具处理的时候可以用到这些标记。标记不会修改包本身，只是在包的内核表示上做标记。 Raw Table：其功能非常有限，其唯一目的就是提供一个让包绕过连接跟踪的框架。 Security Table：作用是给包打上SELinux标记，以此影响SELinux 或其他可以解读 SELinux 安全上下文的系统处理包的行为。这些标记可以基于单个包，也可以基于连接。 在每个table内部，规则被进一步组织成chain，内置的chain是由内置的hook触发的。chain基本上能决定规则何时被匹配。内置的chain名字和netfilter hook名字是一一对应的： PREROUTING: 由 NF_IP_PRE_ROUTING hook触发 ——————&gt; raw,mangle,nat(目的) INPUT: 由 NF_IP_LOCAL_IN hook触发 ——————&gt; mangle,filter,security,nat(源) FORWARD: 由 NF_IP_FORWARD hook触发 ——————&gt; mangle,filter,security OUTPUT: 由 NF_IP_LOCAL_OUT hook触发 ——————&gt; raw,mangle,nat,filter,security,nat(源) POSTROUTING: 由 NF_IP_POST_ROUTING hook触发 ——————&gt; mangle，nat(源) chain使管理员可以控制在包的传输路径上哪个点应用策略。因为每个table有多个chain，因此一个 table可以在处理过程中的多个地方施加影响。特定类型的规则只在协议栈的特定点有意义，因此并不是每个table都会在内核的每个hook注册chain。可以看出raw table只有两个链prerouting和output，分别在对应的hook点发挥作用。 4、从IP协议栈入手要想理解Netfilter的工作原理，必须从对Linux IP报文处理流程的分析开始，Netfilter正是将自己紧密地构建在这一流程之中的。 4.1 接收中断如果网卡收到一个和自己MAC地址匹配或链路层广播的以太网帧，它就会产生一个中断。此网卡的驱动程序会处理此中断做入下处理： 从DMA/PIO或其他地方得到分组数据，写到内存里去； 接着，会分配一个新的套接字缓冲区skb，并调用与协议无关的、网络设备均支持的通用网络接收处理函数netif_rx(skb)。netif_rx()函数让内核准备进一步处理skb。 然后，skb会进入到达队列以便CPU处理（对于多核CPU而言，每个CPU维护一个队列）。如果FIFO队列已满，就会丢弃此分组。在skb排队后，调用__cpu_raise_softirq()标记NET_RX_SOFTIRQ 软中断，等待 CPU 执行。 至此， netif_rx() 函数调用结束，返回调用者状况信息（成功还是失败等）。此时，中断上下文进程完成任务，数据分组继续被上层协议栈处理。 流程：网卡收到一帧————&gt;引发中断————&gt;cpu调用相应的中断处理函数（指向此网卡驱动中的相应的处理函数）（把此packet读到ram中）————&gt;呼叫netif_rx函数来打上timestamp，并把此skb放入到cpu设置的队列中————&gt;标记软中断（__cpu_raise_softirq）————&gt;中断完成。 4.2 softirq内核2.4以后，整个协议栈不再使用bottom half，而是被软中断softirq取代。软中断 softirq优势明显，可以同时在多个CPU上执行；而bottom half一次只能在一个CPU上执行，即在多个CPU执行时严格保持串行。 整个softirq机制的设计与实现中自始自终都贯彻了一个思想：“谁触发，谁执行 ”，也即触发软中断的那个CPU负责执行它所触发的软中断，而且每个CPU都由它自己的软中断触发与控制机制。这个设计思想也使得softirq机制充分利用了SMP系统的性能和特点。 4.3 NET_RX_SOFTIRQ 网络接收软中断这一阶段会根据协议的不同来处理数据分组。 CPU开始处理软中断do_softirq()，接着 net_rx_action() 处理前面标记的NET_RX_SOFTIRQ ，把出对列的skb送入相应列表处理（根据协议不同到不同的列表）。比如，IP分组交给 ip_rcv()处理， ARP分组交给arp_rcv()处理等。 4.4 处理IPv4分组下面讲讲数据包到达网络层后所做的处理，整理流程如下图，从图中可以看到netfilter起作用的5个hooks。 4.4.1 上述处理的详细过程如下： ip_rcv()函数验证IP分组，比如目的地址是否本机地址，校验和是否正确等。若正确，则交给netfilter的NF_IP_PRE_ROUTING钩子,否则丢弃。 到了ip_rcv_finish()函数，数据包就要根据skb结构的目的或路由信息各奔东西了。ip_local_deliver()处理到本机的数据分组、ip_forward()处理需要转发的数据分组、ip_mr_input()转发组播数据包。如果是转发的数据包，还需要找出出口设备和下一跳。ip_rcv_finish()函数最后执行dst_input()，决定数据包的下一步的处理。 4.4.2 转发数据包转发数据包的主要流程如下： 处理IP头选项。如果需要的话，会记录本地IP地址和时间戳； 确认分组可以被转发； 将TTL减一，如果TTL为0 ，则丢弃分组； 根据 MTU 大小和路由信息，对数据分组进行分片，如果需要的话； 将数据分组送往外出设备。 如果由于某种原因，数据分组不能被转发，那么就回应 ICMP 消息来说明不能转发的原因。在对转发的分组进行各种检查无误后，执行 ip_forward_finish ，准备发送。然后执行dst_output(skb) 。无论是转发的分组，还是本地产生的分组，都要经过dst_output(skb) 到达目的主机。 IP 头在此时已经完成就绪。dst_output(skb) 函数要执行虚函数 output（单播的话为ip_output ，多播为ip_mc_output）。最后，ip_finish_output 进入邻居子系统。 4.4.3 数据包本地处理数据包交给netfilter的IP_LOCAL_INPUT钩子,作相应处理，然后交给上层比如TCP进行下一步处理。TCP的处理过程如下： ip_queue_xmit检查socket结构体中是否含有路由信息，如果没有则执行 ip_route_output_flow查找，并存储到sk数据结构中。如果找不到，则丢弃数据包。 数据最终到达驱动层，然后网卡再将数据发送出去。 5、Netfilter hook深入Netfilter的主要工作其实将iptable对应的规则转换成对应nf_hoo_ops变量，然后进行注册从而发挥作用，接下来我们看一下具体过程。 5.1 注册和注销Netfilter hook注册一个hook函数是围绕nf_hook_ops数据结构的一个非常简单的操作，nf_hook_ops数据结构在linux/netfilter.h中定义，该数据结构的定义如下：12345678910struct nf_hook_ops &#123; struct list_head list; /* User fills in from here down. */ nf_hookfn *hook; struct module *owner; u_int8_t pf; unsigned int hooknum; /* Hooks are ordered in ascending priority. */ int priority;&#125;; 该数据结构中的list成员用于维护Netfilter hook的列表，并且不是用户在注册hook时需要关心的重点。 hook成员是一个指向nf_hookfn类型的函数的指针，该函数是这个hook被调用时执行的函数。nf_hookfn同样在linux/netfilter.h中定义。 pf这个成员用于指定协议族。有效的协议族在linux/socket.h中列出，但对于IPv4我们希望使用协议族PF_INET。 hooknum这个成员用于指定安装的这个函数对应的具体的hook类型，其值为NF_IP_PRE_ROUTING等。 priority这个成员用于指定在执行的顺序中，这个hook函数应当在被放在什么地方。对于IPv4，可用的值在linux/netfilter_ipv4.h的 nf_ip_hook_priorities 枚举中定义。出于示范的目的，在后面的模块中我们将使用NF_IP_PRI_FIRST。 注册一个Netfilter hook需要调用nf_register_hook()函数，以及用到一个nf_hook_ops数据结构。nf_register_hook()函数以一个nf_hook_ops数据结构的地址作为参数并且返回一个整型的值。以下提供的是一个示例代码，该示例代码简单的注册了一个丢弃所有到达的数据包的函数。该代码同时展示了Netfilter的返回值如何被解析。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/skbuff.h&gt;#include &lt;linux/netfilter.h&gt;#include &lt;linux/netfilter_ipv4.h&gt; MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"xsc\"); static struct nf_hook_ops nfho; unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *))&#123; return NF_DROP;//丢弃所有数据包&#125; static int kexec_test_init(void)&#123; printk(\"kexec test start ...\\n\"); nfho.hook = hook_func; nfho.owner = NULL; nfho.pf = PF_INET; nfho.hooknum = NF_INET_LOCAL_OUT; nfho.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho);// 注册一个钩子函数 return 0;&#125; static void kexec_test_exit(void)&#123; printk(\"kexec test exit ...\\n\"); nf_unregister_hook(&amp;nfho); //注销钩子函数&#125; module_init(kexec_test_init); //初始化module_exit(kexec_test_exit); //退出处理 5.2 hook函数实现hook函数原型在linux/netfilter.h中给出，如下：12345typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)); skb之后的两个参数是指向net_device数据结构的指针，net_device数据结构被Linux内核用于描述所有类型的网络接口。这两个参数中的第一个in，用于描述数据包到达的接口，毫无疑问，参数out用于描述数据包离开的接口。必须明白，在通常情况下，这两个参数中将只有一个被提供。例如：参数in只用于NF_IP_PRE_ROUTING和NF_IP_LOCAL_IN hook，参数out只用于NF_IP_LOCAL_OUT和NF_IP_POST_ROUTING hook。 sk_buff数据结构中最有用的部分可能就是那三个描述传输层包头（例如：UDP, TCP, ICMP, SPX）、网络层包头（例如：IPv4/6, IPX, RAW）以及链路层包头（例如：以太网或者RAW）的联合(union)了。这三个联合的名字分别是h、nh以及mac。这些联合包含了几个结构，依赖于具体的数据包中使用的协议。 传递给hook函数的最后一个参数是一个命名为okfn函数指针，该函数以一个sk_buff数据结构作为它唯一的参数，并且返回一个整型的值。 5.3 Netfilter报过滤技术实现介绍几种过滤技术的实现： 基于接口进行过滤:使用相应的net_device数据结构的name这个成员，你就可以根据数据包的源接口和目的接口来选择是否丢弃它。如果想丢弃所有到达接口eth0的数据包，你需要做的仅仅是将in-&gt;name 的值与”eth0”做比较，如果名字匹配，那么hook函数简单的返回NF_DROP即可，数据包会被自动销毁。 基于地址进行过滤:基于数据包的源或目的IP地址进行过滤也同样可以实现， 获取一个数据包的IP头通过使用sk_buff数据结构中的网络层包头来完成。这个头位于一个联合中，可以通过sk_buff-&gt;nh.iph这样的方式来访问。如果数据包的源地址与我们设定的丢弃数据包的地址匹配，那么该数据包将被丢弃。 基于TCP端口进行过滤:获取一个TCP头的指针是一件简单的事情,而可以分配一个tcphdr数据结构(在linux/tcp.h中定义)的指针，并将它指向我们的数据包中IP头之后的数据。如下代码： 12345678910111213141516171819202122232425262728static int check_tcp_packet(struct sk_buff *skb)&#123; struct sk_buff *sk = skb_copy(skb, 1); struct tcphdr *tcph = NULL; const struct iphdr *iph = NULL; struct iphdr *ip; __be16 dport; if (!skb) return NF_ACCEPT; ip = ip_hdr(sk); iph = ip_hdr(skb); if(ip-&gt;protocol == IPPROTO_TCP) // TCP 协议 &#123; tcph = (void *) iph + iph-&gt;ihl * 4; // TCP 包头 dport = tcph-&gt;dest; // 目标端口 if(ntohs(dport) == 25 ) &#123; return NF_DROP; &#125; else &#123; return NF_ACCEPT; &#125; &#125; return NF_ACCEPT; &#125; 6、下一步延伸更多更深的内容需要进一步学习linux内核，这里就不再细述了，关于Netfilter的hook攻击技术以及libpcap的通信隐藏等都挺有意思的，有时间不妨深入去实践一下。 参考链接1.https://arthurchiao.github.io/blog/deep-dive-into-iptables-and-netfilter-arch-zh/2.https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html3.https://blog.csdn.net/cheng_fangang/article/details/89662424.https://blog.csdn.net/XscKernel/article/details/8186679","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://WenDeng.github.io/categories/网络协议/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"},{"name":"Iptabls","slug":"Iptabls","permalink":"http://WenDeng.github.io/tags/Iptabls/"},{"name":"Netfilter","slug":"Netfilter","permalink":"http://WenDeng.github.io/tags/Netfilter/"}],"keywords":[{"name":"网络协议","slug":"网络协议","permalink":"http://WenDeng.github.io/categories/网络协议/"}]},{"title":"3.字典序","slug":"算法与数据结构/3.字典序","date":"2019-03-09T03:44:12.000Z","updated":"2019-05-17T07:44:15.050Z","comments":true,"path":"2019/03/09/算法与数据结构/3.字典序/","link":"","permalink":"http://WenDeng.github.io/2019/03/09/算法与数据结构/3.字典序/","excerpt":"给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…","text":"给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120… 字典序 题目原链接：https://www.nowcoder.com/practice/6c9d8d2e426c4c58bbadfdf67d591696?tpId=85&amp;&amp;tqId=29877&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 1.题目描述给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120… 2.输入描述 输入仅包含两个整数n和m。数据范围:对于20%的数据, 1 &lt;= m &lt;= n &lt;= 5 ;对于80%的数据, 1 &lt;= m &lt;= n &lt;= 10^7 ;对于100%的数据, 1 &lt;= m &lt;= n &lt;= 10^18. 3.输出描述 输出仅包括一行, 即所求排列中的第m个数字. 4.示例输入111 4 输出12 5.解题思路参考链接：https://www.nowcoder.com/questionTerminal/fc05f68c5f47438db54c6923ef23cf4a。 在具备字典树相关知识的基础上，不难想象如下字典树：123456789101112graph TB1--&gt;101--&gt;111--&gt;...1--&gt;192--&gt;202--&gt;212--&gt;....10--&gt;10010--&gt;10110--&gt;.....10--&gt;109 由上图可知，需要计算每个节点所对应的子节点数，节点数就是上级节点10，可知总的节点数= 1 + （1 10） + （1 10 10） + （1 10 10 * 10） +……，需要注意的是，节点的值必须小于等于n，所以大于n的值是必须去掉的。 具体求解过程如下: （1）记所求的第m个数为value=1，从start=value查找，end=value+1最为边界，m等于0时结束，value即为所求值。 （2）求start的子节点中值在n以内的子节点个数，记为count。 （3）比较count和m的大小： 若count&gt;m,则所求值在value的子节点中，value=value*10,m–； 若count&lt;=m,则所求的值不在value的子节点中，value=value+1,m=m-count; 回到第一步继续求值 6.实现代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std; int main()&#123; long m,n,start,end,value=1,count; cin&gt;&gt;n&gt;&gt;m; m--;//默认把当前点算入进来 while(m!=0) &#123; start=value; end=value+1; count=0; while(start&lt;=n)//求出当前value的子树数 &#123; //求出当前一层，能算入的子树数目 count+=((n+1)&gt;end?end:(n+1))-start; start=start*10;//进入下一层 end=end*10; &#125; if(count&gt;m) &#123; //当前value的子树数目大于m，所求节点在value的子树中 value=value*10; m--; &#125; else &#123; //当前value的子树数目小于m,进入value+1继续寻找其子树 m=m-count; value++; &#125; &#125; cout&lt;&lt;value&lt;&lt;endl; return 0;&#125; 6.思考与分析 代码不长，除了具备相应知识外，能静下心来慢慢理清思路并实现也是一种能力。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}],"tags":[{"name":"字典树","slug":"字典树","permalink":"http://WenDeng.github.io/tags/字典树/"},{"name":"trie树","slug":"trie树","permalink":"http://WenDeng.github.io/tags/trie树/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}]},{"title":"2.异或","slug":"算法与数据结构/2.异或","date":"2019-03-08T09:44:12.000Z","updated":"2019-05-17T07:44:07.131Z","comments":true,"path":"2019/03/08/算法与数据结构/2.异或/","link":"","permalink":"http://WenDeng.github.io/2019/03/08/算法与数据结构/2.异或/","excerpt":"给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。","text":"给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。 异或 题目原链接：https://www.nowcoder.com/practice/fc05f68c5f47438db54c6923ef23cf4a?tpId=85&amp;&amp;tqId=29876&amp;rp=3&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 1.题目描述给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。 2.输入描述 第一行包含两个整数n,m.第二行给出n个整数A1，A2，…，An。数据范围:对于30%的数据，1 &lt;= n, m &lt;= 1000对于100%的数据，1 &lt;= n, m, Ai &lt;= 10^5 3.输出描述 输出仅包括一行，即所求的答案 4.示例输入123 10 6 5 10 输出12 5.解题思路参考链接：https://blog.csdn.net/qq_30507287/article/details/68947863。 考虑用字典树来解决该题，用示例中6、5、10来构建一颗如下字典树(虚线表示不用)：1234567891011121314151617graph TBroot--&gt;0root--&gt;10-.-&gt;00(0)0--&gt;01(1)01--&gt;010(0)01--&gt;011(1)011--&gt;0110(0)011-.-&gt;0111(1)010-.-&gt;0100(0)010--&gt;0101(1)1--&gt;10(0)1-.-&gt;11(1)10-.-&gt;100(0)10--&gt;101(1)101--&gt;1000(0)101-.-&gt;1001(1) 从已有的数据中选一个数记为a，遍历该字典树（二叉树）,求所有与a异或大于m的数的个数，分情况讨论： 如果a的当前位为0，m的当前位为0，那么明显父节点的右子树的所有数与a异或都大于m；但左子树不能确定，需要继续查询。 如果a的当前位为1，m的当前位为0，那么明显父节点的左子树的所有数与a异或都大于m；但右子树不能确定，需要继续查询。 如果a的当前位为0，m的当前位为1，那么明显父节点的左子树中的数和a异或一定小于m，查询结束；右子树的数不能确定，需要继续查询。 如果a的当前位为1，m的当前位为1，那么明显父节点的右子树中的数和a异或一定小于m，查询结束；左子树的数不能确定，需要继续查询。 具体求解过程如下: （1）依次读取n,m,将n个数依次放入数组并且构建对应的字典树。 （2）获取获取数组中的数，查询字典树，计算与其异或值大于m的数的个数。 （3）得到的count除2，因为如果a\\^b大于m,那么b\\^a也会大于m。 6.实现代码123456789101112131415161718192021222324**@bref:暴力求解，好像是可以通过80%，果然暴力还是不行*int main()&#123; int n,m,i,j,result,count=0,*value; cin&gt;&gt;n&gt;&gt;m; value=new int[n]; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;value[i]; &#125; for(i=0;i&lt;n-1;i++) &#123; for(j=i+1;j&lt;n;j++) &#123; result=value[i]^value[j]; if(result&gt;m) count++; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 能通过的解法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;using namespace std;/** @bref:参考了大神们的思路，服气* 了解字典树之后，理解这个题的解法就好多了*///定义字典树节点class trieTree&#123; public: int num; trieTree *son[2]; public: trieTree(int num) &#123; this-&gt;num=num; son[0]=nullptr; son[1]=nullptr; &#125;&#125;;int foo;static void insert(int a,trieTree *current)&#123; //插入每一个节点，17位所能表示的最大值位131071 for(int i=16;i&gt;=0;i--) &#123; foo=(a&gt;&gt;i)&amp;1;//获取对应的位 if(current-&gt;son[foo] == nullptr) &#123; current-&gt;son[foo]=new trieTree(0); &#125; current=current-&gt;son[foo]; current-&gt;num++;//记数加1 &#125;&#125;//查询结果static int query(trieTree *root,int a,int m,int i)&#123; if(root==nullptr) return 0; trieTree *current=root; int aDigit=(a&gt;&gt;i)&amp;1; int mDigit=(m&gt;&gt;i)&amp;1; if(aDigit==0 &amp;&amp; mDigit==0) &#123; int p=(current-&gt;son[1]==nullptr? 0:current-&gt;son[1]-&gt;num); int q=query(current-&gt;son[0],a,m,i-1); return p+q; &#125; else if(aDigit==1 &amp;&amp; mDigit==0) &#123; int q=(current-&gt;son[0]==nullptr? 0:current-&gt;son[0]-&gt;num); int p=query(current-&gt;son[1],a,m,i-1); return p+q; &#125; else if(aDigit==0 &amp;&amp; mDigit==1) &#123; if(current-&gt;son[1]==nullptr) return 0; return query(current-&gt;son[1],a,m,i-1); &#125; else if(aDigit==1 &amp;&amp; mDigit==1) &#123; if(current-&gt;son[0]==nullptr) return 0; return query(current-&gt;son[0],a,m,i-1); &#125; return 0;&#125;int main()&#123; int m,n,*data; long count=0; trieTree root(-1); cin&gt;&gt;n&gt;&gt;m; data=new int[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;data[i]; insert(data[i],&amp;root);//将所有的数 &#125; for(int i=0;i&lt;n;i++) &#123; count+=query(&amp;root,data[i],m,16); &#125; cout&lt;&lt;count/2&lt;&lt;endl; return 0;&#125; 6.思考与分析这种题目的第一思路是暴力求解，虽然很大概率是不行的，但不妨一试，能想出合理高效的求解方案不是每一个人都能做到的，问题的抽象能力、联想能力往往是解题的关键，常备知识，遇到问题才能直击痛点，庖丁解牛。在写这个题的时候，我自己实现了代码，但是感觉完全没问题，然后提交之后一直只通过80%，我后来花了将近两天的时间近乎一直在想这个题，最后突然灵光发现是用来存结果的count值是int型，而实际结果要大于int型所能表示的范围。真的服气…….我发誓以后存结果的数一定用long。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}],"tags":[{"name":"字典树","slug":"字典树","permalink":"http://WenDeng.github.io/tags/字典树/"},{"name":"trie树","slug":"trie树","permalink":"http://WenDeng.github.io/tags/trie树/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}]},{"title":"1.保卫方案","slug":"算法与数据结构/1.保卫方案","date":"2019-03-08T08:44:12.000Z","updated":"2019-05-17T07:43:58.094Z","comments":true,"path":"2019/03/08/算法与数据结构/1.保卫方案/","link":"","permalink":"http://WenDeng.github.io/2019/03/08/算法与数据结构/1.保卫方案/","excerpt":"战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。","text":"战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。 保卫方案 题目原链接：https://www.nowcoder.com/practice/e1967ae812ea42e7a3ce57ee1f83b686?tpId=85&amp;tqId=29878&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 1.题目描述战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。 2.输入描述 输入中有多组测试数据，每一组测试数据的第一行为一个整数n(3&lt;=n&lt;=10^6),为首都周围的小山数量，第二行为n个整数，依次表示为小山的高度h（1&lt;=h&lt;=10^9）. 3.输出描述 对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。 4.示例输入1251 2 4 5 3 输出17 5.解题思路这个题想了好长时间，但是一直没想出来怎么做，参考了大神的解体思路后，总算想清楚了，原链接如下：http://www.cnblogs.com/mengmz/p/7263915.html。 分析题目可知，对于山峰a,如果能在它的左边和右边分别找到最近且比它大的b和c，那么b能看到a，a能看到c，即整体计数对应加2。那么题目可以分为如下两种情况进行讨论： 对于数组中无重复数字出现的情况，在构成环的全部元素当中，最大值和次大值只有一边存在比它大的数，但能彼此看到，故计数值加1。除了这两个元素外，剩下的n-2个元素都能在左边和右边分别找到比它大的数，故计数值加（n-1）2。即总的结果为：1+（n-2）2。 对于有重复数字出现的情况，假设有一组序列为a,a,b,b,b,c,c且a&gt;b,c&gt;b。a,b,c分别出现的次数为2,3,2，b各元素能互相看见，故b自身能构成的组合数为：c(3,2)=3(3-2)/2。同时所有的b都能看到最后一个a和第一个c，所以计数值加3+3。如果用N1,N2,N3分别表示a,b,c出现的话，则总的结果为：c(N2,2)+2N2; 分析完两种情况后，现在我们需要求出每一个数和两边大于这个数的情况，采用单调栈来解决，具体求解过程如下: （1）读取所有数据，放入数组V，计数值count=0。 （2）新建数组P，遍历数组V，将V中的元素消除重复后放入P中，并记录下每个元素重复的次数。同时找出最大的元素max和其在P中下标max_i。 （3）创建堆栈S，然后从max_i开始遍历所有P中元素。进行如下操作： 若堆栈为空， 将P[i]直接压入堆栈； 若堆栈为非空，将P[i]与栈顶元素进行比较，如果大于栈顶元素，count加上栈顶元素的组合数（重复数N,组合数为c(N,2)+N,注意此时只考虑栈顶元素和P[i]的组合数），然后弹出栈顶元素，若栈不为空，则弹出的数和栈顶数也有组合数，count加弹出数的重复数N，执行本步骤一直弹出直到P[i]小于栈顶元素； 若等于栈顶元素，栈顶元素的重复数+P[i]的重复数，继续执行； 若小于栈顶元素，直接压入； (4)上个步骤结束后，得到一个递减的堆栈。依次弹出栈顶元素到temp，直到堆栈为空，count加上其组合数目,这个时候要考虑以下情况： 堆栈中剩余元素个数多于1,则temp的组合数为c(N,2)+N*2。 堆栈中的剩余元素个数为1，若剩余元素的重复次数n大于1，则temp的组合数为c(N,2)+N*2（如4,4,3,3,3序列，所有的3能看到第一个4和最后一个4）；若剩余的重复次数为1，则temp的组合数为c(N,2)+N（如4,3,3,3序列） 堆栈中的剩余元素个数为0，此时temp为最大值，组合数跟其重复次数N有关,为c(N,2)； 6.实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;//用结构体来保存每个山峰的高度，和重复的次数struct node&#123; int val; long count; node(int v,int c=1): val(v),count(c)&#123;&#125;;&#125;;int main()&#123; int n,value,i,max,max_i; long count=0; cin&gt;&gt;n; vector&lt;int&gt; mountin(n); vector&lt;node&gt; mnode;//去重和计数 for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;mountin[i];//依次获取每个山峰的值 &#125; node temp(mountin[0]); max=mountin[0]; for(i=1;i&lt;n;i++)//去重和寻找最大值 &#123; if(mountin[i]==temp.val)//若重复 &#123; temp.count++;//计数 &#125; else &#123; mnode.push_back(temp); if(max&lt;temp.val)//获取最大峰值和对应下标 &#123; max=temp.val; max_i=mnode.size()-1;//注意，这里获取的去重后的下标 &#125; temp.val=mountin[i]; temp.count=1; &#125; &#125; mnode.push_back(temp); if(max&lt;temp.val)//获取最大峰值和对应下标 &#123; max=temp.val; max_i=mnode.size()-1;//注意，这里获取的去重后的下标 &#125; stack&lt;node&gt; s; n=0; for(i=max_i;n&lt;mnode.size();++n,i=(i+1)%mnode.size()) &#123; while(!s.empty() &amp;&amp; mnode[i].val&gt;s.top().val) &#123; //数组元素大于栈顶元素的情况 temp.val=s.top().val; temp.count=s.top().count; count+=temp.count*(temp.count-1)/2+temp.count; s.pop(); if(!s.empty()) count+=temp.count; &#125; //数组元素小于栈顶元素的情况 if(s.empty()||mnode[i].val&lt;s.top().val) s.push(mnode[i]); else //数组元素等于栈顶元素的情况 &#123; s.top().count+=mnode[i].count; &#125; &#125; //对最后的递减栈进行求解 while(!s.empty()) &#123; temp.val=s.top().val; temp.count=s.top().count; s.pop(); if(s.size()&gt;1) count+=temp.count*(temp.count-1)/2+2*temp.count; else if(s.size()==0) count+=temp.count*(temp.count-1)/2; else //堆栈中还剩一个值的情况 &#123; if(s.top().count==1) //如4，3，3，3 &#123; count+=temp.count*(temp.count-1)/2+temp.count; &#125; else //如4,4，3，3，3 &#123; count+=temp.count*(temp.count-1)/2+2*temp.count; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 6.思考与分析 解题的时候还是需要学会将大问题化解之后进行分析，分情况不断讨论，然后也就能分而解之，水到渠成。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://WenDeng.github.io/tags/动态规划/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://WenDeng.github.io/categories/算法与数据结构/"}]},{"title":"《深度探索c++对象模型》（七）站在对象模型的顶端","slug":"深度探索c++对象模型/《深度探索c++对象模型》（七）","date":"2018-11-22T08:44:12.000Z","updated":"2019-05-17T07:44:43.738Z","comments":true,"path":"2018/11/22/深度探索c++对象模型/《深度探索c++对象模型》（七）/","link":"","permalink":"http://WenDeng.github.io/2018/11/22/深度探索c++对象模型/《深度探索c++对象模型》（七）/","excerpt":"本章的的主题是站在对象模型的尖端，套路哦三个著名的c++语言扩充性质，它们都会影响c++对象，他们分别是exception handling（EH）、template support、runtime type identification(RTTI)。","text":"本章的的主题是站在对象模型的尖端，套路哦三个著名的c++语言扩充性质，它们都会影响c++对象，他们分别是exception handling（EH）、template support、runtime type identification(RTTI)。 一、Template这一节的焦点放在template的语意上面，我们将讨论templates在编译系统中“何时”，“为什么”以及“如何”发挥其功能。下面是有关template的三个主要讨论方向： template的声明，基本上来说就是当你声明一个template class、template class member function等等，会发生什么事情。 如何”实例化”class object、inline nonmember以及member template functions，这些是”每一个编译单元都会拥有的一份实体”的东西。 如何“实例化”出nonmember、member templates functions以及static template class members，这些都是”每一个可执行文件中只需要一份实体”的东西，这也就是一般而言template所带来的问题。 1.template的“实例化”行为对于如下template class:1234567891011121314151617template&lt;class Type&gt;class Point&#123;public: enum Status &#123; unallocated, normalized &#125;; Point(Type x = 0.0, Type y = 0.0, Type z = 0.0); ~Point(); void *operator new(size_t ); void operator delete(void *, size_t ); //...private: static Point&lt;Type&gt; *freeList; static int chunkSize; Type _x, _y, _z;&#125;; 编译器对于template class会根据type的不同而产生不同的实例class。 enum Status、freeList、chunkSize以及object都必须进行实例化，如Point::freeList;,而不能是Point::freeList;`。 定义一个指针，指向特定的实例。例如Point *ptr=0;因为一个指向class object的指针，本身并不是一个class object，编译器不需要知道与该class有关的任何member的数据或object的布局数据。所以不需要实例化。 定义一个reference,例如Point &amp;refer=0;就需要产生一个Point的float实例。 2.member function需要实例化吗？member functions(至少对于那些未被使用过的)不应该被“实体”化，只有在member functions被使用的时候，C++ Standard才要求它们被“实例化”。当前的编译器并不精 确遵循这项要求，之所以由使用者来主导“具现”规则，有两个主要原因： 空间和时间效率的考虑。如果class中有100个member functions，但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中5个，那么其他193个函数都“具现”将花费大量的时间和空间。 尚未实现的功能，并不是一个template实例化的所有类型就一定能够支持一组member functions所需要的所有运算符。如果只“具现”那些真正用到的memeber functions，template就能够支持那些原本可能会造成编译时期错误的类型(types)。 3.template的错误报告。目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行以有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让它通过了，只有在特定实例被定义之后，才能发出抱怨。这是目前实现技术上的一个大问题。 4.Template中的名称决议法。Template有两种语境，一种是C++ Standard所谓的”Scope of the template definition”，也就是“定义出template”的程序。另一种是C++ Standard所谓的”scope of the template instantiation”，也就是说“具现出template”的程序。Template之中，对于一个nonmember name的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而设定的。如果其使用互不相关，那么就以“scope of the template declaration”来决定name。如果其使用互有关联，那么就以“scope of template instantiation”来决定name。例如：123456789101112131415161718//scope of the template definitionextern double foo(double); template&lt;class type&gt;class ScopeRules&#123;public: void invariant() &#123; _member = foo(val); &#125; type type_dependent() &#123;return foo(_member);&#125; //...private: int _val; type _member;&#125;;//scope of the template instantiationextern int foo(int);//...ScopeRultes&lt;int&gt; sr0; 对于sr0.invariant();由于被用来实例化这个template的真正类型，对于 _val的类型并没有影响。所以选中extern double foo(double); 对于sr0.type_dependent();_member与template参数有关,所以选中的foo()跟参数有关,所以选中extern int foo(int);。 5.Member function的实例化行为。对于template的支持，最困难的莫过于template function的实例化，目前的编译器提供了 两个策略：一个是编译时期策略，程序代码必须在program text file中备妥可用；另一个是链接时期策略，程序代码必须在meta-compliation工具可以导引编译器的实例化行为(instantiation)。下面是编译器设计者必须回答的三个主要问题： （1）编译器如何找出函数的定义？答案之一是包含template program text file，就好像它是个header文件一样，Borland编译器就是遵循这个策略。另一种方法是要求一个文件命名规则，例如，我们可以要求，在Point.h文件中发现的函数声明，其template program text一定要放置于文件Point.c或者Point.cpp中，以此类推。cfront就是遵循这个策略。Edison Desigin Group编译器对此两种策略都支持。 （2）编译器如何能够只实例化出程序中用到的member functions?解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的——虽然它也提供#pragmas让你压制(或具现出)特定实体。另一种策略就是仿真链接操作，检测看看哪一个函数真正需要，然后只为它(们)产生实体。cfront就是这么做的，Edison Design Group编译器对此两种策略都支持。 （3）编译器如何阻止member definitions在多个.o文件中都被实例化呢?解决办法之一是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另外一个办法就是由使用者来导引“仿真链接阶段”的实例化策略，决定哪些实体(instances)才是所需求的。 实际上，template instantiation似乎拒绝全面自动化，甚至居然没意见工作都对了，产生出来的object files的重新编译成本仍然可能很高。以手动方式先在个别的object module中完成预先实例化操作，虽然沉闷，却是唯一有效率的方法。 二、异常处理1.编译对异常处理的支持欲支持exception handling，编译器的主要工作就是找出catch子句，以处理被丢出来的exception。这多少需要追踪程序堆栈中的每一个函数当前作用区域(包括追踪函数中的local class objects当时的情况)。同时，编译器必须提供某种查询exception objects的方法，以知道其实际类型(这直接导致某种形式的执行期识别，也就是RTTI)。最后，还需要某种机制用以管理被丢出的object，包括它的产生、储存、可能的解构(如果有相关的destructor)、清理(clean up)以及一般存取，也可能有一个以上的objects同时起作用。 一般而言，exception handling机制需要与编译器所产生的数据结构以及执行期的一个exception library紧密合作，在程序大小和执行速度之间，编译器必须有所抉择： 为了维持执行速度，编译器可以在编译时期建立起用于支持的数据结构，这会使程序大小膨胀，但编译器可以几乎忽略这些结构，直到有个exception被丢出来。 为了维持程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构(并且可以抛弃之)。 2.Exception Handling 快速检阅C++的exception handing由三个主要的语汇组件构成： 一个throw子句。它在程序某处发出一个exception。被抛出去的expection可以是內建类型，也可以是使用者自定类型。 一个或多个catch子句。每一个catch子句都是一个exception handler。它用来表示说，这个子句准备处理某种类型的exception，并且在封闭的大括号区段中提供实际的处理程序 一个try区段。它被围绕以一系列的叙述句(statements)，这些叙述句可能会引发catch子句起作用 当一个exception被丢出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate()会被调用。当控制权被抛弃后，堆栈中的每一个函数调用也就被推离(popped up)，这个程序称为unwinding the stack。在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用。 3.对Exception Handling的支持当一个exception发生时，编译系统必须完成以下事情：（1）检验发生throw操作的函数；（2）决定throw操场是否发生在try区段中；（3）若是，编译系统必须把exception type拿来和每一个catch子句比较；（4）如果比较吻合，流程控制应该交到catch子句手中；（5）如果throw的发生并不在try区段中，并没有一个catch子句吻合，那么系统必须(a)摧毁所有active local objects，(b)从堆栈中将当前的函数”unwind”掉，(c)进行到程序堆栈中的下一个函数中去，然后重复上述步骤2~5 4.当一个实际对象在程序执行时被丢出，会发生什么事？当一个exception被丢出时，exception object会被产生出来并通常放置在相同形式的exception数据堆栈中，从throw端传染给catch子句的是exception object的地址、类型描述器(或是一个函数指针，该函数会传回与该exception type有关的类型描述器对象)，以及可能会有的exception object描述器(如果有人定义它的话)。 三、执行器类型识别（RTTI）RTTI是用于支持EH而获得的副产品，主要目的是处理和识别throw的object类型。 1.Type-Safe Downcast(保证安全的向下转型操作)一个type-safe downcast(保证安全地向下转换操作)必须在执行期对指针有所查询，看看它是否指向它所展现(表达)之object的真正类型。因此，欲支持type-safe downcast在object空间和执行时间上都需要一些额外的负担： 需要额外的空间以存储类型信息(type information)，通常是一个指针，指向某个类型信息节点 需要额外的时间以决定执行期的类型(runtime type)，因为，正如其名所示，这需要再执行期才能决定。 c++的RTTI机制提供了一个安全的downcast设备,但只对那些展现“多态”的类型有效。c++中，一个具备多态性质的class，正式内含着继承而来的virtual function。 2.Type-Safe Dynamic cast(保证安全的动态转型)dynamic_cast运算符可以在执行期决定真正的类型。如果downcast是安全的，这个运算符会传回被适当转换过的指针。如果downcast不是安全地，这个运算符会传回0. 3.References并不是Pointers程序中对一个class指针类型施以dynamic_cast运算符，会获得true或false： 如果传回真正的地址，表示这个object的动态类型被确认了，一些与类型相关的操作现在可以施行于其上。 如果传回0，表示没有指向任何object，意味应该以另一种逻辑施行于这个动态类型未确定的object身上。 dynamic_cast运算符也适用于reference身上。然而对于一个non-type-safe cast，其结果不会与施行于指针的情况相同。为什么？一个reference不可以像指针那样”把自己设为0就代表了”no object”；若将一个reference 设为0，会引起一个临时性对象(拥有被参考到的类型)被产生出来，该临时对象的初值为0，这个reference然后被设定成为该临时性对象的一个别名。因此当dynamic_cast运算符施行于一个reference时，不能够提供对等于指针情况下的那一组true/false。取而代之的是，会发生下列事情： 如果reference真正参考到适当的derived class(包括下一层或下下一层或下下下一层或…)，downcast会被执行而程序可以继续执行。 如果reference并不真正是某一种derived class，那么，由于不能传回0，遂丢出一个bad_cast exception. 4.Typeid运算符typeid运算符传回一个const reference，类型为type_info。type_info object由什么组成？ C++ Standard中对type_info的定义如下：12345678910111213class type_info&#123;public: virtual ~type_info(); bool operator==(const type_info&amp; ) const; bool operator!=(const type_info&amp; ) const; bool before(const type_info&amp;) const; bool char* name() const; //传回class原始名称private: //prevent memberwise init and copy type_info(const type_info&amp; ); type_info&amp; operator=(const type_info&amp; ); //data members&#125;; 编译器必须提供的最小量信息是class的真实名称、以及在type_info objects之间的某些排序算法(这就是before()函数目的)、以及某些形式的描述器，用以表现explicit class type和这个class的任何subtype。 四、效率有了，弹性呢？创痛的c++对对象模型提供有效率的执行期支持。这份效率，再加上与c之间的兼容性，造成了C++的广泛被接受。然而，在某些领域方面，像是动态共享库、共享内存以及分布式对象方面，这个对象模型的弹性还是不够。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（六）执行期语意学","slug":"深度探索c++对象模型/《深度探索c++对象模型》（六）","date":"2018-11-21T08:44:12.000Z","updated":"2019-05-17T07:45:18.886Z","comments":true,"path":"2018/11/21/深度探索c++对象模型/《深度探索c++对象模型》（六）/","link":"","permalink":"http://WenDeng.github.io/2018/11/21/深度探索c++对象模型/《深度探索c++对象模型》（六）/","excerpt":"本章的的主题是执行器语意学，查看执期的某些对象模型行为。包括零时性对象的生命及其死亡，以及对new运算符和delete预算符的支持。","text":"本章的的主题是执行器语意学，查看执期的某些对象模型行为。包括零时性对象的生命及其死亡，以及对new运算符和delete预算符的支持。 0、基础实际上，一个简单的操作，其背后所隐藏的意义都要经过编译器进行适当的解析，编译器所作的工作可能会超出我们的想象许多，编译器所做的这些填充操作最后都会在执行期一一执行，本章就是要看执行期所发生的转换。 一、对象的构造和析构1. 关于构造和析构构造通常在object被定义之后，而destructor要放在每一个离开点之前。一般而言我们会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。 我们很多时候习惯把变量和object的定义放在函数的开始部分，这使得部分不必要的destructor不得不被调用，增加了部分开销。 2. 全局对象C++ 保证，一定会在main()函数中第一次用到global object之前，把它构造出来，而在main() 函数结束之前把global object摧毁掉。global object如果有constructor和destructor的话， 我们说它需要静态的初始化操作和内存释放操作。C++程序中所有的global objects都被放置在程序的data segment中。如果显式指定给它一个值， 此object 将以该值为初值。否则object配置到的内存内容为0。虽然class object在编译时期可以 被放置于data segment中并且内容为0，但constructor一直要到程序启动(startup)时才会实施。 3. 局部静态对象关于局部静态对象，注意两点：（1）即使其所在的函数被调用多次，对应的constructor也只能执行一次。（2）即使其所在的函数被调用多次，对应的deconstructor也只能执行一次。为了能只执行一次对应的constructor，编译器引入一个临时性变量用于进行判断，初始时临时性变量为false，当local static object被构建好后，临时性变量变为true。而destructor则根据该 临时性是否为true决定是否析构local static object。 4. 对象数组C++编译器之一cfront提供一个被命名为ve_new()函数，产生出以class objects构造而 成的数组。在vec_new()中，constructor施行于elem_count个元素之上;在vec_delete()中，destructor被施行于elem_count个元素身上。1Point knots[10] = &#123;Point(),Point(1.0, 1.0, 0.5),-1.0&#125;; 对于上述这种明显获得初值的元素，vec_new()不再有必要。对于那些尚未被初始化的元素，vec_new()的施行方式就像面对“由class elements组成的数组，而该数组没有explicit initialization list”一样。类似下面这样：123456//明确初始化前3个元素Point::Point(&amp;knots[0]);Point::Point(&amp;knots[1], 1.0, 1.0, 0.5);Point::Point(&amp;knots[2], -1.0, 0.0, 0.0);//以vec_new初始化后7个元素vec_new(&amp;knots + 3, sizeof(Point), 7, &amp;Point::Point, 0); 二、new和delete运算符1.new和delete对内置类型的处理。1int *pi = new int(5); 对于如上的语句，实际分为如下两个步骤完成：（1）通过适当的new运算符配置所需的内存。（2）给配置得来的对象设立初值。123456//实际执行过程int *pi;if(pi = _new(sizeof(int))) *pi = 5; //成功了才初始化//delete运算符的情况类似if(pi != 0) _delete(pi); 2.construct如何配置一个class object？以constructor来配置一个class object，处理类似如下：1234567891011Point3d *origin = new Point3d;//被转换为：Point3d *origin;if(origin = _new(sizeof(Point3d))) origin = Point3d::Point3d(origin);//对于delete origin，转换结果类似于：if(origin != 0) &#123; Point3d::~Point3d(origin); _delete(origin);&#125; new运算符实际上总是以标准的C malloc()完成，虽然并没有规定一定得这么做不可。相同情况，delete运算符总是以标准的C free()完成。 3.针对数组的new语意 对于像int *p_array = new int[5];这样的语句，vec_new()不会真正被调用，因为它 的主要功能是把default constructor施行于class objects所组成的数组的每一个元素身上。 对于simple_aggr *p_aggr = new simple_aggr[5];,vec_new()也不会被调用，因为simple_aggr并没有定义一个constructor或destructor，所以配置数组以及清除p_aggr数组的操作，只是单纯地获得内存和释放内存而已，这些操作由new和delete运算符来完成就绰绰有余了。 然而如果class定义有一个default constructo，某些版本的vec_new()就会被调用，配置并构 造class objects所组成的数组，如第一节中所示那样。 寻找数组维度，对于delete运算符的效率带来极大的冲击，所以才导致这样的妥协：只有在中括号出现时，编译器才寻找数组的维度，否则它便假设只有单独一个objects要被删除。 4.Placement Operator new的语意有一个预先定义好的重载的(overloaded) new运算符，称为placement operator new，它需要第二个参数，类型为void*，调用方式如下：1Point2w *ptw = new(arena) Point2w; 其中arena指向内存中的一个区块，用以放置新产生出来的Point2w object。这个预先定义好的placement operator new的实现方法简直是出乎意料的平凡，它只要将“获得的指针”(上例为arena)所指的地址传回。 用这个的意义是什么呢？ 三、临时性对象1.编译器什么时候产生临时性对象和摧毁临时性对象？是否会导致一个临时性对象，视编译器的进取性以及程序上下语境而定。C++ Standard允许编译器对于临时性对象的产生有完全的自由度。c++标准指出，临时性对象的被摧毁，应该是对完整表达式求值过程中的最后一个步骤，该完整表达式造成临时性对象的产生。 2.什么是完整表达式？非正式地说，完整表达式是被涵括的表达式中最外围的那个。1((objA &gt; 1024) &amp;&amp; (objB &gt; 1024) ? objA + objB : foo(objA, objB)); 对于上述表达式，一共有五个子算式，内带一个”? : 完整表达式”中。任何一个子表达式所产生的任何一个临时对象，都应该在完整表达式被求值完成后，才可以毁去。 3.关于临时性对象生命规则的的两个例外。临时性对象的生命规则有两个例外： 第一个例外发生在表达式被用来初始化一个object时，C++ Standard要求说：凡含有表 达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。 临时性对象的生命规则的第二个例外是”当一个临时性对象被一个reference绑定”时。如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之reference的生命结束，或直到临时对象的生命范畴(scope)结束——视哪一种情况先到达而定。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（五）构造、析构、拷贝语意学","slug":"深度探索c++对象模型/《深度探索c++对象模型》（五）","date":"2018-11-20T08:44:12.000Z","updated":"2019-05-17T07:45:11.795Z","comments":true,"path":"2018/11/20/深度探索c++对象模型/《深度探索c++对象模型》（五）/","link":"","permalink":"http://WenDeng.github.io/2018/11/20/深度探索c++对象模型/《深度探索c++对象模型》（五）/","excerpt":"本章的的主题是构造、析构、拷贝语意学。主要是讨论如何支持class模型，探讨object的整个生命周期。","text":"本章的的主题是构造、析构、拷贝语意学。主要是讨论如何支持class模型，探讨object的整个生命周期。 0、基础1. class data member应该何时被初始化？一般而言，class的data member应该被初始化，并且只在constructor中或是在class的其他member functions中指定初值。其他任何操作都将破坏封装性质，使class的维护和修改更加困难。 2. 关于纯虚函数的几点认识。 c++中可以定义和调用(invoke)一个pure virtual function：不过它只能被静态地调用(用类名调用)，不能经由虚拟机制调用。 class设计者如果声明就一定要定义pure virtual destructor，因为每一个 derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏 任何一个base class destructor的定义，就会导致链接失败。最好的方式就是不要把virtual destructor声明为pure。 3. 关于虚拟机制的几点认识。 类中设计虚函数时应先考虑清楚，不会被derived class改写的函数最好被设计 为virtual function。总靠编译器进行优化并不是好的设计理念。 决定一个virtual function是否为const需要先想清楚，不必要的地方别用。 一、“无继承”情况下的对象构造1.对象的生命周期。一个object的生命，是该object的一个执行期属性。local object的生命对应其所 在的scope。global object的生命和整个程序的生命相同。heap object的生命从 它被new运算符配置出来开始，到它被delete运算符摧毁为止。 2.Plain OI’ Data 和其相关处理形如下列的结构，被C++标准称为Plain OI’ Data。123typedef struct&#123; float x, y, z;&#125;Point; 如果以C++ 来编译这段码，理论上编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator。但实际上，编译器会分析这个声明，并为它贴上Plain of Data标签。 对于Point global;理论上,constructor在程序起始处被调用而destructor 在程序的exit()处被调用。然而，事实上那些tirvial members要不是没被定义， 就是没被调用，程序的行为一如它在C中的表现一样。此外，C++ 的所有全局对象都被当作“初始化过的数据”来对待。 对于Point *heap = new Point;会被转换为对new运算符的调用。但并没有default constructor施行与new运算符所传回的Point object身上。 *heap = local;理论上，这样的指定操作会触发trivial copy assignment operator进行拷贝搬运操作。然而实际上此object是一个Plain old data，所以赋值操作(assignment)将只是像C那样的纯粹位搬移操作。 delete heap;会被转换为对delete运算符的调用,观念上，这样的操作会触发Point的trivial destructor。但是一如我们所见，destructor要不是没有被产生就是没有被调用。 3.抽象数据类型(Abstract Data Type)和其相关处理以下是Point的第二次声明，在public接口之下多了private数据，提供完整的封装性，但是没有提供virtual function:1234567class Point&#123;public: Point(float x = 0.0, float y = 0.0, float z = 0.0): _x(x), _y(y),_z(y) &#123; &#125; //no copy constructor, copy operator or destructor definedprivate: float _x, _y, _z;&#125;; 对于Point，我们不需要定义一个copy constructor或copy assignment operator，因为默认的位拷贝已经足够，也不需要destructor,因为默认的内存管理方法也已经足够，如果我们不自己定义，编译器也因为判断不会用到而不会产生的函数。 对于Point global;default constructor作用于其上。由于global被定义在全局范畴中，其初始化操作将延迟到程序激活时才开始，扩展调用default constructor。如果要将class中的所有成员都设定常 量初值，那么给予一个explicit initialization list会比较有效率些 。 对于Point *heap = new Point;`会被转换为对new运算符的调用。然后调用default Point Constructor并自行扩展。 *heap = local;理论上，这样的指定操作会触发trivial copy assignment operator进行拷贝搬运操作。然而并没有，只进行简单的位拷贝操作。 delete heap;，由于没有destrucor,同样不会被调用。 4.在上述情况中加入虚函数又将怎么处理？将人虚函数之后，class object除了多负担一个vptr之外，也引发编译器对Point class产生膨胀作用。例如：12345678class Point&#123;public: Point(float x = 0.0, float y = 0.0): _x(x), _y(y) &#123; &#125; //no destructor, copy constructor or copy operator virtual float z();protected: float _x, _y;&#125;; 首先constructor将需要附加一些代码用于将vptr初始化。这些代码位于base class构造函数和用户代码之间。 12345678Point* Point::Point(Point *this, float x, float y): _x(x), _y(y)&#123; this-&gt;_vptr_Point = _vtbl_Point; //设定object的virtual table pointer this-&gt;_x = x; //扩展member initialization list this-&gt;_y = y; return this; //传回this对象&#125; 其次需要合成一个copy constructor和一个copy assignment operator，因为直接bitwise操作对于vptr可能是非法的。 12345678//copy constructor的内部合成inline Point* Point::Point(Point* this, const Point&amp; rhs)&#123; this-&gt;_vptr_Point = _vtbl_Point;//设定object的vptr //将rhs坐标中的位连续拷贝到this对象 //或是经由member assignment提供一个member... return this;&#125; 一般而言，如果你的设计之中有许多函数都需要以传值方式传回一个local class object，此时提供一个copy constructor就比较合理，它的出现会触发NRV优化。NRV 优化后就不再需要调用copy constructor，因为运算结果已经被直接置于“将被传回 的object”体内了。(有它-&gt;NRV-&gt;不用它？？？？) 二、继承体系下的对象构造1. 编译器会对constructor做什么？像这样T object定义一个对象时,会调用constructor,其内部做的工作包括： （1）记录在member initialization list中的data members初始化操作会被放进constructor的函数本身，并以members的声明顺序为顺序。 （2）如果有一个member并没有出现在member initialization list中，但它有一个default constructor，那么该default constructor必须被调用。 （3）在那之前，如果class object有virtual functions, 它们必须被设定初值，指向适当的virtual tables. （4）在那之前，所有上一层的base class constructors必须被调用，以base class生声明顺序为顺序(与member initialization list中的顺序没有关联)： 如果base class被列于member initialization list中，那么任何明确指定的参数都应该被传递进去。、 如果base class没有被列于member initialization list中，而它有default constructor(或default memberwise copy constructor),那么就调用之。 如果base class是多重继承下的第二或后继的base class，那么this指针必须有所调整。 （5）在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅 如果class被列于member initialization list中，那么如果有任何显式指定的参数，都应该传递过去。若没有列于list之中，而class有一个default constructor，亦应该调用之 此外，class中的每一个virtual base class subobject的偏移位置(offset)必须在执行期可被存取 如果class object是最底层(most-derived)的class，其constructors可能被调用，某些用以支持这一行为的机制必须被放进来。 2. 一个实例说明编译器在对象构造的过程中所做的操作。有一个基类和其对应的派生类如下：1234567891011class Point&#123; public: Point(float x = 0.0, float y = 0.0); Point(const Point&amp;); //copy constructor Point&amp; operator=(const Point&amp;); //copy assignment operator virtual ~Point(); //virtual destructor virtual float z() &#123; return 0.0; &#125; protected: float _x, _y; &#125;; 123456789class Line&#123; Point _begin, _end; public: Line(float = 0.0, float = 0.0, float = 0.0, float = 0.0); Line(const Point&amp;, const Point&amp;); draw(); //...&#125;; （1）对于Line::Line(const Point&amp; begin, const Point&amp; end): _end(end), _begin(begin) {},它会被编译器扩充并转换为： 12345Line* Line::Line(Line *this, const Point&amp; begin, const Point&amp; end)&#123; this-&gt;_begin.Point::Point(begin); this-&gt;_end.Point::Point(end); return this;&#125; （2）对于Line a;implicit Line destructor会被合成出来(如果Line派生自Point,那么合成出来的destructor将会是virtual。然而由于Line只是内带Point objects而非继承自Point，所以被合成出来的destructor只是nontrivial而已)。在其中，它的member class objects的destructor会被调用(与其构造的相反顺序): 1234inline Line::~Line(Line *this)&#123; this-&gt;_end.Point::~Point(); this-&gt;_begin.Point::~Point();&#125; (3) 对于Line b=a;implicit Line copy constructor会被合成出来，成为一个inline public member; (4) 对于a=b;同样，implicit assignment operator会被合成出来，成为一个inline public member; 3. 虚拟继承：constructor怎么处理virtual base class的构造？试想下面三种类派生情况：123class Vertex : virtual public Point&#123; ... &#125;class Vertex3d : public Point3d, public Vertex&#123; ... &#125;class PVertex : public Vertex3d &#123; ... &#125; Vertex的constructor必须调用Point的constructor。然而当Point3d和Vertex同为Vertetx3d的subobjects时，它们对Point constructor的调用操作一定不可以发生，取而代之的是，作为一个最底层的class，Vertex3d有责任将Point初始化，而更往后(往下)继承，则由PVertex来负责完成“被共享之Point subobject”的构造。对于Vertex3d，当调用Point3d和Vertex的constructor时，可以通过如下扩展，把_most_derived参数设为flase从而不调用Point的构造函数。12345678910//在virtual base class情况下的constructor扩充内容Point3d* Point3d::Point3d(Point3d* this, bool _most_derived, float x, float y, float z)&#123; if(_most_derived != false) this-&gt;Point::Point(x, y); this-&gt;_vptr_Point3d = _vtbl_Point3d; this-&gt;vptr_Point3d_Point = _vpbl_Point3d_Point; this-&gt;_z = rhs._z; return this;&#125; “virtual base class constructors的被调用”有着明确的定义：只有当一个完整的class object被定义出来时，它才会被调用；如果object只是某个完整object的subject，它就不会被调用。 4. vptr初始化语意学：什么时候设置vptr合适？constructor的执行算法通常如下： (1) 在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructors会被调用 (2) 上述完成之后，对象的vptrs被初始化，指向相关的virtual tables (3) 如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。 (4) 最后，执行程序员所提供的代码。 三、对象复制语意学(Object Copy Semantics)1. 怎样显式地拒绝将一个class object指定给另一个class object？如果想要禁止将一个class object指定给另一个class object，那么只要将copy assignment operator声明为private,并且不提供其定义即可。 2. 关于copy assignment operator。对于编译器来说，class如果有了bitwise copy语意，implicit copy assignment copy就会被视为无用的，从而也不会被合并出来。一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意： （1）当class内含一个member object，而其class有一个copy assignment operator时 （2）当一个class的base class有一个copy assignment operator时 （3）当一个class声明了任何virtual functions(我们一定不要拷贝右端class object的vptr地址，因为它可能是一个derived class object)时 （4）当class继承自一个virtual base class(不论base class有没有copy operator)时 copy assignment operator需要考虑的是需不需要被合成？什么时候被合成？当多重继承遇到virtual base class共享时，如何避免中间base class对最上层base class的subobject的多重拷贝？书籍作者的建议是不允许virtual base class的拷贝操作，尽量不要在任何virtual base class中声明数据。 四、析构语义学(Semantics of Destruction)1. 什么时候需要合成destructor?如果class没有定义destructor，那么只有在class内含的member object或base class拥有destructor的情况下，编译器才会自动合成一个出来。否则，destructor被视为不需要，也就不需被合成。 事实上，我们应该拒绝那种被我们称为“对称策略”的奇怪想法：“你已经定义了一个constructor,所以你应该提供一个destructor也是天经地义的事”。我们应该因为“需要”而非“感觉”来提供destructor,更不要因为你不确定是否需要一个destructor，于是就提供它。（取自作者原话） 2. 如果没有destructor,编译会在需要时自动合成，那如果有destructor,编译器又是怎么进行扩展的呢?一个由程序员定义的destructor被扩展的方式类似constructors被扩展的方式，但顺序相反： （1） destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设(reset) （2）如果object内含一个vptr，那么首先重设(reset)相关的virtual table （3）如果class拥有member class objects。而后者拥有destructors，那么它们会以其声明的顺序的相反顺序被调用 （4）如果有任何直接的(上一层)nonvirtual base classes拥有destructors，它们会以其声明顺序的相反顺序被调用 （5）如果有任何virtual base classes拥有destructor，而目前讨论的这个class是最尾端(most-derived)的class，那么它们会以其原来的构造顺序的相反顺序被调用。 就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实体： 一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructors。 一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。 一个object的生命结束于其destructor开始执行之时。由于每一个base class constructor都轮番被调用，所以derived object实际上变成了一个完整的object。例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象、一个Point3d对象，最后成为一个Point对象。当我们在destructor中调用member functiions时，对象的蜕变会因为vptr的重新设定而受到影响。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（四）Function语意学","slug":"深度探索c++对象模型/《深度探索c++对象模型》（四）","date":"2018-11-19T08:44:12.000Z","updated":"2019-05-17T07:45:25.935Z","comments":true,"path":"2018/11/19/深度探索c++对象模型/《深度探索c++对象模型》（四）/","link":"","permalink":"http://WenDeng.github.io/2018/11/19/深度探索c++对象模型/《深度探索c++对象模型》（四）/","excerpt":"Function是c++中的又一大重要部分， 本章的的主题是Function语意学，主要是探究编译器对class中的static member function、nonstatic member function和virtual member function所做的处理，并用实际测试分析其使用对代码效率的影响。同时也会进一步探究“指向member function”的指针和Inline function的原理和效率。","text":"Function是c++中的又一大重要部分， 本章的的主题是Function语意学，主要是探究编译器对class中的static member function、nonstatic member function和virtual member function所做的处理，并用实际测试分析其使用对代码效率的影响。同时也会进一步探究“指向member function”的指针和Inline function的原理和效率。 一、Member function的各种调用方式1. Nonstatic Member Function是怎么被调用的？C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。在c++中，member function会被被编译器转化为nonmember function，然后执行期被调用，转化过程如下： 改写函数原型，以安插一个额外的参数(this指针)到member function中，用以提供一个存取管道，使class object得以将此函数调用。 将每一个“对nonstatic data member的存取操作”改为经由this指针来存取。 将member function重新写成一个外部函数。将函数名称经过“mangling”处理，使它在程序中称为独一无二的词汇。 2. 编译器为什么要进行名称处理（name mangling）？怎么处理？继承所带来的重复变量名、函数的重载等都需要编译器能唯一识别，这时候就需要就需要进行名称处理。一般而言，member的名称前面会加上class的名称，形成独一无二的命名，有时候member function的名称也需要加上参数类型等。 3. Virtual Member Functions是如何被调用的？编译器内部会对virtual member function进行如下转换：123ptr-&gt;f(); //f()为virtual member function（*ptr-&gt;vptr[1](ptr);//内部转化结果 vptr表示编译器产生的指针，指向virtual table。 1 是virtual table slot的索引值，关联到normalize()函数。 第二个ptr表示this指针。 4. Static Member Functions有什么特性？如何被调用的？static member functions的主要特性是它没有this指针。以下的次要特性统统根源于其主要特性： 它不能够直接存取其class中的nonstatic members 它不能够被声明为const、volatile或virtual 它不需要经由class object才被调用，虽然大部分时候它是这样被调用的。 如果取一个static member function的地址，获得的将是其在内存中的位置，也就是其地址。由于static member function没有this指针，所以其地址的类型并不是一个“指向class member of function的指针”，而是一个“nonmember函数指针”。 二、Virtual Member function1. 什么是多态？C++中，多态表示以“一个public base class 的指针（或reference)，寻址出一个derived class object”。 runtime type identification(RTTI) 2. 为了能方便class指针在执行期找到对应的函数实例，就需要编译器决定是否需要给class添加额外信息，那么，到底何时才需要这份信息？答案是在必须支持某种形式之“执行期多态”的时候，要鉴定哪些classes展现多态特性，就需要额外的执行期信息。识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtual function。只要class拥有一个virtual function，它就需要这份额外的执行期信息。 3. 什么样的额外信息是我们需要存储起来的？在实现上，编译器可以做到在每一个多态对象的class object身上增加两个members: 一个字符串或数字，表示class的类型 一个指针，指向表格，表格中带有程序的virtual function的执行期地址。 4. 执行期如何找到对应的virtual function地址？执行期要做的，只是在特定的virtual table slot中激活virtual function。这些active virtual function包括： 这一class所定义的函数实例。它会改写(overriding)一个可能存在的base class virtual function函数实例。 继承自base class的函数实例。这是在derived class决定不改写virtual function时才会出现的情况 一个pure_virtual_called()函数实例，它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数(有时候会用到)。 每一个virtual function都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的virtual function的关系。执行期通过vptr和对应的slot获得对应的virtual function地址并进行调用。 在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承中，对virtual function的支持就没有那么美好了。 5. 多重继承下virtual function编译器需要做什么？当把一个从heap中配置而得的Derived对象的地址，指定给一个Base2指针时，编译器需要如下处理：12345Base2 *pbase2 = new Derived;//编译器会做的处理Derived *tmp = new Derived;Base2 *pbase2 = tmp ? tmp + sizeof(Base1) : 0;//转移以支持第二个base class 当要删除pbase2所指的对象时，指针必须被再一次调整，以求再一次指向Derived对象的起始处(推测它还指向Derived对象)。然而上述的offset加法却不能够在编译时期直接设定，因为pbase2所指的真正对象只有在执行期才能确定。 6. 多重继承下virtual function带来的负担是什么？在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的个数(因此，单一继承将不会有额外的virtual tables)。针对每一个virtual tables，Derived对象中有对应的vptr。vptrs将在constructor(s)中被设定初值。 7.Thunk技术是什么？用来做什么？offset的大小，以及把offset加到this指针上头的那一小段程序代码，必须经由编译器在某个地方插入。较有效率的解决办法是利用所谓的thunk。所谓thunk是以小段assembly代码，用来： (1) 以适当的offset值调整this指针 (2) 跳到virtual function去。Thunk技术允许virtual table slot继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。Slots中的地址可以直接指向virtual function，也可以指向一个相关的thunk(如果需要调整this指针的话)。 8.哪些情况，第二或后继的base class会影响对virtual functions的支持？有以下三种情况，第二或后继的base class会影响对virtual functions的支持。 第一种情况是，通过一个”指向第二个base class”的指针，调用derived class virtual function。例如： 123456Base2 *ptr = new Derived;//调用Derived::~Derived//ptr指向Derived对象中的Base2 subobject；//为了能够正确执行，ptr必须调整指向Derived对象的起始处。delete ptr; 第二种情况是第一种情况的变化，通过一个“指向derived class”的指针，调用第二个base class中一个继承而来的virtual function。例如： 12345Derived *pder = new Derived;//调用Base2::mumble()//在此情况下，derived class指针必须再次调整，以指向第二个base subobject。pder-&gt;mumble(); 第三种情况发生于一个语言扩充性质之下：允许一个virtual function的返回值类型有所变化，可能是base type，也可能是publicly derived type。 12345678Base2 *pb = new Derived;//调用Derived * Derived::clone()//当进行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址//于是clone()的Derived版会被调用；//它会传回一个指针，指向一个新的Derived对象，该对象的地址在被指定给pb2之前//必须先经过调整，以指向Base2 subobject。Base2 *pb2 = pb-&gt;clone(); 9.虚拟继承下virtual functions呢？当一个virtual base class从另一个virtual base class派生而来，并且两者都支持virtual functions和nonstatic data members时，编译器对于virtual base class的支持简直就像进了迷宫一样。不要在一个virtual base class中声明nonstatic data members，否则你将距离复杂的深渊越来越近。 三、函数的效率nonmemeber、static member或nonstatic member函数都被转换为完全相同形式，所以三者效率完全相同。导入virtual function之后，class constructor将获得参数以设定virtual table指针。所以每多一层继承，就会多增加一个额外的vptr设定。 constructor的额外操作在多次调用的情况下可能会拖低效率，减少常用函数中的局部对象可以在一定程度上提高效率。 四、指向Member Function的指针1.指向nonstatic member function的指针是如何工作的？取一个nonstatic data member的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。然而这个值也是不完全的。它也需要被绑定于某个class object的地址上，才能够通过它调用该函数。所有的nonstatic member functions都需要对象的地址(以参数this指出)。1234double ( Point::*pmf)(); //member function的指针名pmf = &amp;Point::y; //获得对应的member function地址(origin.*coord)(); //调用方式,origin是一个object,指针(ptr-&gt;*corrd)();(coord)(&amp;origin); //编译器内部转化 2.指向nonstatic member function的指针会带来负担吗？看情况，如果并不用于virtual function、多重继承、virtual base class等情况的话，并不会比使用一个“nonmember function指针”的成本高。但上述三种情况对于“member function指针”的类型以及调用都太过于复杂。 3.虚拟机制能在使用“指向member function的指针”的情况下运行吗？如果能，又是怎样实现的？对一个nonstatic member function取其地址，将获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，取其地址所能获得的只是其在virtual table中的索引值。1234&amp;Point::x(); //x()为非虚函数，得其内存地址 &amp;Point::z(); //z()为虚函数，得其索引值(*ptr-&gt;vptr[(int)pmf])(ptr);//pmf指向virtual函数时的调用方式 为了使pmf能支持上述两种情况，编译器必须定义函数指针使它能够(1)含有两种数值,(2)更重要的是其数值可以被区别代表内存地址还是virtual table中的索引值。 4.在多重继承下，指向Member Functions的指针如何工作？为了让指向member functions的指针也能够支持多重继承和虚拟继承，Stroustrup设计了下面一个结构体：12345678910111213struct _mptr&#123; int delta; //delta字段表示this指针的offset值 int index; //virtual table索引,不用时设为-1 union&#123; protofunc faddr; //nonvirtual member function地址 int v_offset; //v_offset字段放的是一个virtual base class的vptr位置。 &#125;;&#125;;(ptr-&gt;*pmf)();//原始调用// 编译器转换(pmf.index &lt; 0) ? ( *pmf.faddr )( ptr) : (* ptr-&gt;vptr[pmf.index](ptr)); Microsoft就供应了三种风味，以减少不必要的字段： 一个单一继承实例(其中带有vcall thunk地址或是faddr) 一个多重继承实例(其中带有faddr和delta、vcall thunk地址) 一个虚拟继承实例(其中带有四个members) 五、Inline Functions1.Inline Function有什么优点？为了处理类内部数据，有时候会用friend function进行操作。然而如果我们将这些函数声明为inline，我们就可以保持直接存取members 的那种高效率，同时也能兼顾函数的封装性，此外，也不用再用friend。 2.Inline Function什么时候被展开？编译器会决定是否将Inline Functiong按照一个expression进行展开。处理一个inline函数，有两个阶段： 分析函数定义，以决定函数的“intrinsic inline ability”。“intrinsic” (本质的，固有的)一词在这里意指“与编译器相关”，如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个static函数，并在“被编译模块”内产生对应的函数语义。 真正的inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作(evaluation)以及临时性对象的管理。同样在扩展点上，编译器将决定这个调用是否“不可为inline”。 3.Inline Function如何处理形式参数？扩展Inline function时，每一个形式参数都会被对应的实际参数取代。如果实际参数是一个常量表达式，我们可以在替换之前先完成其求值操作；后继的inline替换，就可以把常量直接“绑”上去。如果既不是常量表达式，也不是带有副作用的表达式，那么就直接替换之。例如：12345678910inline int bar()&#123; int minval; int val1 = 1024; int val2 = 2048; minval = min(val1, val2); /*(1)*/ minval = min(1024, 2048); /*(2)*/ minval = min(foo(), bar() + 1); /*(3)*/ return minval;&#125; (1) 处形参无副作用，直接展开：1234567minval = val1 &lt; val2 ? val1 : val2; ``` (2) 处那一行直接拥抱常量：``` minval = 1024; ``` (3) 处那一行则引发参数的副作用，它需要导入一个临时对象，以避免重复求值: int t1;int t2;minval = (t1 = foo()), (t2 = bar() + 1),t1 &lt; t2 ? t1 : t2;123#### 4.Inline Function如何处理局部变量？一般而言，inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。如果inline函数以单一表达式扩展多次，则每次扩展都需要自己的一组局部变量。如果inline函数以分离的多个式子被扩展多次，那么只需一组局部变量，就可以重复使用(译注：因为它们被放在一个封闭区段中，有自己的scope) minval=min(val1,val2)+min(foo(),foo()+1);//这就是单一表达式，进行两次扩展，多出两组变量` 5.Inline Function的缺点。一个inline函数如果被调用太多次，会产生大量的扩展码，使程序大小暴涨。参数带有副作用或者以一个单一表达式做多重调用、或者其本身有多个局部变量，都会产生大量局部变量，当然，编译器有可能帮你处理，也可能不会。 对于既要安全又要效率的程序，inline函数提供了一个强有力的工具。然而，与non-inline函数比起来，他们需要更加小心地处理。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（三）Data语意学","slug":"深度探索c++对象模型/《深度探索c++对象模型》（三）","date":"2018-11-18T08:44:12.000Z","updated":"2019-05-17T07:44:49.927Z","comments":true,"path":"2018/11/18/深度探索c++对象模型/《深度探索c++对象模型》（三）/","link":"","permalink":"http://WenDeng.github.io/2018/11/18/深度探索c++对象模型/《深度探索c++对象模型》（三）/","excerpt":"本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。","text":"本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。 前述 本章的的主题是Data语意学，主要是探究编译器对class中的Data member的绑定、布局和存储等操作，最后探究Data member存取和多种继承方式之间的效率关系，以及指向Data member的指针的效率问题。 参考书籍及链接：《深度探索c++对象模型》 0、本章基础1. 空类对象的大小是多少？1class X &#123; &#125;;//空类 对于空类，它有一个隐藏的1byte大小，那个被编译器安插进去的一个char,这使得这一class的两个objects得以在内存中配置独一无二的地址。 2. class object的size会受到哪些因素的影响？会影响class object的size的因素有如下三个，编译器： 语言本身所造成的额外负担：当语言支持virtual base classes时，就会导致一些额外负担。需要一个指针，它或者指向virtual base class subobject,或者指向一个相关的表格，表格用于存储subobject地址或偏移值。 编译器对于特殊情况所提供的优化处理：Virtual base class subobject的1 byte大小也会出现在derived class上。 Alignment（边界对齐）的限制：在大部分的机器上，聚合的结构体大小会受到alignment的限制，使他们能够更有效率地在内存中被存取。比如32机器字上就是4的整数倍。 3. 各种类型data member的存放。nonstatic直接放在class object之中。static data member放置在程序的一个global data segment中，不会影响个别class object的大小。无论class产生多少个object,甚至是0个，其static data members永远也只存在一份实例。但是一个template classs的static data members的行为稍有不同。 一、Data member的绑定1. member function取用的是global还是local data member?当member funtion取用Data时，优先考虑member data,人们称这种情况为“member rewriting rule”，意思是对于member functions本身的分析，会直到整个class的声明都出现了才开始。在一个inline member function躯体之内的一个data member绑定操作，会在整个class声明之后才发生。 以前人们提倡两种程序设计风格，即将所有的data members放在class声明起始处，或者把所有的inline function都放在class声明之外。就是为解决绑定问题，但这种情况在c++ 2.0之后已经解决了。 2. member function的argument list的情况又是怎么样的呢?与取用data member不同的是，argument list中的名称还是会在它们第一次 遭遇时被适当地决议（resolved）完成。123456789101112typedef int length;class Point3d&#123;public: void mumble(length val) &#123; _val=val;&#125; //length被决议为global length mumble() &#123;return val;&#125; // ...private: typedef float length;//这样的声明将使先前的参考操作不合法 length _val; // ...&#125;; 虽然编译器能处理，但还是提倡一种防御性程序风格：即总是把“nested（嵌套的） type声明”放在class的起始处。 二、Data member的布局1. Data member是怎样被放置的？关于data member的布局，记住以下三点： nonstatic data members在class object中的排列顺序和其被声明的顺序一样，任何中间介入的static data members都不会被放进对象布局之中。 C++ standard允许编译器将多个access sections(也就是private、public、protected等区段)之中的data members整体自由排列，不必在乎他们的出现在class中的声明顺序（连续的两个privata也算两个section）。 编译器还可能会合成一些内部使用的data members，以支持整个对象模型，vptr就是这样的东西，当前所有的编译器都把它安插在每一个“内含virtual function之class”的object内。 三、Data member的存取1. 经由一个class object和一个指针存取data member，有重大差异吗？答案是显然的，这跟data member的类型和class的继承等都有关系，分如下两种情况讨论： data member 为 staticstatic data members会被编译器提出于class之外，并被视为一个global变量(但只在class生命范围内可见)。每一个static data member只有一个实例，存放在程序的data segment之中，通过一个指针和通过一个对象来存取data member都是一样的。 若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其class member的指针，因为static member并不内含在一个class object之中。 如果有两个classes，每一个都声明了一个同名的static member，编译器就会暗中对每一个static data member编码(对于这种手法有个很美的名称：name-mangling)，以获得一个独一无的程序识别代码。 data member 为 nonstaticNonstatic data members直接存放在每一个class object之中。只有经过class object才能存取它们（implicit 存取如this指针）。欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置(offset)。 每一个nonstatic data member的偏移位置(offset)在编译时期即可获知，甚至如果member属于一个base class subobject(派生自单一或多重继承串链)也是一样的。因此，存取一个nonstatic data member，其效率和存取一个C struct member或一个nonderived class的member是一样的。 但是如果该data member是一个virtual base class 的member,那么通过指针的存取速度会稍慢一点。（指针的真正class type 只有在执行器才真正确定）。 四、“继承”与Data Member C++ standard未强制指定derived class members和base class members的排列顺序，理论上编译器可以自由安排之。在大部分编译器上头，base class members总是先出现，但属于virtual base class的除外。“继承”会对Data Member的布局有什么影响？接下来分四种情况进行讨论。 1. 第一种情况：只要继承不要多态。这种情况不会存储时间上的额外负担，由于base class和derived class的objects都是从相同的地址开始，其差异只在于derived object 比较大，用以容纳自建的nonstatic data members，把一个derived class object指定给base class 的指针或引用，并不需要编译器去调停或修改地址，可以提供了最佳执行效率。 2. 第二种情况：加上多态。加上virtual function接口后，弹性增加了，但也同时增加了空间和存取时间上的额外负担，如何取舍，视多态程序所带来的利益。可能带来的额外负担如下： 导入一个和virtual table ，用来存储它所声明的每一个virtual functions的地址。再加上一两个slots(type_info)。 在每一个class object中导入一个vptr,提供执行期的链接，使每一个object能够找到相应的virtual table。 加强constructor，使它能够为vptr设定初始值，让它指向class所对应的virtual table。 加强destructor，使它能够消抹“指向class 相关virtual table”的vptr。 3. 第三种情况：多重继承。对于单一继承，如果没有virtual function，那么编译器就不需要做其他工作;但如果base class没有virtual function而derived class有，并且vptr放在object首部，那么当把一个derived object转换为其base object时，就需要编译器对vptr进行调整。在既是多重继承又是虚拟继承的情况下，编译器的需要做的会更多。对一个多重派生对象，将其地址指定给“最左端(也就是第一个)base class的指针”，情况将和单一继承时相同，因为二者都指向相同的起始地址。至于第二个或后继的base class的地址指定操作，则需要将地址修改为：加上(或减去)介于中间的base class subobjects大小。比较需要注意的是，如果在取drived class object的地址时进行偏移计算时，若其为指针，就需要判断其是否为0，若为0则基类object的地址也应为0。当然，这些都是编译器的工作，我们需要了解，但不需要自己去实现。 如果要存取第二个(或后继)base class中的一个data member会是怎样的情况？需要付出额外的成本吗？ 不，members的位置在编译期就固定了，因此，存取members只是一个简单的offset运算，就像单一继承一样简单，不管是经由一个指针，一个reference或是一个object来存取。 4. 第四种情况：虚拟继承。虚拟继承的出现是为了避免多个相同base class subobject的出现，将其只保留一份，从而减少空间浪费。class如果含有一个或多个virtual base class subobjects将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，总是能有固定的offset，这部分可以被直接存取，至于共享部分，所表现的就是virtual base class subobject ，这个部分数据，其位置因为每次派生操作而有变化，所以只能间接存取。 一般而言，virtual base class最有效的一种运用形式就是：一个抽象的virtual base class，没有任何data members。 5、对象成员的效率程序员如果只关心起程序效率，应该实际测试，不能光凭推论、常识判断或假设。参考书籍作者所做的测试表明，虚拟继承所造成确实会严重影响data member的存取效率。 五、指向Data members的指针(Pointer to Data Members)1. 如果获取Data member的偏移值？偏移值应该为多少？通过如（&amp;Point3d::z）这样的操作可以获得data member的偏移值。实际测试表明所获得的offset比预想大1，这是为什么？实际上这样做的目的是为了区分一个“没有指向任何data member”的指针，和一个指向“第一个data member”的指针的情况。比如：12345678float Point3d::*p1 = 0;//“没有指向任何data member”的指针float Point3d::*p2 = &amp;Point3d::x;//指向“第一个data member”的指针if(p1 == p2) //如何区分?&#123; cout &lt;&lt; \"p1 &amp; p2 contain the same value --\" ; cout &lt;&lt; \" they must address the same member!\" &lt;&lt; endl;&#125; 因此，不论编译器或使用者都必须记住，在真正使用该值以指出一个member之前，请先减掉1。 2.“指向Member的指针”对数据的存取有什么影响？无继承时，指向member的指针对数据的存取操作，首先需要计算offset-1,其次具体的object需要用offset计算地址，会极大地降低效率，但目前的一些编译器提供了对应的优化，可以使其像直接通过对象取值一下快速。有继承时，data member是直接放在class object中的，理论上不会影响代码的效率，但继承的使用会妨碍优化的效果。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（二）构造函数语意学","slug":"深度探索c++对象模型/《深度探索c++对象模型》（二）","date":"2018-11-17T08:44:12.000Z","updated":"2019-05-17T07:44:57.900Z","comments":true,"path":"2018/11/17/深度探索c++对象模型/《深度探索c++对象模型》（二）/","link":"","permalink":"http://WenDeng.github.io/2018/11/17/深度探索c++对象模型/《深度探索c++对象模型》（二）/","excerpt":"本章的的主题是构造函数语意学，主要是讨论constructor如何工作，以及它什么时候被合成，同时挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。","text":"本章的的主题是构造函数语意学，主要是讨论constructor如何工作，以及它什么时候被合成，同时挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。 一、Default Constructor的构造操作1. 什么时候才会合成一个default construct呢？ 答案是当编译器需要的时候，default constructor会被合成出来，只执行编译器所需要的任务。另外要注意程序的需要和编译器的需要之间的区别，如果程序有需要，那是程序员的责任，就需要自己实现constructor。 对于class X，如果没有任何user-declared constructor，那么会有一个default constructor被隐式(implicitly)声明出来…一个被隐式声明出来的default constructor将是一个trivial(浅薄而无能，没啥用的)constructor… 一个nontrivial default constructor在ARM的术语中就是编译器需要的那种，必要的话由编译器合成出来。下面4小节分别讨论nontrivial default constructor的4种情况 2. 几种对象构建时的区别。 Global objects的内存保证会在程序启动的时候被清0。Local objects配置于程序的堆栈中，heap objects配置于自由空间，都不一定会被清零，它们的内容将是内存上次被使用的遗迹。 3. 第一种情况：“带有Default Constructor”的member class object如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么这个class的implicit default constructor就是“nontrivial”，编译器为该class合成出一个default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。 4. 多成员对象的情况。编译器的处理是：如果一个class A内含一个或者一个以上member class objects，那么class A的每一个constructor必须调用每一个member classes 的default constructor。编译器会扩张已存在的constructors,在其中安插一些代码，使得user code在被执行之前，先调用必要的default constructors。调用顺序与member objects在class中的声明次序一致。 5. 第二种情况：“带有Default constructor”的base class。如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。对于一个后继派生的class而言，这个合成的constructor和一个“被显式提供的default constructor”并没有差异。 注意一点，如果有constructor,但没有default constructor,那就会对每一个constructors进行扩充。如果亦存在Member Class Object，那些default constructor也会在base class constructor都被调用之后调用。 6. 第三种情况：“带有一个Virtual Funtion”的class。如果class声明(或继承)一个virtual function，编译器也需要合成出default constructor或扩充construtor。下面两个扩张行动会在编译期间发生： 一个virtual function table(在cfront中被称为vtbl)会被编译期产生出来，内放class的virtual functions地址。 在每一个class object中，一个额外的pointer member(也就是vptr)会被编译期合成出来，内含相关之class vtbl的地址。 编译器会为每一个含有virtual function的class objects的vptr进行适当的初始化，以放置适当的virtual table地址。 7. 第四种情况：“带有一个virtual base class”的class。如果class派生自一个继承串链，其中有一个或更多的virtual base classes编译器也需要合成出default constructor或扩充construtor。其目的在于必须使 virtual base class 在其每一个derived class object中的位置能够在执行期准备妥当。对于class所定义的每一个constructor。编译器都会安插那些“允许每一个virtual base class 的执行期存取操作”的代码。 8. 总结。除以上四种情况外，在没有声明constructor时就默认其是无用的， 其default constructor也就不会被合成出来的。在合成的default constructor中，只有base class subobjects和member class objects会被初始化。所有其他的nonstatic data member ，如整数，整数指针，整数数组等是不会被初始化的，这些初始化操作对程序是必须的，但对编译器则并非需要的。C++新手一般有两个误解： 任何class 如果没有定义default constructor ，就会被合成出来一个。 编译器合成出来的default constructor 会明确设定 class 内每一个data member的默认值。 二、Copy Constructor的构造操作1. 哪些情况需要有copy constructor？有三种情况，会以一个object的内容作为另一class object的初值，即需要有 copy constructor。 把一个object直接赋值给另一个object进行初值。 当object被当做参数交给某个函数 当函数返回一个class object。 一个class object可用两种方式复制得到，一种是被初始化，另一种是赋值。从概念上看，这两种操作分别是以copy constructor和copy assignment operator完成的。Default constructors和copy constructor在必要的时候才由编译器 产生，这里的“必要”意指当class不展现bitwise copy sematics时。 2. Default Memberwise Initialization当class object以“相同的另一个object作为初值是，其内部是以所谓的default memberwise initialization方式完成的。也就是把每一个内建的或派生的data member（例如一个数组或指针）的值，从某个object拷贝一份到另一个object上，但不拷贝其具体内容。例如只拷贝指针地址，不拷贝一份新的指针指向的对象，这也就是浅拷贝，不过它并不会拷贝其中member class object，而是以递归的方式实行memberwise initialization。 3. 递归的memberwise initialization是如何实现的呢？答案就是Bitwise Copy Semantics和default copy constructor。如果class展现了Bitwise Copy Semantics，则使用bitwise copy（bitwise copy semantics编译器生成的伪代码是memcpy函数），否则编译器会生成default copy constructor。 4. Memberwise copy(深拷贝)与Bitwise copy(浅拷贝)的区别Memberwise copy: 在初始化一个对象期间,基类的构造函数被调用,成员变量被调用,如果它们有构造函数的时候,它们的构造函数被调用,这个过程是一个递归的过程。Bitwise copy: 原内存拷贝。例子,给定一个对象object,它的类型是class Base。对象object占用10字节的内存,地址从0x0到0x9.如果还有一个对象objectTwo,类型也是class Base。那么执行objectTwo = object;如果使用Bitwise拷贝语义,那么将会拷贝从0x0到0x9的数据到objectTwo的内存地址，也就是说Bitwise是字节到字节的拷贝。 对于默认的拷贝构造函数不会使用深拷贝,它只是使用浅拷贝。这意味着类的所有的成员是一层深度的拷贝而已。如果你的类或结构体成员中只是包含基本的数据类型例如int, float, char,那么Memberwise copy与Bitwise copy基本是相同的。但如果类中有指针存在,那么你可能会遇到问题。例如下面的例子:12345678910111213141516class A&#123; int m; double d; char *Str;&#125;;如果你创建两个这样的类对象,class A a, b;并且你给a赋值, a.m = 6; a.d = 10.123; a.Str = new char[10]; astrcpy(a.Str, \"test\");//这里是浅拷贝 如果执行b = a;那么会把对象a的每一个成员的值赋值给b的每个成员。 b.m = a.m; b.d = a.d; b.Str = a.Str;//现在对象a和b的成员Str都执向相同的内存,删除任一个内存都会析放另一个对象的内存。 所以你需要深拷贝,它不是拷贝的内存地址而是拷贝内存地址的内容。一个默认的拷贝构造函数经常执行浅拷贝,只有拥有自己的拷贝函数才可以实现深拷贝。 5. 什么时候一个class不展现出“bitwise copy semantics”呢？有四种情况： 当class内含有一个member class object，而这个member class内有一个默认的copy构造函数(不论是class设计者明确声明，或者被编译器合成) 当class继承自一个base class，而base class有copy构造函数(不论显式声明或是被编译器合成] 当一个类声明了一个或多个virtual 函数 当class派生自一个继承串链，其中一个或者多个virtual base class 6. 重新设定Virtual Table的指针（virtual funtion的情况）当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作也必须要保证安全（非pointer和reference)。也就是说，合成出来的基类构造函数会显式设定object的vptr指向基类对应的virtual table，而不是直接将右手边的class object中将其vptr现值拷贝过来。 7. 如何处理virtual base class subobject的情况？virtual base class的存在需要特别处理。一个class object如果以另一个object作为初值，而后者有一个virtual base class subobject，那么也会使“bitwise copy semantics”失效。这时需要合成一个copy constructor,从而安插一些代码以设定virtualbase class pointer/offset的初值，对每一个members执行必要的memberwise初始化操作，以及执行其他的内存相关工作。 三、程序转化语意学(Program Transformation Semantics)1. class object的显式初始化操作。初始化object时，必要的程序转化有以下两个阶段： 重写每一个定义，其中的初始化操作会被剥除，在c++中，“定义”指占用内存的行为。 class的copy constructor调用操作会被安插进去。 2. 参数的初始化所做的程序转换。C++ Standard说，把一个class object当做参数传给一个函数(或是作为一个函数的返回值)，相当于以下形式的初始化操作:123456789X xx = arg;//其中xx代表形式参数(或返回值)而arg代表真正的参数值//因此，若已知如下函数：void foo(X xo); //转换的结果为：X xx;//xo以memberwise的方式将xx当作初值...foo(xx); 有一种策略是导入所谓的临时性object，并调用copy constructor将它初始化，然后将此临时性object交给函数，临时性object会在函数结束处被析构。 3. 返回值的初始化所做的程序转换。函数bar()的返回值为一个对象，那该怎么把局部对象xx拷贝过来？ Stroustrup在cfront中的解决办法是一个双阶段的转化： 首先加上一个额外参数，其类型是class object的一个reference，这个参数将被用来放置被“拷贝建构”而得的返回值。 在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。函数也对应变为void类型。 4. 在编译器层面所做的优化。编译器会以result参数取代name return val。这样的编译器优化操作，有时被称为Named Return Value(NRV)优化。NRV优化如今被视为是标准C++编译器的一个义不容辞的优化操作。NRV需要一定的条件，即对应的类要有copy constructor。一般而言，面对“以一个class object作为另一个class object的初值”的情形，语言允许编译器有大量的自由发挥空间。其优点当然是导致机器码产生时有明显的效率提升。缺点则是你不能安全地规划你的copy constructor的副作用，必须视其执行而定。 NRV与返回值初始化的区别在于：NRV中不产生local object，直接以_result带入其中进行各种处理，减少调用copy constructor。而返回值初始化则是在最后用copy constructor将local object的值拷贝给_result, 中间不处理_result。一个是优化，一个是程序转换。 5. 那Copy Constructor要还是不要？copy constructor的应用，迫使编译器多多少少对你的程序代码做部分优化。尤其当一个函数以传值(by value)的方式传回一个class object，而该class有一个copy constructor(不论是明确定义出来的，或是合成的)时。这将导致深奥的程序转化——不论在函数的定义或使用上，此外编译器也将copy constructor的调用操作优化，以一个额外的第一参数(数值被直接存放在其中)取代NRV。 如果编译器能自动为你实施了最好的行为,那就没有必要实现一个自己的copy constructor。 如果class需要大量的memberwise初始化操作，例如以传值的方式传回object，此时提供一个explicit inline copy constructor就是非常合理的（在有NRV的前提下）。 四、成员们的初始化队伍(Memeber Initialization List)1. 在下列情况下，为了让你的程序能够顺利编译，你必须使用member initialization list: 当初始化一个reference member时 当初始化一个const member时 当调用一个base class的constructor，而它拥有一组参数时 当调用一个member class的constructor，而它拥有一组参数时 2.member initialization list中到底会发生什么事情？编译器会一一操作initialization list，以适当顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。initialization list中的项目顺序是由class中的members声明顺序决定的，不是由initialization list中的排列顺序决定的。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"《深度探索c++对象模型》（一）关于对象","slug":"深度探索c++对象模型/《深度探索c++对象模型》（一）","date":"2018-11-16T08:44:12.000Z","updated":"2019-05-17T07:44:30.901Z","comments":true,"path":"2018/11/16/深度探索c++对象模型/《深度探索c++对象模型》（一）/","link":"","permalink":"http://WenDeng.github.io/2018/11/16/深度探索c++对象模型/《深度探索c++对象模型》（一）/","excerpt":"看完《深度探索c++对象模型》，心中对c++编译器在编译期间所做的处理有了更深入的认识，我想，除了对编译器本身有深入认识的作者之外，应该很少有人对c++的对象模型有这么深的认识。能接触了这本书，是我们的幸运，是作者让我们有机会能一窥其貌，感谢作者。 其实第一遍读这本书，我的收获还不算多，这可能是我对c++的使用还不够多的缘故，但通过这本书，我以后使用c++的时候，就会心里有更多的底气，也会有更多需要注意的地方，在经过更多的实践之后，我一定还会回来拜读这本书的。 现在，我想就本书所学到的的知识做一些总结。","text":"看完《深度探索c++对象模型》，心中对c++编译器在编译期间所做的处理有了更深入的认识，我想，除了对编译器本身有深入认识的作者之外，应该很少有人对c++的对象模型有这么深的认识。能接触了这本书，是我们的幸运，是作者让我们有机会能一窥其貌，感谢作者。 其实第一遍读这本书，我的收获还不算多，这可能是我对c++的使用还不够多的缘故，但通过这本书，我以后使用c++的时候，就会心里有更多的底气，也会有更多需要注意的地方，在经过更多的实践之后，我一定还会回来拜读这本书的。 现在，我想就本书所学到的的知识做一些总结。 一、关于对象1. C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？答案是并没有增加布局成本。就像C struct一样，memeber functions虽然含在class的声明之内，却不出现在object中。每一个non-inline member function只会诞生一个函数实体。至于每一个“拥有零个或一个定义的” inline function则会在其每一个使用者(模块)身上产生一个函数实体。 2. C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括： virtual funciton机制，用以支持一个有效率的“执行期绑定” virtual base class，用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体” 二、C++ 对象模式(The C++ Object Model)1. 在C++中，有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。2. C++对象模型中，nonstatic data members被配置于每一个class object之内。static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual function则以两个步骤支持之： 每个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为virtual table(vtbl) 每一个class object被安插一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object(用以支持runtime type identification, RTTI)也经由virtual table被指出来，通常放在表格的第一个slot处。 这个模型的主要优点在于它的空间和存取时间的效率。主要缺点是：如果应用程序代码未曾改变，但所用到的class objects的nonstatic data members有所修改(有可能是增加、移除或更改)，那么应用程序代码同样得重新编译。 3.继承关系可以指定为虚拟(virtual，也就是共享的意思)：在虚拟继承的情况下，base class不管在继承链中被派生(derived)多少次，永远只会存在一个实例(称为subobject)。 三、关键词带来的差异1.什么时候一个人应该在c++程序中以struct取代class?答案之一是当他让人感觉比较好的时候。单独来看，关键词本身并不提供任何差异，c++编译器对二者都提供了相同支持，我们可以认为支持struct只是为了方便将c程序迁移到c++中。 2.那为什么我们要引入class关键词？这是因为引入的不只是class这个关键词，更多的是它所支持的封装和继承的哲学。 3.怎么在c++中用好struct？将struct和class组合起来，组合，而非继承，才是把c和c++结合在一起的唯一可行的方法。另外，当你要传递“一个复杂的class object的全部或部分”到某个c函数去时，struct声明可以将数据封装起来，并保证拥有与c兼容的空间布局。 四、对象的差异1. C++程序设计模型直接支持三种程序设计典范（programming paradigms）： 程序模型：数据和函数分开。 抽象数据类型模型：数据和函数一起封装以来提供。 面向对象模型：可通过一个抽象的base class封装起来，用以提供共同接口，需要付出的就是额外的间接性。 虽然你可以直接或间接处理继承体系中的一个base class object,但只有通过pointer或reference的间接处理，才支持OO程序设计所需的多态性质。c++通过class的pointers和reference来支持多态，这种程序设计风格就称为面向对象 1234Liberary_materials thing1;//基类Book book;//派生类thing1=book;thing1.check_in();//这种情况下，调用的是基类的check_in() 12Liberary_materials &amp;thing2=bookthing2.check_in();//这种情况下调用的才是book的check_in() 2. C++以下列方法支持多态： 经由一组隐式的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针1shape *ps=new circle(); 经由virtual function机制1ps-&gt;rotate(); 经由dynamic_cast和typeid运算符1if(circle *pc=dynamic_cast&lt;circle *&gt;(ps))... 多态的主要用途是经由一个共同的接口来影响类型的封装，这个接口通常被定义在一个抽象的base class中。这个共享接口是以virtual function机制引发的，它可以在执行期根据object的真正类型解析出到底是哪一个函数实体被调用。 3. 需要多少内存才能表现一个class object? 其nonstatic data members的总和大小 加上任何由于aliginment的需求而填补上去的空间(可能存在于members之间，也可能存在于集合体边界),aliginement就是将数值调整到某数的倍数，如在32位的计算机上为4。 加上为了支持virtual而由内部产生的任何额外负担 4. 一个指针(引用)，不管它指向哪一种数据结构，指针本身所需的内存大小是固定的(一个机器字)。例如：一个指向ZooAnimal的指针是如何地与一个指向整数得指针或一个指向template Array的指针有所不同的呢？123ZooAnimal *px;int *pi;Array&lt;string&gt; *pta; 以内存需求的观点来说，没有什么不同！它们三个都需要足够的内存来放置一个机器地址(通常是个word)。“指向不同类型的各指针”间的差异，既不在其指针表示法不同，也不在其内容(代表一个地址)不同，而是在其所寻址出来的object类型不同，也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小。 5.转型(cast)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存大大小和其内容”的解释方式。 如一个类型为void *的指针只能够持有一个地址，但不能 通过它操作所指object。 6.一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）二者都指向基类对象的第一个byte,其间的差别是，派生类指针涵盖的地址包含整个派生类对象，而一个基类指针所涵盖的地址只包含派生类对象的基类子对象部分。 但基类指针可以通过virtual机制访问派生类对象的函数。 7.当一个base class object被直接初始化为(或被指定为)一个derived class object时。derived object就会被切割(sliced)以塞入较小的base type内存中，derived type将没有留下任何蛛丝马迹。多态于是不再呈现，而一个严格的编译器可以在编译器解析一个“通过此object而触发的virtual function调用操作”，因而回避virtual机制。如果virtual function被定义为inline，则更有效率上的大收获。 8.C++也支持具体的ADT程序风格，如今被称为object-based(OB)。一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象构建起来时不需要设置virtual机制。空间紧凑是因为每一个class object不需要负担传统上为了支持virtual机制儿需要的额外负荷。不过，OB设计比较没有弹性。在弹性（OO）和（OB）之间常常存在着取舍。一个人能够有效选择其一之前，必须先清楚了解两者的行为和应用领域的需求。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/tags/C-基础/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"C++基础","slug":"C-基础","permalink":"http://WenDeng.github.io/categories/C-基础/"}]},{"title":"git中的仓库崩溃后的如何恢复","slug":"项目工具/git中的仓库崩溃后的如何恢复","date":"2018-06-16T10:44:12.000Z","updated":"2019-05-17T07:38:26.799Z","comments":true,"path":"2018/06/16/项目工具/git中的仓库崩溃后的如何恢复/","link":"","permalink":"http://WenDeng.github.io/2018/06/16/项目工具/git中的仓库崩溃后的如何恢复/","excerpt":"","text":"解决git仓库崩溃问题 不知道是不是虚拟机的问题，最近修改代码后git仓库总崩溃，导致的结果就是很多时候自己刚修改的代码不得不放弃，最近找到一种比较好的解决方式，链接如下：https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty 1.git仓库崩溃表现1234dengwen@ubuntu:~/project_DW/selog$ git statuserror: object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is emptyerror: object file .git/objects/a9/761932a220991b0490c2715f218f814d39b876 is emptyfatal: loose object a9761932a220991b0490c2715f218f814d39b876 (stored in .git/objects/a9/761932a220991b0490c2715f218f814d39b876) is corrupt 2.常规解决方案git仓库崩溃后，常规的解决方案是在其他目录git clone之前版本的项目，然后将当前版本的项目拷贝过去进行覆盖，再进行提交，但是这样做的结果就是可能会丢失部分git commit信息，除此之外基本没什么问题。 3.推荐方法这种方法的好处在于可以恢复git log信息，同时也不用重新clone项目、切换分支、替换等操作，相对来说，git管理的完整度和效率会更高，具体步骤如下： （1）删除全部空文件: 注意在.git目录下进行 1234567dengwen@ubuntu:~/project_DW/selog/.git$ find . -type f -empty -delete -print./objects/0d/e32d3b8d0399414c0c8fc47a56069e9821615a./objects/14/540f9dda3c30044e2dbe4629d22c715145f212./objects/19/b98c74bc6c2e372887af410301a0a80495725c./objects/55/14f9022e0e39a29d0e25cdf15cecac1f2f479c./objects/84/0103bdd9538473baab19520eda11b88b40c953./FETCH_HEAD （2）获取最后两条reflog：注意自己要恢复的分支，此处为develop 12dengwen@ubuntu:~/project_DW/selog$ tail -n 2 .git/logs/refs/heads/develop41867ca4ab8d60979e804ee7f4640a2e9231d96b f815821a9c4e4833be898dace675916f3cad0124 dengwen &lt;15680482464@163.com&gt; 1539335482 +0800 commit: add manage （3）恢复对应的日志由上一步我们知道最新的日志节点为f815821a9c4e4833be898dace675916f3cad0124，我们可以查看这个节点的信息： 123456dengwen@ubuntu:~/project_DW/selog$ git show f815821a9c4e4833be898dace675916f3cad0124commit f815821a9c4e4833be898dace675916f3cad0124Author: dengwen &lt;15680482464@163.com&gt;Date: Fri Oct 12 17:11:22 2018 +0800 add manage 接下来要做的就是恢复日志,同样，需要注意分支和日志节点。1dengwen@ubuntu:~/project_DW/selog$ git update-ref develop f815821a9c4e4833be898dace675916f3cad0124 （4）提交最新的git log执行上述步骤后，用git status可以查看仓库的状态了，也就意味着git仓库恢复成功了。","categories":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}],"tags":[{"name":"git使用","slug":"git使用","permalink":"http://WenDeng.github.io/tags/git使用/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}]},{"title":"Git 中的SSH key的生成","slug":"项目工具/git之生成ssh key","date":"2018-06-16T09:24:12.000Z","updated":"2019-05-17T07:43:24.860Z","comments":true,"path":"2018/06/16/项目工具/git之生成ssh key/","link":"","permalink":"http://WenDeng.github.io/2018/06/16/项目工具/git之生成ssh key/","excerpt":"","text":"Git 中的SSH key的生成1.1&emsp;安装git：&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： http://msysgit.github.com/ 1.2&emsp;查看是否经有SSH key：1cat ~/.ssh/id_rsa.pub //git bash中输入这个命令 1.3&emsp;生成SSH key：1ssh-keygen -t rsa -C \"your.email@example.com\" -b 4096 //git bash中输入这个命令，修改对应的邮箱 如果已经存在SSH key,则直接复制即可，否则需要重新生成。 生成SSH key时需要设置对应的文件存放路径和密码，为了方便，直接回车默认即可。 1.3&emsp;查看生成的SSH key，复制到git中即可： 123xclip -sel clip &lt; ~/.ssh/id_rsa.pub //GNU/Linux (requires the xclip package)cat ~/.ssh/id_rsa.pub | clip //Git Bash on Windows / Windows PowerShelltype %userprofile%\\.ssh\\id_rsa.pub | clip //Windows Command Line","categories":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}],"tags":[{"name":"git使用","slug":"git使用","permalink":"http://WenDeng.github.io/tags/git使用/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}]},{"title":"Git基本命令详解","slug":"项目工具/git基本命令详解","date":"2018-06-16T08:44:12.000Z","updated":"2019-05-17T07:43:32.254Z","comments":true,"path":"2018/06/16/项目工具/git基本命令详解/","link":"","permalink":"http://WenDeng.github.io/2018/06/16/项目工具/git基本命令详解/","excerpt":"","text":"最近刚开始学习git，总结一下git的各个命令，方便以后查阅。学习环境：windows10 参考链接： Pro Git（中文版）http://git.oschina.net/progit/ 沉浸式学 Githttp://igit.linuxtoy.org/contents.html 1. git的安装及初始配置1.1 git 安装&emsp; &emsp;windows下安装git很方便，github上提供了安装包，链接： http://msysgit.github.com/ 1.2 git 初始化配置&emsp; &emsp; 1.2.1&emsp;配置用户名和户邮箱：12 git config --global user.name \"deng wen\" git config --global user.email 156XXXXXXX@163.com &emsp; &emsp; 1.2.2&emsp;查看初始配置：1git config --list 2.git的基础命令2.1 新建仓库&emsp; Git 新建项目仓库的方法有两种。分别为：&emsp; &emsp; 2.1.1&emsp; 第一种：在现存的目录下，用如下命令得到一个.git仓库目录，资源对应添加到其中：1git init &emsp; &emsp; 2.1.2&emsp; 第二种：从已有的 Git 仓库克隆出一个新的镜像仓库来。[URL] 如：http://uestclab307.kmdns.net:808/dengwen/SAIC_SecMonitor.git，mygitname可省略：1git clone [URL] mygitname 2.2 文件基本处理&emsp; &emsp; 2.2.1&emsp;检查当前文件状态：123 git status``` &amp;emsp; &amp;emsp; 2.2.2&amp;emsp; 将新文件或更新文件加入跟踪： git add filename git add —A //将所有新文件一次加入跟踪 git checkout -- filename // 对所做的更改进行忽略 git reset HEAD filename //撤销加入跟踪的文件 1&amp;emsp; &amp;emsp; 2.2.3&amp;emsp; 文件提交： git commit —m &quot;your comment&quot; //-m表示注释 git commit --amend //撤销刚做的提交 git commit —a //所有跟踪文件一次提交 1&amp;emsp; &amp;emsp; 2.2.4&amp;emsp; 删除文件： git rm --cached filename //跟踪目录删除、本地不删除 git rm -f filename //跟踪目录、本地目录皆删除： 1&amp;emsp; &amp;emsp; 2.2.5&amp;emsp; 在仓库中移动文件： git mv file_from file_to 1&amp;emsp; &amp;emsp; 2.2.6&amp;emsp; 查看提交历史，- -pretty按固定格式显示,--graph 选项用 ASCII 字符串形象地展示了每个提交所在的分支及其分化衍合情况： git log git log --pretty=format:&quot;%h - %an, %ar : %s&quot; git log --pretty=format:&quot;%h %s&quot; --graph 12345678910111213141516171819&gt;**选项 说明** %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 ### **2.3 远程仓库的使用** &amp;emsp; &amp;emsp; 2.3.1&amp;emsp; 查看当前的远程库,-v 选项显示对应的克隆地址： git remote //查看当前仓库对应的远程库,一般为origin git remote -v //查看当前仓库对应的远程库及相应地址 1&amp;emsp; &amp;emsp; 2.3.2&amp;emsp;远程仓库处理： git remote add yourname [url] //yourname是你的本地仓库名，相当于赋值yourname为URL git fetch yourname //从远程仓库抓取数据到本地，到如果要查看需要合并到当前分支 git remote show [remote-name] //查看远程仓库信息，如显示了有哪些远端分支还没有同步到本地等 git remote rename old-name new-name //重命名 git remote rm paul //删除 12### **2.4 标签** &amp;emsp; &amp;emsp; 2.4.1&amp;emsp; 新建标签： git tag //查看已有标签 git tag -a yourtagname -m &apos;your comment&apos; //打标签 git show yourtagname //查看版本信息 git tag -a yourtagname hist //后期加标签,hist表校验和 1&amp;emsp; &amp;emsp; 2.4.2&amp;emsp; 标签远程共享： git push origin yourtagname //推送标签 git push origin --tags //推送所有标签 12### **2.5 Git 命令别名** &amp;emsp; &amp;emsp; 2.5.1&amp;emsp; 简写git命令： git config --global alias.shortname gitcommandname eg: git config --global alias.unstage &apos;reset HEAD&apos; git unstage filename //撤销加入跟踪的文件 1234## **3.git分支处理**### **3.1 Git 查看分支** &amp;emsp; &amp;emsp; 3.1.1&amp;emsp; 查看分支： git branch git branch -a //查看所有分支，包括远程分支 git branch -v //查看分支最后一个提交对象的信息 git branch --merged/--no--merge //查看已经（或尚未）合并的分支 12### **3.2 Git 分支切换、合并和删除** &amp;emsp; &amp;emsp; 3.2.1&amp;emsp; 切换分支： git branch branchname //在当前分支下创建分支 git checkout branchname //切换到已有的分支 git checkout -b &apos;branchname&apos; //创建分支并切换 1&amp;emsp; &amp;emsp; 3.2.2&amp;emsp; 合并分支： git merge branchname //将分支合并到当前分支 12&amp;emsp; &amp;emsp; 3.2.3&amp;emsp; 删除分支： git branch -d branchname //删除分支 12### **3.3 Git 远程分支处理** &amp;emsp; &amp;emsp; 3.3.1&amp;emsp;跟踪远程分支： git checkout -b [分支名] [远程仓库名]/[分支名] //跟踪分支是一种和某个远程分支有直接联系的本地分支 git pull //新建跟踪分支后用该命令直接将远程分支合并进来 git push //将本地跟踪分支推送到远程分支 git push --set-upstream [远程仓库名] [分支名] //将当前的分支设置为跟踪某个远程分支 1&amp;emsp; &amp;emsp; 3.3.2&amp;emsp;抓取和合并远程分支： git fetch origin //同步远程origin/master数据到本地，指针移到它最新的位置上。 git merge origin/remotename //将远程分支的内容合并到当前分支，用于远程分支已同步而又不能直接访问时。 12&amp;emsp; &amp;emsp; 3.3.3&amp;emsp;推送分支和删除远程分支： git push origin name1:name2 //把本地分支name1推送到远程分支name2中，如果远程仓库没有这个分支，会生成这样一个新的分支。用这种方式可以远程创建分支。 git push origin name //将本地分支推到远程同名分支。 git push origin :remotename //把空白远程远程分支，即删除远程分支。 ` 这些就是基本的git命令，更多待进一步学习","categories":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}],"tags":[{"name":"git使用","slug":"git使用","permalink":"http://WenDeng.github.io/tags/git使用/"},{"name":"技术","slug":"技术","permalink":"http://WenDeng.github.io/tags/技术/"}],"keywords":[{"name":"项目工具","slug":"项目工具","permalink":"http://WenDeng.github.io/categories/项目工具/"}]}]}