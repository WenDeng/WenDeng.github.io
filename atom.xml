<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>野渡 的博客</title>
  
  <subtitle>路漫漫其修远兮 吾将上下而求索！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WenDeng.github.io/"/>
  <updated>2019-07-29T17:18:54.934Z</updated>
  <id>http://WenDeng.github.io/</id>
  
  <author>
    <name>野渡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>必须掌握的面试问题系列（一）数据库（转）</title>
    <link href="http://WenDeng.github.io/2019/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://WenDeng.github.io/2019/07/01/数据库/必须掌握的面试问题系列（一）数据库/</id>
    <published>2019-07-01T14:37:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是总结了一下常见的数据库问题，主要是对之前的知识进行回顾和复习。<br><a id="more"></a></p><h4 id="一、为什么用自增列作为主键？"><a href="#一、为什么用自增列作为主键？" class="headerlink" title="一、为什么用自增列作为主键？"></a>一、为什么用自增列作为主键？</h4><p>1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为<strong>聚集索引</strong>。如果没有显式定义主键，则InnoDB会选择第一个<strong>不包含有NULL值的唯一索引</strong>作为主键索引。</p><p>如果也没有这样的唯一索引，则InnoDB会选择<strong>内置6字节长的ROWID作为隐含的聚集索引</strong>，并随着行记录的写入而递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的。</p><p>2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>4、如果使用<strong>非自增主键</strong>（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h4 id="二、为什么使用数据索引能提高效率？"><a href="#二、为什么使用数据索引能提高效率？" class="headerlink" title="二、为什么使用数据索引能提高效率？"></a>二、为什么使用数据索引能提高效率？</h4><p>数据索引的存储是有序的，在有序的情况下，通过索引查询一个数据是无需遍历索引记录的。极端情况下，数据索引的查询效率为二分法查询效率，趋近于log2(N)。</p><h4 id="三、B-树索引和哈希索引的区别"><a href="#三、B-树索引和哈希索引的区别" class="headerlink" title="三、B+树索引和哈希索引的区别"></a>三、B+树索引和哈希索引的区别</h4><p><strong>B+树</strong>是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的。</p><p><strong>哈希索引</strong>就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的。</p><h4 id="四、哈希索引的优势："><a href="#四、哈希索引的优势：" class="headerlink" title="四、哈希索引的优势："></a>四、哈希索引的优势：</h4><p>等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p><h4 id="五、哈希索引不适用的场景："><a href="#五、哈希索引不适用的场景：" class="headerlink" title="五、哈希索引不适用的场景："></a>五、哈希索引不适用的场景：</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li></ul><p>通常，B+树索引结构适用于绝大多数场景，没有范围查询、没有排序的时候，特别适合采用哈希索引。</p><h6 id="仅等值查询"><a href="#仅等值查询" class="headerlink" title="仅等值查询"></a>仅等值查询</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'李明'</span>;</span><br></pre></td></tr></table></figure><p>而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。<strong>如果认为建立哈希索引可以提高查询效率</strong>，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</p><p>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p><p>注意：<strong>在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销</strong>。</p><p>但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</p><h4 id="六、B树和B-树的区别"><a href="#六、B树和B-树的区别" class="headerlink" title="六、B树和B+树的区别"></a>六、B树和B+树的区别</h4><p>1、B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p><p>2、B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。</p><h4 id="七、为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#七、为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="七、为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>七、为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h4><ul><li><p>（1）B+的磁盘读写代价更低。<br>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。<br>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p></li><li><p>（2）B+-tree的查询效率更加稳定。<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></li></ul><h4 id="八、MySQL联合索引"><a href="#八、MySQL联合索引" class="headerlink" title="八、MySQL联合索引"></a>八、MySQL联合索引</h4><ul><li><p>（1）联合索引是两个或更多个列上的索引。<br>对于联合索引: Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p></li><li><p>（2）利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</p></li></ul><p>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</p><h4 id="九、什么情况下应不建或少建索引？"><a href="#九、什么情况下应不建或少建索引？" class="headerlink" title="九、什么情况下应不建或少建索引？"></a>九、什么情况下应不建或少建索引？</h4><ul><li>1、表记录太少</li><li>2、经常插入、删除、修改的表</li><li>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>4、经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h4 id="十、什么是表分区？"><a href="#十、什么是表分区？" class="headerlink" title="十、什么是表分区？"></a>十、什么是表分区？</h4><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><h4 id="十一、表分区与分表的区别"><a href="#十一、表分区与分表的区别" class="headerlink" title="十一、表分区与分表的区别"></a>十一、表分区与分表的区别</h4><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p><p><strong>分表与分区的区别在于</strong>：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><h4 id="十二、表分区有什么好处？"><a href="#十二、表分区有什么好处？" class="headerlink" title="十二、表分区有什么好处？"></a>十二、表分区有什么好处？</h4><ul><li>1、存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据。</li><li>2、优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li>3、分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li><li>4、避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li></ul><h4 id="十三、分区表的限制因素"><a href="#十三、分区表的限制因素" class="headerlink" title="十三、分区表的限制因素"></a>十三、分区表的限制因素</h4><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h4 id="十四、如何判断当前MySQL是否支持分区？"><a href="#十四、如何判断当前MySQL是否支持分区？" class="headerlink" title="十四、如何判断当前MySQL是否支持分区？"></a>十四、如何判断当前MySQL是否支持分区？</h4><p>命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%partition%'</span></span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%partition%';</span><br><span class="line">+-------------------+-------+| <span class="type">Variable_name</span> | <span class="type">Value</span> |<span class="type">+-------------------+-------+| have_partitioning</span> | <span class="type">YES</span> |<span class="type">+-------------------+-------+1</span> row <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>have_partintioning 的值为YES，表示支持分区。</p><h4 id="十五、MySQL支持的分区类型有哪些？"><a href="#十五、MySQL支持的分区类型有哪些？" class="headerlink" title="十五、MySQL支持的分区类型有哪些？"></a>十五、MySQL支持的分区类型有哪些？</h4><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h4 id="十六、四种隔离级别"><a href="#十六、四种隔离级别" class="headerlink" title="十六、四种隔离级别"></a>十六、四种隔离级别</h4><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><h4 id="十七、关于MVCC，怎么实现的？MVCC有什么用？"><a href="#十七、关于MVCC，怎么实现的？MVCC有什么用？" class="headerlink" title="十七、关于MVCC，怎么实现的？MVCC有什么用？"></a>十七、关于MVCC，怎么实现的？MVCC有什么用？</h4><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) </p><blockquote><p>注：与MVCC相对的，是基于锁的并发控制LBCC，Lock-Based Concurrency Control</p></blockquote><p><strong>MVCC最大的好处</strong>：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</p><p>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</p><blockquote><p>其实现主要是通过增加两个隐藏的列，用来记录修改版本号和删除版本号，版本号有数据库支持。</p></blockquote><h4 id="十八、在MVCC并发控制中，读操作可以分成两类："><a href="#十八、在MVCC并发控制中，读操作可以分成两类：" class="headerlink" title="十八、在MVCC并发控制中，读操作可以分成两类："></a>十八、在MVCC并发控制中，读操作可以分成两类：</h4><ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）。</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li></ul><h4 id="十九、行级锁定的优点："><a href="#十九、行级锁定的优点：" class="headerlink" title="十九、行级锁定的优点："></a>十九、行级锁定的优点：</h4><ul><li>1、当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>2、回滚时只有少量的更改</li><li>3、可以长时间锁定单一的行。</li></ul><h4 id="二十、行级锁定的缺点："><a href="#二十、行级锁定的缺点：" class="headerlink" title="二十、行级锁定的缺点："></a>二十、行级锁定的缺点：</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li><strong>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁</strong>。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h4 id="二十一、MySQL优化"><a href="#二十一、MySQL优化" class="headerlink" title="二十一、MySQL优化"></a>二十一、MySQL优化</h4><ul><li><p>开启查询缓存，优化查询<br>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</p><p>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</p></li><li>为搜索字段建索引</li><li><p>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR</p></li><li><p>Prepared StatementsPrepared    Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p><p>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</p></li><li>垂直分表</li><li>选择正确的存储引擎</li></ul><h4 id="二十二、key和index的区别"><a href="#二十二、key和index的区别" class="headerlink" title="二十二、key和index的区别"></a>二十二、key和index的区别</h4><p>key是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</p><p>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</p><h4 id="二十三、Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#二十三、Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="二十三、Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>二十三、Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h4><p>区别：</p><ul><li>（1）InnoDB支持事务，MyISAM不支持<br>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>（2）InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>（3）<strong>InnoDB是聚集索引</strong>，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是<strong>辅助索引</strong>需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。<br>而<strong>MyISAM是非聚集索引</strong>，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>（4）InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>（5）Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul><p>如何选择：</p><ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul><h4 id="二十四、数据库表创建注意事项"><a href="#二十四、数据库表创建注意事项" class="headerlink" title="二十四、数据库表创建注意事项"></a>二十四、数据库表创建注意事项</h4><p>（1）字段名及字段配制合理性   </p><ul><li>剔除关系不密切的字段；   </li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><p>（2）系统特殊字段处理及建成后建议</p><ul><li>添加<strong>删除标记</strong>（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><p>（3）表结构合理性配置</p><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><p>（4）其它建议</p><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是总结了一下常见的数据库问题，主要是对之前的知识进行回顾和复习。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://WenDeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试" scheme="http://WenDeng.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C++基础之元编程与constexpr</title>
    <link href="http://WenDeng.github.io/2019/06/30/c++%E5%9F%BA%E7%A1%80/C++%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8Econstexpr/"/>
    <id>http://WenDeng.github.io/2019/06/30/c++基础/C++基础之元编程与constexpr/</id>
    <published>2019-06-30T03:20:12.000Z</published>
    <updated>2019-07-29T17:18:54.930Z</updated>
    
    <content type="html"><![CDATA[<p><strong>元编程</strong>（metaprogramming）是一个典型的复合词，他由前缀 meta- 和词根 programming 复合而成，有“对一个程序进行编程”的意思。换句话说，编译器先编译你的代码，得到一份新的代码，然后再编译新的代码来解决问题。</p><p>模板元编程技术，即把一些可以在编译时完成的求值计算，通过模板特化的技术绑定到具体的实例化代码上，从而减少不必要的代码量，提升代码的运行效率。</p><a id="more"></a><h2 id="一、C-的元编程"><a href="#一、C-的元编程" class="headerlink" title="一、C++的元编程"></a>一、C++的元编程</h2><h3 id="1-1-为什么要元编程呢？"><a href="#1-1-为什么要元编程呢？" class="headerlink" title="1.1 为什么要元编程呢？"></a>1.1 为什么要元编程呢？</h3><p>前面我们知道了什么是元编程，那么为什么要有这种编写技巧呢？</p><p>无外乎两点：减少重复的代码以方便后期的维护，减少重复性的工作以方便后期的优化。其本质还是在于对编码逻辑的抽象，把重复性最高的工作，用最少的代码量来完成。<strong>在编译时让编译器来展开执行，这就是元编程的目的和核心思路</strong>。</p><p>在 C++ 中，关于元编程有两个门派，一个是<strong>模板元编程</strong>，主要借助的是模板特化来实现自动化编程。另一个是常量表达式门派，主要是借助 <strong>constexpr</strong> 这一关键字来实现。两者就目前而言区别不算很大，而且基本上提到 C++ 的元编程，大家都会首先想到模板元编程，所以后面的讨论主要讲解的工具也是模板元编程，特此说明一下。</p><h3 id="1-2-元编程实例"><a href="#1-2-元编程实例" class="headerlink" title="1.2 元编程实例"></a>1.2 元编程实例</h3><p>多说无益，我们先从最简单的例子说起。</p><h4 id="1-2-1-简单的递归"><a href="#1-2-1-简单的递归" class="headerlink" title="1.2.1 简单的递归"></a>1.2.1 简单的递归</h4><p>我们先写一个简单的普通版本的递归函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="built_in">pow</span>(a, b - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-2-2-元编程实现上述递归"><a href="#1-2-2-元编程实现上述递归" class="headerlink" title="1.2.2 元编程实现上述递归"></a>1.2.2 元编程实现上述递归</h4><p>这个代码特化了两个终止条件，相对之特化一个终止条件的减少了一层递归调用，能提速不少。但是我们都知道，每递归调用一次，就要压一次函数堆栈，尤其是一但递归次数变多了，不仅仅是效率大打折扣，还有很大概率因为堆栈溢出而出错。<strong>那么元编程是怎么处理这个任务的呢？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A, <span class="keyword">int</span> B&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; result = A * Pow&lt;A, B - <span class="number">1</span>&gt;::result &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Pow</span>&lt;A, 1&gt; &#123;</span> <span class="keyword">enum</span> &#123; result = A &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Pow</span>&lt;A, 0&gt; &#123;</span> <span class="keyword">enum</span> &#123; result = <span class="number">1</span> &#125;; &#125;;</span><br></pre></td></tr></table></figure><p>和递归写法类似，我们同样特化了两个终止条件，然后用一个枚举量<strong>result</strong> 来记录结果。之所以选择枚举量，是因为枚举量是一个常量表达式的最原始的实现方法，但是现在我们有<strong>constexpr</strong>关键字了，所以也可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A, <span class="keyword">int</span> B&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = A * ConstPow&lt;A, B - <span class="number">1</span>&gt;::result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span>&lt;A, 1&gt; &#123;</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = A; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> A&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ConstPow</span>&lt;A, 0&gt; &#123;</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> result = <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure><p>这两种写法本质上是相同的。当然有人会问为什么用struct而不是用 class，事实上，C++ 的class和struct最主要的区别就是前者可以显式修饰成员的属性，而后者只有一个public属性。那么对于这份代码，结果result显然是我们要公开出去的一个成员，所以为了节省代码量，我就偷懒写成struct了。</p><h4 id="1-2-2-普通递归和元编程实现的区别"><a href="#1-2-2-普通递归和元编程实现的区别" class="headerlink" title="1.2.2 普通递归和元编程实现的区别"></a>1.2.2 普通递归和元编程实现的区别</h4><p>上述两种方式对递归的求解调用如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//普通递归实现</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Pow&lt;<span class="number">2</span>, <span class="number">4</span>&gt;::result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//元编程实现</span></span><br></pre></td></tr></table></figure></p><p>那么这两种写法在具体调用时，有什么区别呢？</p><p>区别就在于执行计算的时期不同。前者是典型的运行时展开运行时计算，也就是只有在代码真正运行的时候，才会进入函数，开始递归计算。<strong>而后者是典型的编译时展开编译时计算</strong>。实际上在编译时就会被展开写作如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">4</span>&gt;</span>::result <span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">3</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">2</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * 2 * Pow<span class="tag">&lt;<span class="name">2,</span> <span class="attr">1</span>&gt;</span>::result</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 2 * 2 * 2 * 2</span><br><span class="line"><span class="tag">&lt;<span class="name">=</span>&gt;</span> 16</span><br></pre></td></tr></table></figure><p>所以代码中的这句<strong>cout&lt;&lt;Pow&lt;2, 4&gt;::result</strong>实际上和直接写<strong>cout&lt;&lt;16</strong>是一样的，也就是说，真正的计算任务给了编译器，而运行时只是把编译时算好的答案打印出来而已。</p><p>在这里，<code>Pow&amp;lt;&amp;gt;</code> 这份模板就被称为<strong>模板元编程技术，即把一些可以在编译时完成的求值计算，通过模板特化的技术绑定到具体的实例化代码上，从而减少不必要的代码量，提升代码的运行效率</strong>。</p><h3 id="1-3-元编程对性能的影响"><a href="#1-3-元编程对性能的影响" class="headerlink" title="1.3 元编程对性能的影响"></a>1.3 元编程对性能的影响</h3><p>这里首先要泼一盆冷水给大家，那就是天底下没有免费的好事：模板元编程在提升了代码的运行效率的同时，必然会导致编译时的效率降低，因为你把很多本来运行时的计算前置到了编译时计算，总的计算量并没有改变。所以我们反复强调的是，提升了运行效率，而非提升了整体的性能。</p><p>需要注意的是：众所周知，枚举变量，是没有地址的！是没有地址的！是没有地址的！所以是不能当做左值使用的！所以是不能当做左值使用的！所以是不能当做左值使用的！为什么要强调这个呢？</p><p>比如我们有一个函数是这样的接口void foo(const int &amp;);然后你调用了一个 foo(Pow&lt;2, 5&gt;::result);这样是不可以的。因为引用传递枚举值的时候，并不会使用任何静态内存，类似于字面量一样，所以一旦你把枚举值当左值使用了，编译器自然就会报错提醒。但是如果是<strong>常量表达式</strong>，就不会有这种问题，因为常量表达式的第一个前提是，它是变量，所以他有物理地址，所以可以foo(Pow&lt;2, 5&gt;::result);。</p><h2 id="二、试试稍复杂的模板元编程"><a href="#二、试试稍复杂的模板元编程" class="headerlink" title="二、试试稍复杂的模板元编程"></a>二、试试稍复杂的模板元编程</h2><p>最后我们实现一个稍微复杂的例子：计算两个向量的一般数学意义上的内积，即比如我们有两个三维向量a[]和b[]，其内积的定义为a[0]*b[0]+a[1]*b[1]+a[2]*b[2]。</p><p>我们先考虑最简单的模板函数的实现方式，不妨假设我们的向量是通过容器T[]储存的，那么我们可以用递归方式这样写：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T&gt; T dot_re(<span class="built_in">int</span> <span class="built_in">dim</span>, T *a, T *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dim</span> == <span class="number">1</span>) <span class="keyword">return</span> (*a) * (*b);</span><br><span class="line">    <span class="keyword">return</span> (*a) * (*b) + dot_re(<span class="built_in">dim</span> - <span class="number">1</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们试试把它改成元编程版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> DIM, <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">Dot</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">result</span><span class="params">(T *a, T *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*a) * (*b) + __Dot&lt;DIM - <span class="number">1</span>, T&gt;::result(a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">Dot</span>&lt;1, T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">result</span><span class="params">(T *a, T *b)</span> </span>&#123; <span class="keyword">return</span> (*a) * (*b); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> DIM, <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">dot_meta</span>(<span class="title">T</span> *<span class="title">a</span>, <span class="title">T</span> *<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __Dot&lt;DIM, T&gt;::result(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候可能会问，为什么命名第一种写法最简单最快，但是我们还要刻意写一份元编程版本的呢？</p><p>这是由于，现代编译器普遍都具有了针对循环和递归的优化，这种优化对于比较大规模的循环是非常值得的，但是针对于比较小的向量内积计算，可能就没有一句直接展开a[0]*b[0] + a[1]*b[1] + a[2]*b[2]更为迅速了。可能一次两次的这种计算体现不出来，但是如果是大规模的计算可能就差别很大了。为了方便，我们折腾一个 benchmark 测试一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">dot</span>(<span class="title">int</span> <span class="title">dim</span>, <span class="title">T</span> *<span class="title">a</span>, <span class="title">T</span> *<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> result = T();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">        result += a[i] * b[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">benchmark</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DOT_META_(dim, a, b) dot_meta<span class="meta-string">&lt;dim&gt;(a, b)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> TEST_CASE(id, foo) for (int i = 0; i &lt; cnt; i++)\</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)\</span><br><span class="line">    &#123;\</span><br><span class="line">        <span class="keyword">int</span> hoge = foo(<span class="number">4</span>, a.data(), b.data());\</span><br><span class="line">        sum#<span class="meta">#id += hoge * foo(4, a.data(), a.data());\</span></span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">auto</span> t#<span class="meta">#id = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> t0 = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    TEST_CASE(<span class="number">1</span>, dot)</span><br><span class="line">    TEST_CASE(<span class="number">2</span>, dot_re)</span><br><span class="line">    TEST_CASE(<span class="number">3</span>, DOT_META_)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"======== "</span> &lt;&lt; cnt &lt;&lt; <span class="string">" ========\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot():      "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t1 - t0).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot_re():   "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t2 - t1).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"dot_meta(): "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;(t3 - t2).count() &lt;&lt; <span class="string">"ms\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"(sum1 % 100, sum2 % 100, sum3 % 100)= ("</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (sum1 % <span class="number">100</span>) &lt;&lt; <span class="string">", "</span> &lt;&lt; (sum2 % <span class="number">100</span>) &lt;&lt; <span class="string">", "</span>&lt;&lt; (sum3 % <span class="number">100</span>) &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> TEST_CASE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> DOT_META_</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) benchmark(i * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在编译时加上 <code>-O2</code> 选项，直接看结果：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">======== <span class="number">1000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">4.02</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">1.99</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">0.00</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">3000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">37.87</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">15.98</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">1.99</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(16, 16, 16)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">5000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">104.75</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">43.89</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">6.99</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(48, 48, 48)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">7000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">203.42</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">87.76</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">13.96</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(-4, -4, -4)</span></span><br><span class="line"></span><br><span class="line">======== <span class="number">9000</span> ========</span><br><span class="line">dot<span class="comment">()</span>:      <span class="number">336.08</span>ms</span><br><span class="line">dot_re<span class="comment">()</span>:   <span class="number">144.64</span>ms</span><br><span class="line">dot_meta<span class="comment">()</span>: <span class="number">23.93</span>ms</span><br><span class="line"><span class="comment">(sum1 % 100, sum2 % 100, sum3 % 100)</span>= <span class="comment">(-40, -40, -40)</span></span><br></pre></td></tr></table></figure><p>可见，元编程版本的速度远远超过了前面的两种写法，而为什么递归版本的速度比循环要快呢？这是因为编译器把我们的递归版本进行了尾递归改写，然后再尾递归优化。有兴趣的可以利用g++ -S把汇编代码编译出来对比下区别。在我的电脑上，如果没有开-O2`优化，汇编的代码忠实的记录了执行时会进行递归调用。但是如果开了-O2优化之后，就会发现整个递归已经被改写成非常简洁的迭代代码。这就是最简单的尾递归优化。但是即便如此，也比不上直接展开计算的效率。当然，并不是所有时候这种展开都会很快，而这更多的细节就等到真正用到的时候再去测试吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;元编程&lt;/strong&gt;（metaprogramming）是一个典型的复合词，他由前缀 meta- 和词根 programming 复合而成，有“对一个程序进行编程”的意思。换句话说，编译器先编译你的代码，得到一份新的代码，然后再编译新的代码来解决问题。&lt;/p&gt;
&lt;p&gt;模板元编程技术，即把一些可以在编译时完成的求值计算，通过模板特化的技术绑定到具体的实例化代码上，从而减少不必要的代码量，提升代码的运行效率。&lt;/p&gt;
    
    </summary>
    
      <category term="C++基础" scheme="http://WenDeng.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++11特性" scheme="http://WenDeng.github.io/tags/C-11%E7%89%B9%E6%80%A7/"/>
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>8.最长回文子串与最长公共子串问题</title>
    <link href="http://WenDeng.github.io/2019/06/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://WenDeng.github.io/2019/06/13/算法与数据结构/8. 最长回文子串与最长公共子串问题/</id>
    <published>2019-06-13T02:58:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>字符串处理是常见的问题，其中又数最长回文字符串比较经典，这里总结一下。</p><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a><br><a id="more"></a></p><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure></p><h3 id="2、解法1：暴力求解"><a href="#2、解法1：暴力求解" class="headerlink" title="2、解法1：暴力求解"></a>2、解法1：暴力求解</h3><p>找你所有可能的子串，判断每一个字串是否为回文串。字串有n^2个，每一个字串都需要遍历一遍才能确定是否回文，故时间复杂度为：O( n^3)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">int</span> len = s.length(),maxlen=<span class="number">1</span>,start=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index1 = i,index2 = j;<span class="comment">//子串的两端坐标</span></span><br><span class="line">            <span class="keyword">while</span>(index1 &lt; index2 &amp;&amp; s[index1] == s[index2])<span class="comment">//依次进行匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                index1++;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index1 &gt;= index2 &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen) <span class="comment">//当前子串是回文子串</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxlen);<span class="comment">//提取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"oho"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解法2：利用最长公共字串求解"><a href="#3、解法2：利用最长公共字串求解" class="headerlink" title="3、解法2：利用最长公共字串求解"></a>3、解法2：利用最长公共字串求解</h3><p>本题可以转换为求解两个字符串的最长公共字串，对于输入字符串str，求其反转字符串rstr，求其最长公共子串即可。所以时间复杂度为求最长公共子串的时间复杂度：O(n^2),空间复杂度为O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> rev=s,ret,temp;</span><br><span class="line">        reverse(rev.begin(),rev.end());<span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">if</span>(rev==s) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;<span class="comment">//存放回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)<span class="comment">//查找s与rev的最长公共子串</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=<span class="string">""</span>;<span class="comment">//存放待验证子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp+=s[j];<span class="comment">//提取子串，每次增加一个字符</span></span><br><span class="line">                <span class="keyword">if</span>(temp.length()&lt;len)  <span class="keyword">continue</span>;<span class="comment">//子串的长度不够....</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rev.find(temp)!=<span class="number">-1</span>)<span class="comment">//在rev中找到temp</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> q=temp;<span class="comment">//q用来验证temp是否是回文子串</span></span><br><span class="line">                    reverse(q.begin(),q.end());</span><br><span class="line">                    <span class="keyword">if</span>(q==temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        len=temp.length();</span><br><span class="line">                        ret=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>如何求两个字符串的最长公共子串</strong>？一种比较合理的方式是分配一个二维数组，行和列分别对应的两个字符串的长度，对应的值表示两个字符串的字符是否相等。如果其i-1,j-1对应值大于0，则在其基础上+1。二位数组中的最大值即为最大长度。其实这也是一个动态规划问题，时间复杂度为O(n*m);</p><h3 id="4、解法3：动态规划求解"><a href="#4、解法3：动态规划求解" class="headerlink" title="4、解法3：动态规划求解"></a>4、解法3：动态规划求解</h3><p>定义dp[j][i]表示索引j到索引i的子串是否是回文串,为true时表示索引j到索引i形成的子串为回文子串，且子串起点索引为j,长度为i - j + 1。</p><p>我们知道，当只有一个字符时肯定是回文字符串，当有两个字符时，两个字符相等才能构成回文。那如果多个字符呢？其实可以递推，如果i到j回文，那么[i+1,j-1]也回文，反过来，要想[i,j]区间的字符串回文，那么str[i]需要等于str[j]并且[i+1，j-1]也回文。</p><p>对应的递推方程为：<br><img src="https://upload-images.jianshu.io/upload_images/6946981-a5f3dcc2b314fd49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/799/format/webp" alt="image"></p><p>实现代码为：(算法时间复杂度为O(N^2))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> dp[s.length()][s.length()];<span class="comment">//用一个二维数组记录状态</span></span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>,start = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); <span class="comment">//csting提供的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - j &lt; <span class="number">2</span>)  dp[j][i] = (s[i] == s[j]);</span><br><span class="line">            <span class="keyword">else</span>  dp[j][i] = (s[i] == s[j] &amp;&amp; dp[j + <span class="number">1</span>][i - <span class="number">1</span>]);<span class="comment">//递推</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[j][i] &amp;&amp; maxlen &lt; i - j + <span class="number">1</span>) <span class="comment">//找到回文子串</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = i - j + <span class="number">1</span>;</span><br><span class="line">                start = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);<span class="comment">//提取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、解法4：中心扩展法"><a href="#4、解法4：中心扩展法" class="headerlink" title="4、解法4：中心扩展法"></a>4、解法4：中心扩展法</h3><p>中心扩展就是遍历字符串，以每一个字母为中心，向两边扩展，这样来找最长的子回文串。算法复杂度为O(N^2)。</p><p>需要考虑两种情况：     </p><ul><li>长度为奇数的回文串，比如a, aba, abcba    </li><li>长度为偶数的回文串，比如aa, abba     </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line">        <span class="keyword">int</span> len = s.size(),maxlen = <span class="number">1</span>,start = <span class="number">0</span>,j,k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//求长度为奇数的回文串</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i - <span class="number">1</span>, k = i + <span class="number">1</span>;<span class="comment">//以i为中心点向两边展开</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len &amp;&amp; s[j] == s[k]) <span class="comment">//相等，则得到一个回文串</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k - j + <span class="number">1</span> &gt; maxlen)  maxlen = k - j + <span class="number">1</span>,start = j;</span><br><span class="line">                j--,k++;<span class="comment">//进一步扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//求长度为偶数的回文串</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i, k = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len &amp;&amp; s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k - j + <span class="number">1</span> &gt; maxlen)  maxlen = k - j + <span class="number">1</span>,start = j;</span><br><span class="line">                j--,k++;<span class="comment">//进一步扩展</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"abbb"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">""</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"ohomm"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;solu.longestPalindrome(<span class="string">"asdfghnmzxcv"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串处理是常见的问题，其中又数最长回文字符串比较经典，这里总结一下。&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://WenDeng.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="动态规划" scheme="http://WenDeng.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://WenDeng.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用与epoll原理探究</title>
    <link href="http://WenDeng.github.io/2019/06/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8Eepoll%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://WenDeng.github.io/2019/06/09/服务端编程/IO多路复用与epoll原理探究/</id>
    <published>2019-06-09T08:10:30.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>本文在引入五种IO模型的基础上，介绍常见的三种IO multiplexing技术select、poll和epoll的用法，并总结分析三者的应用场景和优缺点0，最后详细介绍epoll高效的原因。</p><a id="more"></a><h3 id="1、五种IO模型"><a href="#1、五种IO模型" class="headerlink" title="1、五种IO模型"></a>1、五种IO模型</h3><p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p><ul><li>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</li><li>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</li><li>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，主要作用是可以避免同步非阻塞IO模型中轮询等待的问题，可达到在同一个线程内同时处理多个IO请求的目的。。</li><li>（4）信号驱动 I/O（ signal driven IO）：信号驱动IO在实际中并不常用。</li><li>（5）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</li></ul><p>需要记住的是上述<strong>前四种IO都是同步IO</strong>。对于一次read IO访问，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>同步和异步的主要区别在于谁负责拷贝数据</strong>：同步方式下由用户线程将数据拷贝到用户空间；异步方式下由内核负责将数据拷贝到用户空间，拷贝完成后会通知用户线程或者调用用户线程注册的回调函数进行后续处理。</p><p><strong>阻塞和非阻塞的主要区别在于是否需要等待完成</strong>：阻塞和非阻塞主要是针对同步方式，阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p><h3 id="2、IO-multiplexing技术"><a href="#2、IO-multiplexing技术" class="headerlink" title="2、IO multiplexing技术"></a>2、IO multiplexing技术</h3><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（读就绪或写就绪），就通知程序进行相应的读写操作。</p><p>select、poll和epoll都是Linux API提供的IO复用方式。注意<strong>select，poll，epoll本质上都是同步I/O</strong>，因为这些就绪的IO上的数据都由用户线程进行拷贝。</p><p>下面主要讲select、poll、epoll的用法。</p><h4 id="2-1-select函数"><a href="#2-1-select函数" class="headerlink" title="2.1 select函数"></a>2.1 select函数</h4><p>select系统调用函数介绍：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span>(<span class="params"><span class="keyword">int</span> maxfd,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout</span>)</span>;</span><br><span class="line"><span class="comment">//maxfd表示需要监听的套接字最大描述符+1  </span></span><br><span class="line"><span class="comment">//fd_set是一个文件描述符集合。三个参数分别表示监听读、写和异常文件描述符集合，可以设为空指针。</span></span><br><span class="line"><span class="comment">//timeout设定等待时间，timeval结构用于指定这段时间的秒数和微秒数，可以精确到微秒。</span></span><br><span class="line"><span class="comment">//返回值：有就绪描述符就返回其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset) <span class="comment">//将指定的文件描述符集清空，必须进行初始化。</span></span><br><span class="line">FD_SET(fd_set *fdset) <span class="comment">//用于在文件描述符集合中增加一个新的文件描述符。</span></span><br><span class="line">FD_CLR(fd_set *fdset) <span class="comment">//用于在文件描述符集合中删除一个文件描述符。</span></span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd,fd_set *fdset) <span class="comment">//用于测试指定的文件描述符是否在该集合中。</span></span><br></pre></td></tr></table></figure></p><p><strong>select运行机制</strong><br>select()的机制中提供一种fd_set的数据结构，实际上是一个long类型的数组，每一位代表一个对应的文件描述符，通过宏进行添加和删除。当调用select()时，由内核根据IO状态修改fd_set的内容，由此来返回那些就绪IO。</p><p>相比同步阻塞模型，select怎加了添加监听文件描述符以及调用select函数的额外操作，还有返回后的遍历代价。其最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p><strong>select机制的缺点：</strong>    </p><ul><li>（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。</li><li>（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。</li><li>（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。</li><li>（4）每次调用select之前都需要遍历设置监听集合，重复工作。</li></ul><h4 id="2-2-poll函数"><a href="#2-2-poll函数" class="headerlink" title="2.2 poll函数"></a>2.2 poll函数</h4><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是<strong>poll没有最大文件描述符数量的限制</strong>。也就是说，poll只解决了上面的问题3，并没有解决问题1，2的性能开销问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//nfds记录数组fds中描述符的总数量</span></span><br><span class="line"><span class="comment">//返回值表示fds集合中就绪描述符数量，返回0表示超时，返回-1表示出错；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// 需要被检测或选择的文件描述符</span></span><br><span class="line">        <span class="keyword">short</span> events;                   <span class="comment">// 对文件描述符fd上感兴趣的事件</span></span><br><span class="line">        <span class="keyword">short</span> revents;                  <span class="comment">// 文件描述符fd上当前实际发生的事件</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-epoll函数"><a href="#2-3-epoll函数" class="headerlink" title="2.3 epoll函数"></a>2.3 epoll函数</h4><p>epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select来说，<strong>epoll没有描述符个数限制</strong>，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在<strong>用户空间和内核空间只需copy一次</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//epoll_create 函数创建一个epoll句柄，参数size表明内核要监听的描述符数量，失败时返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//epoll_ctl函数用于注册要监听的事件类型，带四个参数。</span></span><br><span class="line"><span class="comment">//epfd 表示epoll句柄；op 表示fd操作类型，包括EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL三种；</span></span><br><span class="line"><span class="comment">//fd 是要监听的描述符；event 表示要监听的事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// epoll_wait函数用于等待就绪事件，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</span></span><br><span class="line"><span class="comment">// epfd是epoll句柄；events表示从内核得到的就绪事件集合；</span></span><br><span class="line"><span class="comment">// maxevents告诉内核events的大小；timeout表示等待的超时事件。</span></span><br></pre></td></tr></table></figure></p><p>可以看出上述epoll机制的好处在于：分清了频繁调用和不频繁调用的操作。例如，epoll_ctrl是不太频繁调用的，而epoll_wait是非常频繁调用的。这时，epoll_wait却几乎没有入参，这比select的效率高出一大截，而且，它也不会随着并发连接的增加使得入参越发多起来，导致内核执行效率下降。</p><h3 id="3、epoll的LE和ET"><a href="#3、epoll的LE和ET" class="headerlink" title="3、epoll的LE和ET"></a>3、epoll的LE和ET</h3><p>epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序可以通过记录IO状态，从而减少epoll_wait的调用，提高应用程序效率。</p><ul><li><strong>水平触发（LT）</strong>：默认工作模式，表示当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</li><li><strong>边缘触发（ET）</strong>： 当epoll_wait检测到事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。边缘触发只在状态由未就绪变为就绪时只通知一次。</li></ul><p>ET和LE容易走向两个极端，LT会在你不能处理读或写时不断epoll_wait返回告诉你可读可写从而浪费不必要的时间；而ET则可能会在你想读或想写时由于错过第一次时机从而获取不到对应的响应。</p><p>总而言之，一般应用场景上两者的性能不会有什么大的差距，<strong>ET的优点在于epoll_wait的调用次数会减少一些</strong>，某些场景下连接在不必要唤醒时不会被唤醒（此唤醒指epoll_wait返回）。但实际上，这不单纯是一个网络问题，而跟应用场景相关，虽然大部分开源框架都是基于ET写的，但框架追求的是纯技术问题，力求尽善尽美，与实际应用还是有区别的。</p><blockquote><p>小结：LT模式和ET模式各有优缺点，无所谓孰优孰劣。使用 LT 模式，我们可以自由决定每次收取多少字节（对于普通 socket）或何时接收连接（对于侦听 socket），但是可能会导致多次触发；使用ET模式，我们必须每次都要将数据收完（对于普通socket）或必须理解调用accept接收连接（对于侦听socket），其优点是触发次数少。</p></blockquote><blockquote><p>应用场景：</p><ul><li>(1) 读频次少，每次数据很多：如果LT和ET模式下的缓冲区足够大，那么两种模式没有区别。但是如果缓冲区比较小，那么很明显应该用LT模式，而且也方便控制读入数据的量或者甚至推迟读数据。</li><li>(2) 写数据少，但频次多：对于写，LT为了避免频繁触发epoll_wait,每次写开始和写完后向epoll注册和注销事件，如果频次多，那就不太好，即使频次少，多次调用epoll_ctrl也会带来开销。与之对应的是，ET模式在写数据情况下表现很好。</li></ul></blockquote><h3 id="4、epoll的高效原理与内核管理机制"><a href="#4、epoll的高效原理与内核管理机制" class="headerlink" title="4、epoll的高效原理与内核管理机制"></a>4、epoll的高效原理与内核管理机制</h3><p>通过前面两节的知识，我们知道epoll高效的一个原因在于ET机制的引入减少epoll_wait的调用此时，而poll相对select优势在于不用重复遍历设置监听文件描述符集合，而epoll相对poll和select的优势在于不用来回在内核和用户空间copy监听集合，能快速返回活跃IO集合。</p><p>说到epoll都夸赞它的效率和并发量，那么它好在哪里呢？<br><strong>epoll的核心数据结构在于红黑树+双向链表</strong>，首先调用epoll_create时内核帮我们在epoll文件系统里建了个file结点；除此之外在内核cache里建立红黑树用于存储以后epoll_ctl传来的socket，当有新的socket连接来时，先遍历红黑书中有没有这个socket存在，如果有就立即返回，没有就插入红黑数，然后给内核中断处理程序注册一个钩子函数，每当有事件发生时就通过钩子函数把这些文件描述符放到用来存储就绪事件的链表中。<strong>epoll_wait并不监听文件句柄，而是等待就绪链表不空or收到信号or超时这三种条件后返回</strong>。</p><p>epoll_wait返回时，会将就绪链表上的事件摘除，在LT模式下，这些就绪socke事件会再次被放回到刚刚清空的准备就绪链表，保证所有的事件都得到正确的处理。如果到timeout时间后链表中没有数据也立刻返回。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/1.png?raw=true" alt="image"></p><p>对于epoll，需要建立文件系统，包括红黑树和链表代价会比较高，同时回调机制也会在fd活跃数目较多的情况下被反复调用，效率反而不高。所以：<strong>当监测的fd数目较小，或者fd数目多且各个fd都比较活跃，建议使用select或者poll；当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</strong>，比如ngix web服务器就是使用epoll实现的。</p><h3 id="5、select、poll和epoll的应用场景"><a href="#5、select、poll和epoll的应用场景" class="headerlink" title="5、select、poll和epoll的应用场景"></a>5、select、poll和epoll的应用场景</h3><p>我们知道epoll的优势非常明显，几乎没有描述符数量的限制，并发支持完美，不会随着socket的增加而降低效率，也不用在内核空间和用户空间之间做无效的copy操作。但是是不是所有的场景都适合epoll呢？</p><blockquote><p>一个游戏服务器，tcpserver负责接收客户端的连接，dbserver负责处理数据信息，一个webserver负责处理服务器的web请求，gameserver负责游戏的逻辑处理，所有这些服务都和另外一个gateserver相连，gateserver负责服务器间的通信和转发（进程间通信），只要游戏服务器在服务状态，这些连接几乎不会断开（异常情况可能会断开），并且这些连接数量一般不会很多。</p></blockquote><blockquote><p>这种情况，gateserver是选择select还是epoll呢？很明显是select，因为每时每刻这些连接的socket都有事件发生（比如：服务期间的心跳信息，还有大型网络游戏的同步信息（一般每秒在20-30次）），最重要的是，这种场景下，并发量也不会很大。如果此时用epoll，为此所建立的文件系统，红黑书和链表对于此来说就是杀鸡用牛刀，效率反而不高。</p></blockquote><blockquote><p>但是这里的tcpserver负责大量的客户端的连接，毫无疑问epoll是首选，它接受大量的客户端连接，收到客户端的消息之后把消息转发发给select网络模型的gateserver，gateserver再转发给gameserver进行逻辑处理，最后返回给客户端就over了。</p></blockquote><p>因此在如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了。</p><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>总结上述的知识可以看出，epoll建立红黑树和链表、调用回调函数都需要开销，适用于高并发而活跃连接较少的情况。select和poll的代价在于用户空间与内核态的数据拷贝和遍历处理，适用于连接量较少但其中大多数都比较活跃的情况。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/2.png?raw=true" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文在引入五种IO模型的基础上，介绍常见的三种IO multiplexing技术select、poll和epoll的用法，并总结分析三者的应用场景和优缺点0，最后详细介绍epoll高效的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="服务端编程" scheme="http://WenDeng.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="IO multiplexing" scheme="http://WenDeng.github.io/tags/IO-multiplexing/"/>
    
      <category term="epoll原理" scheme="http://WenDeng.github.io/tags/epoll%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>7.二叉树问题集合</title>
    <link href="http://WenDeng.github.io/2019/06/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
    <id>http://WenDeng.github.io/2019/06/06/算法与数据结构/7.二叉树问题集合/</id>
    <published>2019-06-06T02:32:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树是算法问题中的一个重点，主要考察逻辑思维和边界判断问题，本章主要总结几个常见的二叉树相关算法问题。</p><a id="more"></a><h3 id="1、序列化二叉树"><a href="#1、序列化二叉树" class="headerlink" title="1、序列化二叉树"></a>1、序列化二叉树</h3><h4 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><blockquote><p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h4 id="1-2-解题思路"><a href="#1-2-解题思路" class="headerlink" title="1.2 解题思路"></a>1.2 解题思路</h4><p>本题的考点在于二叉树和字符串之间的想好转换，此外需要知道二叉树的先序遍历。需要注意的是两位及两位以上的数字序列号成字符串后怎么反序列化回来，还有就是被调用的函数怎么修改指针值达到目的。</p><blockquote><p>用到的函数：to_string(int)、string.copy(dst,len,begin)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSerialize</span><span class="params">(<span class="built_in">string</span> &amp;str,TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;str+=<span class="string">"#,"</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(root) str += to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">        DoSerialize(str,root-&gt;left);</span><br><span class="line">        DoSerialize(str,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">Serialize</span><span class="params">(TreeNode *root)</span> <span class="comment">//将二叉树转换为字符串</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        DoSerialize(str,root);</span><br><span class="line">        <span class="keyword">char</span> *ret=<span class="keyword">new</span> <span class="keyword">char</span>[str.length()];  </span><br><span class="line">        str.copy(ret,str.length()<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//拷贝字符串</span></span><br><span class="line">        ret[str.length()<span class="number">-1</span>]==<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoDeserialize</span><span class="params">(TreeNode **node,<span class="keyword">char</span> *str,<span class="keyword">int</span> &amp;index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'\0'</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'#'</span>)  <span class="comment">//当前节点的左节点为空，直接返回。</span></span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[index]&gt;=<span class="string">'0'</span> &amp;&amp; str[index]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value=value*<span class="number">10</span>+str[index]-<span class="string">'0'</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *node=<span class="keyword">new</span> TreeNode(value); <span class="comment">//创建节点</span></span><br><span class="line">        DoDeserialize(&amp;((*node)-&gt;left),str,++index);</span><br><span class="line">        DoDeserialize(&amp;((*node)-&gt;right),str,++index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//将字符串转换为二叉树</span></span><br><span class="line">        TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!str) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//用来记录字符串的下标</span></span><br><span class="line">        DoDeserialize(&amp;root, str, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution solu;</span><br><span class="line">    TreeNode *p = <span class="keyword">new</span> TreeNode(<span class="number">11</span>);</span><br><span class="line">    TreeNode *node1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *node2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node3 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode *node4 = <span class="keyword">new</span> TreeNode(<span class="number">16</span>);</span><br><span class="line">    p-&gt;left=node3;</span><br><span class="line">    p-&gt;left-&gt;left=node2;</span><br><span class="line">    p-&gt;left-&gt;left-&gt;left=node1;</span><br><span class="line">    p-&gt;right=node4;</span><br><span class="line"></span><br><span class="line">    TreeNode *ptr=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solu.Serialize(p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *q=solu.Deserialize(solu.Serialize(p));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;solu.Serialize(q)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// string str="deng";</span></span><br><span class="line">    <span class="comment">// string &amp;str1=str;</span></span><br><span class="line">    <span class="comment">// str1+=" wen";</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;str1&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树是算法问题中的一个重点，主要考察逻辑思维和边界判断问题，本章主要总结几个常见的二叉树相关算法问题。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://WenDeng.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="二叉树" scheme="http://WenDeng.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>6.数组中的重复数</title>
    <link href="http://WenDeng.github.io/2019/05/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0/"/>
    <id>http://WenDeng.github.io/2019/05/27/算法与数据结构/6.数组中重复的数/</id>
    <published>2019-05-27T08:32:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><a id="more"></a><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><blockquote><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><h4 id="（1）Hash求解（或者排序后求解）"><a href="#（1）Hash求解（或者排序后求解）" class="headerlink" title="（1）Hash求解（或者排序后求解）"></a>（1）Hash求解（或者排序后求解）</h4><p>用一个辅助数组进行计数，遍历原数组并记录每个数出现的次数，然后就可以得到重复的数。这种的解法的的时间复杂度为O(n),空间复杂度也为O(n)。实现代码如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    // numbers: an<span class="built_in"> array </span>of integers</span><br><span class="line">    // length:  the length of<span class="built_in"> array </span>numbers</span><br><span class="line">    // duplication: (Output) the duplicated number in the<span class="built_in"> array </span>number</span><br><span class="line">    // Return value:true<span class="built_in"> if </span>the input is valid,<span class="built_in"> and </span>there are some duplications in the<span class="built_in"> array </span>number; otherwise false</span><br><span class="line">    </span><br><span class="line">    bool duplicate(int numbers[],<span class="built_in"> int </span>length, int* duplication) &#123;</span><br><span class="line">       <span class="built_in"> int </span>*cnt=new int[length]; //辅助数组</span><br><span class="line">        for(int i=0;i&lt;length;i++) cnt[i]=0; //计数都为0</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[i]&gt;=length || numbers[i]&lt;0)<span class="built_in"> return </span>false;</span><br><span class="line">            if(cnt[numbers[i]]&gt;=1) //判断是否重复</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication=numbers[i];</span><br><span class="line">                delete cnt; //记得释放</span><br><span class="line">               <span class="built_in"> return </span>true;</span><br><span class="line">            &#125;</span><br><span class="line">            else cnt[numbers[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        delete cnt;//记得释放</span><br><span class="line">       <span class="built_in"> return </span>false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="（2）创新解法"><a href="#（2）创新解法" class="headerlink" title="（2）创新解法"></a>（2）创新解法</h4><p>依次遍历数组，对于坐标i，取其值m，然后判断numbers[m]是否与m相等，相等则表明对应的位置上已经有该值，返回；否则交换numbers[i]和numbers[m]，将m放到对应的位置，然后继续取numbers[i],直到numbers[i]==i,即当前位置已经被放置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span> *duplication)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span>||length&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=numbers[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt;= length || numbers[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//范围出错</span></span><br><span class="line">                <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])  <span class="comment">//对应的数已经出现过一次了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *duplication = numbers[i]; <span class="comment">//找到值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);<span class="comment">//一直换，知道换到对应的数为相应的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该种解法的<strong>时间复杂度为O(n)</strong>,虽然有两重循环，但是固定位置的数只需要放正确一次即可，无论是while循环还是for循环都来做。<strong>空间复杂度为O(1)</strong>。</p><h3 id="3、类似的题"><a href="#3、类似的题" class="headerlink" title="3、类似的题"></a>3、类似的题</h3><h4 id="3-1-长度为n-1的数组放1-n的数，求重复的数（不能修改原数组）。"><a href="#3-1-长度为n-1的数组放1-n的数，求重复的数（不能修改原数组）。" class="headerlink" title="3.1 长度为n+1的数组放1~n的数，求重复的数（不能修改原数组）。"></a>3.1 长度为n+1的数组放1~n的数，求重复的数（不能修改原数组）。</h4><p>这个题跟上一个题的数主要区别是不能修改原数组。可以用辅助数组进行求解，还可以用二分法进行求解，如取中间的数m，然后统计1~m的数的个数cnt1，统计m+1~n的数的个数cnt2。如果cnt大于m，则对应的重复的数在1~m这个区间，继续二分，直到最后一个数。</p><p>时间复杂度为O(nlogn),空间复杂度为O(1)。</p><h4 id="3-2-除了一个数外，所有两个数都出现两次的数组，找出这个数。"><a href="#3-2-除了一个数外，所有两个数都出现两次的数组，找出这个数。" class="headerlink" title="3.2 除了一个数外，所有两个数都出现两次的数组，找出这个数。"></a>3.2 除了一个数外，所有两个数都出现两次的数组，找出这个数。</h4><p>用异或可解决问题，时间复杂度为O(n)。</p><h4 id="3-3-除了两个数外，所有两个数都出现两次的数组，找出这两个数。"><a href="#3-3-除了两个数外，所有两个数都出现两次的数组，找出这两个数。" class="headerlink" title="3.3 除了两个数外，所有两个数都出现两次的数组，找出这两个数。"></a>3.3 除了两个数外，所有两个数都出现两次的数组，找出这两个数。</h4><p>还是用异或进行解决，需要注意的是这里需要求出那两个特殊的数的异或结果，然后找到其为1最低位对应的2的幂值m，遍历数组找到与m相与为1的所有数然后异或即可得结果result1，遍历数组找到与m相与为0的所有数然后异或即可得结果result2。</p><h4 id="3-4-除一个数外，其它的所有的数都出现3次，求这个数。"><a href="#3-4-除一个数外，其它的所有的数都出现3次，求这个数。" class="headerlink" title="3.4 除一个数外，其它的所有的数都出现3次，求这个数。"></a>3.4 除一个数外，其它的所有的数都出现3次，求这个数。</h4><p>这个题的解法为用一个长度为32的数组，用来统计数组中所有数对应位为1的个数。最后遍历一次处理这个数组即可得到结果。</p><p>时间复杂度为O(n),空间复杂度为O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/p&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://WenDeng.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数组" scheme="http://WenDeng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>第9章 虚拟内存之C程序中常见的内存相关错误</title>
    <link href="http://WenDeng.github.io/2019/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF/"/>
    <id>http://WenDeng.github.io/2019/05/27/操作系统/第9章 虚拟内存之C程序中常见的内存相关错误/</id>
    <published>2019-05-26T16:32:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>对C/C++程序员来说，管理和使用虚拟存储器可能是个困难的， 容易出错的任务。与存储器有关的错误属于那些令人惊恐的错误， 因为它们在时间和空间上， 经常是在距错误源一段距离之后才表现出来。 将错误的数据写到错误的位置， 你的程序可能在最终失败之前运行了好几个小时，且使程序中止的位置距离错误的位置已经很远啦。而避免这种噩梦的最好方法就是<strong>防范于未然。</strong></p><p>本节主要介绍《深入理解计算机系统》中介绍的 <strong>C程序中常见的内存操作有关的10种典型编程错误</strong>， 以便以后随时查看，复习。</p><a id="more"></a><h3 id="1、-间接引用无效指针"><a href="#1、-间接引用无效指针" class="headerlink" title="1、 间接引用无效指针"></a>1、 间接引用无效指针</h3><p>进程虚拟地址空间的某些地址范围可能没有映射到任何有意义的数据，如果我们试图间接引用一个指向这些地址的指针，则操作系统会以终止进程。而且，虚拟存储器的某些区域是只读的（如.text或.rodata），试图写这些区域会以保护异常中止当前进程。  </p><p>如从stdin读取一个int变量时，scanf(“%d”, &amp;val)是正确用法，若误写为scanf(“%d”,<br>val)时，val的值会被解释为一个地址，并试图向该地址写数据。在最好的情况下，进程立即异常中止。在最坏的情况下，val的值恰好对应于虚拟存储器<br>的某个合法的具有读/写权限的内存区域，于是该内存单元会被改写，而这通常会在相当长的一段时间后造成灾难性的、令人困惑的后果。</p><p>我们学习C/C++中的指针时， 指针未初始化错误也属于这类错误。</p><h3 id="2、-读未初始化的存储器-Reading-Uninitialized-Memory"><a href="#2、-读未初始化的存储器-Reading-Uninitialized-Memory" class="headerlink" title="2、 读未初始化的存储器(Reading Uninitialized Memory)"></a>2、 读未初始化的存储器(Reading Uninitialized Memory)</h3><p>C语言的malloc并不负责初始化申请到的内存区域(在C/C++中未初始化的全局变量会被初始化为0)，因此，常见的错误是假设堆存储器被初始化为0，例如：</p><p>这个程序是计算一个 n*n的矩阵（**A） 乘以 一个 n*1（*x） 的矩阵, 并返回计算结果（*y）。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int  *matvec(int  **A,  int  *x,  int n)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>;</span><br><span class="line">    int  *y =  (int  *)malloc(n *  sizeof(int));  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span> ; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">0</span> ; <span class="built_in">j</span> &lt; n; <span class="built_in">j</span>++)</span><br><span class="line">    y[<span class="built_in">i</span>]  += A[<span class="built_in">i</span>][<span class="built_in">j</span>]  * x[<span class="built_in">j</span>];</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，错误地假设了y被初始化为0。<strong>正确的实现方式是显式地依次将y[i]置为0或者使用calloc分配内存</strong>。</p><h3 id="3、栈缓冲区溢出-Allowing-Stack-Buffer-Overflows"><a href="#3、栈缓冲区溢出-Allowing-Stack-Buffer-Overflows" class="headerlink" title="3、栈缓冲区溢出(Allowing Stack Buffer Overflows)"></a>3、栈缓冲区溢出(Allowing Stack Buffer Overflows)</h3><p>这个是我们熟悉的<strong>缓冲区溢出错误</strong>（buffer overflow bug）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *buf[<span class="number">64</span>];</span><br><span class="line">     gets(buf);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入超过64个字符， 上面的代码将导致栈缓冲区溢出。 可以使用 fgets 函数代替 gets函数， fget函数有第二个参数， 以限制输入串的大小。</p><h3 id="4、-误以为指针和它们指向的对象是相同大小的。-Assuming-that-Pointers-and-the-Objects-They-Point-to-Are-the-Same-Size"><a href="#4、-误以为指针和它们指向的对象是相同大小的。-Assuming-that-Pointers-and-the-Objects-They-Point-to-Are-the-Same-Size" class="headerlink" title="4、 误以为指针和它们指向的对象是相同大小的。(Assuming that Pointers and the Objects They Point to Are the Same Size)"></a>4、 误以为指针和它们指向的对象是相同大小的。(Assuming that Pointers and the Objects They Point to Are the Same Size)</h3><p>例如: 申请一个二维 n*m 的int数组空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">makeArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> i;  </span><br><span class="line">     <span class="keyword">int</span> **A = (<span class="keyword">int</span> **)Malloc(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">// 这里错误地认为int *与int两种变量类型具有相同的size  </span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">         A[i] = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> A;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码目的是创建一个由n个指针构成的数组，每个指针均指向一个包含m个int的数组，但是<strong>第五行</strong>误将<strong>sizeof(int*)</strong>写成<strong>sizeof(int)</strong>。这段代码只有在int和int*的size相同的机器上运行良好。如果在像Corei7这样的机器上运行这段代码，由于指针变量的size大于sizeof(int)，则会引发代码中的for循环写越界。因为这些字中的一个很可能是已分<br>配块的边界标记脚部，所以我们可能不会立即发现这个错误，直到进程运行很久释放这个内存块时，此时，分配器中的合并代码会戏剧性地失败，而没有任何明显的<br>原因。这是”在远处起作用”（action at distance）的一个隐秘示例，这类”在远处起作用”是与存储器有关的编程错误的典型情况。</p><h3 id="5、-造成错位错误-Making-Off-by-One-Errors"><a href="#5、-造成错位错误-Making-Off-by-One-Errors" class="headerlink" title="5、 造成错位错误(Making Off-by-One Errors)"></a>5、 造成错位错误(Making Off-by-One Errors)</h3><p>错位（Off-by-one）错误是另一种常见的覆盖错误来源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> ** <span class="title">makeArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">int</span> **A = (<span class="keyword">int</span> **)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">        A[i] = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> A;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，for循环次数不合预期，导致写越界。幸运的话，进程会立即崩溃；不幸的话，运行很长时间才抛出各种诡异问题。</p><h3 id="6、引用指针，而不是它所指向的对象-Referencing-a-Pointer-Instead-of-the-Object-It-Points-to"><a href="#6、引用指针，而不是它所指向的对象-Referencing-a-Pointer-Instead-of-the-Object-It-Points-to" class="headerlink" title="6、引用指针，而不是它所指向的对象(Referencing a Pointer Instead of the Object It Points to)"></a>6、引用指针，而不是它所指向的对象(Referencing a Pointer Instead of the Object It Points to)</h3><p>如果不注意C操作符的优先级和结合性，就会错误地操作指针，而不是指针所指向的对象。<br>比如下面的函数，其目的是删除一个有*size项的二叉堆里的第一项，然后对剩下的*size-1项重建堆：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * binheapDelete(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *<span class="built_in">size</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> *packet = binheap[<span class="number">0</span>];  </span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*<span class="built_in">size</span> - <span class="number">1</span>];  </span><br><span class="line">    *<span class="built_in">size</span>--;  <span class="comment">// 此处应该为(*size)--  </span></span><br><span class="line">    heapify(binheap, *<span class="built_in">size</span>, <span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">return</span> (packet);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，由于–和<em>优先级相同，从右向左结合，所以</em>size–其实减少的是指针自己的值，而非其指向的整数的值。因此，<strong>谨记：当你对优先级和结合性有疑问时，就应该使用括号。</strong></p><h3 id="7、误解指针运算-Misunderstanding-Pointer-Arithmetic"><a href="#7、误解指针运算-Misunderstanding-Pointer-Arithmetic" class="headerlink" title="7、误解指针运算(Misunderstanding Pointer Arithmetic)**"></a>7、误解指针运算(Misunderstanding Pointer Arithmetic)**</h3><p>在C/C++中，指针的算术操作是以它们指向的对象的大小为单位来进行的。例如下面函数的功能是扫描一个int的数组，并返回一个指针，指向val的首次出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(*p &amp;&amp; *p != val) &#123;  </span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// 此处应该为p++，否则p += 4会导致大部分元素被跳过  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、引用不存在的变量-Referenceing-Nonexistent-Variables"><a href="#8、引用不存在的变量-Referenceing-Nonexistent-Variables" class="headerlink" title="8、引用不存在的变量(Referenceing Nonexistent Variables)"></a>8、引用不存在的变量(Referenceing Nonexistent Variables)</h3><p>C/C++新手不理解栈的规则时，可能会引用不再合法的本地变量，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">stackref</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> val;  </span><br><span class="line">    <span class="keyword">return</span> &amp;val;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数返回的指针（假设为p）指向栈中的局部变量，但该变量在函数返回后随着stackref栈帧的销毁已经不再有效。也即：尽管函数返回的指针p仍然指向<br>一个合法的存储器地址，但它已经不再指向一个合法的变量了。当程序后续调用其它函数时，存储器将重用刚才销毁栈帧处的存储器区域。再后来，如果程序分配某<br>个值给*p，那么它可能实际上正在修改另一个函数栈帧中的数据，从而潜在地带来灾难性的、令人困惑的后果。</p><h3 id="9、引用空闲堆块中的数据-Referencing-Data-in-Free-Heap-Blocks"><a href="#9、引用空闲堆块中的数据-Referencing-Data-in-Free-Heap-Blocks" class="headerlink" title="9、引用空闲堆块中的数据(Referencing Data in Free Heap Blocks)"></a>9、引用空闲堆块中的数据(Referencing Data in Free Heap Blocks)</h3><p>典型的错误为：引用已经被释放了的堆块中的数据，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">heapref</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> i;  </span><br><span class="line">      <span class="keyword">int</span> *x, *y;  </span><br><span class="line">      x = (<span class="keyword">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">      <span class="comment">/*  各种操作 */</span>  </span><br><span class="line">      <span class="built_in">free</span>(x);  </span><br><span class="line">        </span><br><span class="line">      y = (<span class="keyword">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">          y[i] = x[i]++;  <span class="comment">// 此处的x之前已经被释放了！  </span></span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="10、-引起内存泄露（Introducing-Memory-leaks）"><a href="#10、-引起内存泄露（Introducing-Memory-leaks）" class="headerlink" title="10、 引起内存泄露（Introducing Memory leaks）"></a>10、 引起内存泄露（Introducing Memory leaks）</h3><p>内存泄露是缓慢、隐性的杀手，当程序员忘记释放已分配块时会发生这种问题，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">     <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果leak在程序整个生命周期内只调用数次，则问题还不是很严重（但还是会浪费存储器空间），因为随着进程结束，操作系统会回收这些内存空间。但如果<br>leak()被经常调用，那就会发生严重的内存泄露，最坏的情况下，会占用整个虚拟地址空间。对于像守护进程和服务器这样的程序来说，内存泄露是严重的<br>bug，必须加以重视。</p><p>【参考资料】<br>《深入理解计算机系统》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对C/C++程序员来说，管理和使用虚拟存储器可能是个困难的， 容易出错的任务。与存储器有关的错误属于那些令人惊恐的错误， 因为它们在时间和空间上， 经常是在距错误源一段距离之后才表现出来。 将错误的数据写到错误的位置， 你的程序可能在最终失败之前运行了好几个小时，且使程序中止的位置距离错误的位置已经很远啦。而避免这种噩梦的最好方法就是&lt;strong&gt;防范于未然。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本节主要介绍《深入理解计算机系统》中介绍的 &lt;strong&gt;C程序中常见的内存操作有关的10种典型编程错误&lt;/strong&gt;， 以便以后随时查看，复习。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《TCP-IP详解卷1》第4章ARP：地址解析协议</title>
    <link href="http://WenDeng.github.io/2019/05/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC4%E7%AB%A0ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
    <id>http://WenDeng.github.io/2019/05/24/网络协议/《TCP-IP详解卷1》第4章ARP：地址解析协议/</id>
    <published>2019-05-24T08:29:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。一个网络如以太网可以同时被不同的网络层使用。</p><p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。<strong>设备驱动程序从不检查IP数据报中的目的IP地址</strong>。</p><p>地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。ARP（地址解析协议）和RAR P（逆地址解析协议）就是这样的两个映射协议。</p><p>ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。</p><a id="more"></a><h3 id="1、从一个实例入手"><a href="#1、从一个实例入手" class="headerlink" title="1、从一个实例入手"></a>1、从一个实例入手</h3><p>当我们敲下以下命令：ftp bsdi，实际发生的过程如下。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/41.png?raw=true" alt="image"></p><ul><li>（1）应用程序FTP客户端调用函数gethostbyname(3)把主机名（bsdi）转换成32 bit的IP地址。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/host s）。</li><li>（2）FTP客户端请求TCP用得到的IP地址建立连接。</li><li>（3）TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报。</li><li>（4）如果目的主机在本地网络上，那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。</li><li>（5）假定是一个以太网，那么发送端主机必须把32bit的IP地址变换成48bit的以太网地址。逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。</li><li>（6）ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li><li>（7）目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li><li>（8）收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</li><li>（9）发送IP数据报到目的主机。</li></ul><p>在ARP背后有一个基本概念，那就是网络接口有一个硬件地址。<strong>在硬件层次上进行的数据帧交换必须有正确的接口地址</strong>。知道主机的IP地址并不能让内核发送一帧数据给主机。<strong>内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据</strong>。ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。</p><h3 id="2、ARP高速缓存"><a href="#2、ARP高速缓存" class="headerlink" title="2、ARP高速缓存"></a>2、ARP高速缓存</h3><p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。我们可以用arp(8)命令来检查ARP高速缓存。参数-a的意思是显示高速缓存中所有的内容。</p><h3 id="3、ARP的分组格式"><a href="#3、ARP的分组格式" class="headerlink" title="3、ARP的分组格式"></a>3、ARP的分组格式</h3><p>ARP的分组格式如下（42Byte: 28字节的ARP数据,14字节的以太网帧头）：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/42.png?raw=true" alt="image"></p><ul><li>（1）以太网报头中的前两个字段是以太网的源地址和目的地址<strong>。目的地址为全1的特殊地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧</strong>。</li><li>（2）以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。</li><li>（3）硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li><li>（4）协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。<strong>它的值与包含IP数据报的以太网数据帧中的类型字段的值相同</strong>，这是有意设计的。</li><li>（5）两个1字节的字段分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li><li>（6）操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RAR P请求（值为3）和RARP应答（值为4）。这个字段必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。</li><li>（7）接下来的四个字段是发送端的硬件地址、发送端的协议地址、目的端的硬件地址和目的端的协议地址。<strong>注意，这里有一些重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址</strong>。</li></ul><p>对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。<strong>当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去</strong>。</p><h3 id="4、分析ARP实例"><a href="#4、分析ARP实例" class="headerlink" title="4、分析ARP实例"></a>4、分析ARP实例</h3><p>现在通过tcpdump获得一个TCP连接请求产生的ARP请求和应答，我们来看一下它的含义：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/43.png?raw=true" alt="image"></p><p>在第1行中，源端主机的硬件地址是0:0:c0:6f:2d:40。目的端主机的硬件地址是ff:ff:ff:ff:ff:ff，这是一个以太网广播地址。紧接着的一个输出字段是arp，表明帧类型字段的值是0x0806，说明此数据帧是一个ARP请求或回答。在每行中，单词arp或ip后面的值60指的是以太网数据帧的最小长度,可以看出需要填充。第1行中的arp who-has字段表示作为ARP请求的这个数据帧中，目的IP地址是svr4的地址，发送端的IP地址是bsdi的地址。</p><p>从第2行中可以看到，尽管ARP请求是广播的，但是ARP应答的目的地址却是bsd（0:0:c0:6f:2d:40）。</p><p>第3行是第一个请求建立连接的TCP段。它的目的硬件地址是目的主机(svr4)。</p><h3 id="5、如果ARP请求的主机不存在会发生什么？"><a href="#5、如果ARP请求的主机不存在会发生什么？" class="headerlink" title="5、如果ARP请求的主机不存在会发生什么？"></a>5、如果ARP请求的主机不存在会发生什么？</h3><p>如果查询的主机已关机或不存在会发生什么情况呢？用telnet 140.254.13.36发起连接，然后用tcpdump来查看状态，结果如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/44.png?raw=true" alt="image"></p><p>令人感兴趣的是看到多次进行ARP请求：第1次请求发生后5.5秒进行第2次请求，在24秒之后又进行第3次请求。注意，在线路上始终看不到TCP的报文段。我们能看到的是ARP请求。直到ARP回答返回时，TCP报文段才可以被发送，因为硬件地址到这时才可能知道。如果我们用过滤模式运行tcpdump命令，只查看TCP数据，那么将没有任何输出。</p><h3 id="6、ARP代理"><a href="#6、ARP代理" class="headerlink" title="6、ARP代理"></a>6、ARP代理</h3><p>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或<strong>ARP代理</strong>。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。<strong>一种攻击就是欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/45.png?raw=true" alt="image"></p><p>如图,当子网140.252.1（称作gemini）上的其他主机有一份IP数据报要传给地址为140.252.1.29的sun时，gemini比较网络号140.252和子网号1，因为它们都是相同的，所以在以太网中转发IP地址140.252.1.29的ARP请求。路由器netb识别出该IP地址属于它的一个拔号主机，于是把它的以太网接口地址140.252.1作为硬件地址来回答。主机gemini通过以太网发送IP数据报到netb，netb通过拨号SLIP链路把数据报转发到sun。这个过程对于所有140.252.1子网上的主机来说都是透明的，主机sun实际上是在路由器netb后面进行配置的。<strong>在这个过程中路由器会对arp结果进行缓存，以提高下一次查询效率</strong>。</p><p><strong>为什么在拨号SLIP链路的两端只拥有一个IP地址，而在bsdi和slip之间的两端却分别有一个IP地址</strong>？<br>这是因为NetBlazer不需要知道拨号SLIP链路每一端的IP地址，相反，它通过分组到达的串行线路接口来确定发送分组的拨号主机，因此对于连接到路由器的每个拨号主机不需要用唯一的I P地址。所有的拨号主机使用同一个IP地址140.252.1.183作为SLIP链路的目的地址。</p><p><strong>ARP代理可以把数据报传送到路由器sun上，但是子网140.252.13上的其他主机是如何处理的呢</strong>？<br>选路必须使数据报能到达其他主机。这里需要特殊处理，选路表中的表项必须在网络140.252的某个地方制定，使所有数据报的目的端要么是子网140.252.13，要么是子网上的某个主机，这样都指向路由器netb。而路由器netb知道如何把数据报传到最终的目的端，即通过路由器sun。</p><h3 id="7、免费ARP"><a href="#7、免费ARP" class="headerlink" title="7、免费ARP"></a>7、免费ARP</h3><p>我们可以看到的另一个ARP特性称作<strong>免费ARP</strong>。它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</p><p>免费ARP可以有两个方面的作用：</p><ul><li>(1) 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误消息“以太网地址：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li><li>(2) 如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li></ul><h3 id="8、arp命令"><a href="#8、arp命令" class="headerlink" title="8、arp命令"></a>8、arp命令</h3><p>arp命令及几个常用的参数如下：</p><ul><li>-a：用来显示ARP高速缓存中的所有内容。</li><li>-d：用来删除ARP高速缓存中的某一项内容。</li><li>-s：用来增加高速缓存中的内容，这个参数需要IP和对应的以太网地址。</li><li>关键字pub和-s选项一起，可以使系统起着主机ARP代理的作用。系统将回答与主机名对应的IP地址的ARP请求，并以指定的以太网地址作为应答。</li></ul><h3 id="9、小结"><a href="#9、小结" class="headerlink" title="9、小结"></a>9、小结</h3><p>在大多数的TCP/IP实现中，ARP是一个基础协议，但是它的运行对于应用程序或系统管理员来说一般是透明的。ARP高速缓存在它的运行过程中非常关键，我们可以用arp命令对高速缓存进行检查和操作。高速缓存中的每一项内容都有一个定时器，根据它来删除不完整和完整的表项。arp命令可以显示和修改ARP高速缓存中的内容。</p><p>我们介绍了ARP的一般操作，同时也介绍了一些特殊的功能：委托ARP（当路由器对来自于另一个路由器接口的ARP请求进行应答时）和免费ARP（发送自己IP地址的ARP请求，一般发生在引导过程中）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。一个网络如以太网可以同时被不同的网络层使用。&lt;/p&gt;
&lt;p&gt;当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。&lt;strong&gt;设备驱动程序从不检查IP数据报中的目的IP地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。ARP（地址解析协议）和RAR P（逆地址解析协议）就是这样的两个映射协议。&lt;/p&gt;
&lt;p&gt;ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://WenDeng.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="TCP/IP协议" scheme="http://WenDeng.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>第9章 虚拟内存之动态内存分配与垃圾收集</title>
    <link href="http://WenDeng.github.io/2019/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>http://WenDeng.github.io/2019/05/23/操作系统/第9章 虚拟内存之动态内存分配与垃圾收集/</id>
    <published>2019-05-23T14:50:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用<strong>动态内存分配器</strong>更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种基本风格，<strong>显式分配器</strong>要求应用显式释放分配的块，而<strong>隐式分配器</strong>(<strong>也叫做垃圾收集器</strong>)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。</p><a id="more"></a><h3 id="1、malloc和free函数"><a href="#1、malloc和free函数" class="headerlink" title="1、malloc和free函数"></a>1、malloc和free函数</h3><h4 id="1-1-malloc函数"><a href="#1-1-malloc函数" class="headerlink" title="1.1 malloc函数"></a>1.1 malloc函数</h4><p>c标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">//返回：若成功则为已分配块的指针，若出错则为null.</span></span><br></pre></td></tr></table></figure></p><p>malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。如果malloc遇到问题，那么它就返回null，并设置errno。<strong>malloc不初始化它返回的内存，如果想要已初始化的内存则通过calloc分配，如果想要改变已分配块的大小则使用realloc函数</strong>。</p><h4 id="1-2-malloc的底层——sbrk函数"><a href="#1-2-malloc的底层——sbrk函数" class="headerlink" title="1.2 malloc的底层——sbrk函数"></a>1.2 malloc的底层——sbrk函数</h4><p>malloc可以通过mmap和munmap来显式分配和释放堆内存，或则还可以使用sbrk函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>; <span class="comment">//成功返回brk的旧值，出错返回-1</span></span><br></pre></td></tr></table></figure></p><p>sbrk函数通过将内核的brk(指向堆顶部)指针增加incr来扩展和收缩堆。如果成功则返回brk的旧值，否则返回-1并设置errno为ENOMEM。如果sbrk的参数为0，则返回的为原来的brk地址。</p><h4 id="1-3-free函数"><a href="#1-3-free函数" class="headerlink" title="1.3 free函数"></a>1.3 free函数</h4><p>程序通过调用free函数来释放已分配的堆块。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">//不返回值</span></span><br></pre></td></tr></table></figure></p><p>ptr必须指向一个已分配块的起始位置，如果不是，那么free的行为就是未定义的。</p><h3 id="2、为什么要使用动态内存"><a href="#2、为什么要使用动态内存" class="headerlink" title="2、为什么要使用动态内存"></a>2、为什么要使用动态内存</h3><p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如我们需要根据输入的n分配一个对应大小的数据来临时存储数据，这是就用动态分配比较好。</p><blockquote><p>值得注意的是，c99提供了动态的数组大小分配，可以不再需要由程序员显式分配动态空间。不过这种分配方式是否是堆上的空间就需要进一步验证了。</p></blockquote><h3 id="3、分配器的要求和目标"><a href="#3、分配器的要求和目标" class="headerlink" title="3、分配器的要求和目标"></a>3、分配器的要求和目标</h3><p>显式分配器必须在一些相当严格的约束条件下工作：</p><ul><li><strong>处理任意请求序列</strong>：一个应用可以有任意的分配请求和释放请求序列，分配器不可以假设分配和释放请求的顺序。</li><li><strong>立即响应请求</strong>：分配器必须立即响应分配请求。因此不允许分配器提高性能，从新排列或者缓冲请求。</li><li><strong>只使用堆</strong>：分配器使用的任何数据结构都保存在堆里。</li><li><strong>对齐块</strong>：比如8个字节的对齐。</li><li><strong>不修改已分配的块</strong>：分配器只能操作或者改变空闲块，不允许不能压缩已分配的块。</li></ul><p>分配器在满足上述要求的情况下，需要达到以下两个目标：</p><ul><li>(1)最大化吞吐率,单位时间完成尽可能多的请求。</li><li>(2)最大化存储器的利用率。天真的程序员经常不正确的假设虚拟存储器是一个无限的资源<strong>，事实上，一个系统中被所有进程分配的虚拟存储器的全部数量是受磁盘上交换空间的数量限制的</strong>。好的程序员知道虚拟内存是一个有限的空间，必须高效地使用。</li></ul><p>分配器设计中一个有趣的挑战就是在上述两个目标之间找到一个适当的平衡。</p><h3 id="3、碎片"><a href="#3、碎片" class="headerlink" title="3、碎片"></a>3、碎片</h3><p>造成堆的空间利用率很低的主要原因是一种被称为碎片的现象，当虽然有未使用的内存但这块内存并不能满足分配请求时，就会产生碎片。有以下两种形式的碎片：内部碎片和外部碎片。</p><ul><li><strong>内部碎片</strong>：在一个已分配块比有效载荷大时发生。比如分配器限制的最小分配至比实际请求值要大，又或者为了对齐而增加块的大小。意味着已分配但是未使用。</li><li>外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以来处理这个请求时发生。<strong>外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块</strong>。</li></ul><h3 id="4、分配器设计"><a href="#4、分配器设计" class="headerlink" title="4、分配器设计"></a>4、分配器设计</h3><p>一个分配器需要在吞吐率和利用率之间把握好平衡，必须要考虑以下几个因素：</p><ul><li>组织空闲块：如何组织</li><li>放置：怎么选择一个合适的块来放置新分配的块。</li><li>分割：新分配的块放到某个空闲块后，如何处理剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><h3 id="5、隐式空闲链表"><a href="#5、隐式空闲链表" class="headerlink" title="5、隐式空闲链表"></a>5、隐式空闲链表</h3><h4 id="5-1-组织空闲块"><a href="#5-1-组织空闲块" class="headerlink" title="5.1 组织空闲块"></a>5.1 组织空闲块</h4><p>假设用下图结构来组织堆块，并且已知采用双字对齐，头部后面的就是应用调用malloc时请求的有效载荷。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/30.jpg?raw=true" alt="image"></p><p>分配器将堆组织为下图式样的一个连续的已分配块和空闲块的序列，该序列被称为<strong>隐式空闲链表</strong>。之所以称为隐式空闲链表是因为分配需要遍历堆中所有的块，才能知道空闲块的集合。注意，<strong>图中用一个已分配而大小为的零的块来标记结束</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/31.png?raw=true" alt="image"></p><p>隐式空闲链表的有点是简单，缺点是放置开销会与已分配块和空闲块块的总数呈线性关系。</p><h4 id="5-2-放置已分配的块"><a href="#5-2-放置已分配的块" class="headerlink" title="5.2 放置已分配的块"></a>5.2 放置已分配的块</h4><p>当应用发起一个分配请求时，分配器需要从空闲链表中选择一个合适的块来满足请求。分配器的选择方式称为<strong>放置策略</strong>。常见的放置策略有以下几种：</p><ul><li><strong>首次适配</strong>：从头开始搜索空闲链表，选择第一个遇见的合适的空闲块。它的优点在于趋向于将大的空闲块保留在链表的后面，缺点是它趋向于在靠近链表前部处留下小空闲块的碎片，从而增加较大请求块的放置时间。</li><li><strong>下一次适配</strong>：每次从上一次查询结束的地方开始进行搜索，直到遇见合适的空闲块。这种策略通常比首次适配效率高，但是内存利用率则要低得多了</li><li><strong>最佳适配</strong>：检查每个空闲块，选择适合所需请求大小的最小空闲块。最佳适配的内存利用率是三种策略中最高的，但它需要对堆进行彻底的搜索。</li></ul><h4 id="5-3-分割空闲块"><a href="#5-3-分割空闲块" class="headerlink" title="5.3 分割空闲块"></a>5.3 分割空闲块</h4><p>分配器在匹配到一个合适的空闲块后，就需要决定分配这个空闲块中多少空间，可以称之为分割策略，一般有以下两种方式：</p><ul><li>（1）选择用整个空闲块，这个方式简单而且快捷，缺点是可能会造成很多内部碎片。</li><li>（2）分配器嫁给你空闲块分为两个部分，第一部分变成分配块，而剩下的那部分则组织成一个新的空闲块。</li></ul><h4 id="5-4-合并空闲块"><a href="#5-4-合并空闲块" class="headerlink" title="5.4 合并空闲块"></a>5.4 合并空闲块</h4><p>为了避免假碎片问题，分配器需要在释放一个已分配块时，除了重新标记当前块外也需要合并相邻空闲块。合并空闲块的方式称为合并策略，主要分为两种：</p><ul><li>（1）立即合并：就是在每次释放块时，就立即合并所有相邻块，这种方式可能会产生抖动（比如频繁在一个8字节的空闲块中执行3字节的分配与释放，就可能产生大量不必要的分割与合并）。</li><li>（2）推迟合并：即推迟合并空闲块的时机，比如直到某个分配请求失败才扫描整个堆，合并所有的空闲块。快速的分配器通常会选择某种形式的推迟合并。</li></ul><h4 id="5-5-合并空闲块的具体实现"><a href="#5-5-合并空闲块的具体实现" class="headerlink" title="5.5 合并空闲块的具体实现"></a>5.5 合并空闲块的具体实现</h4><p>对于向后合并，我们可以通过当前块的头部指针判断下一个块是否空闲，从而进行合并，但是如何合并前面的块呢？搜索整个链表？</p><p>Knuth提出了一种叫做<strong>边界标记</strong>的技术用于常数时间对前面的块进行合并。其实现如下图，通过在每个块的结尾处添加一个脚部，其是头部的一个副本。这样分配器就可以通过检查当前块的前一个字节的内容从而判断前一个块的起始位置和状态。</p><p>比如有一个释放当前块，其前一个块和后一块都是空闲的，此时需要将三块的大小求和然后更新前一块的头部和后一块脚部，明显能在常数时间内完成。</p><p>边界标记的一个缺陷是每一块都要保持一个头部和一个脚部，这会导致显著的内存开销。一种可能的优化方案是在已分配的块剩余部分保存脚部信息，从而减小开销。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/32.png?raw=true" alt="image"></p><h3 id="6、显式空闲链表"><a href="#6、显式空闲链表" class="headerlink" title="6、显式空闲链表"></a>6、显式空闲链表</h3><h4 id="6-1-空闲块组织"><a href="#6-1-空闲块组织" class="headerlink" title="6.1 空闲块组织"></a>6.1 空闲块组织</h4><p>其实对于通用的分配器来说，隐式空闲链表是不适合的，一种更好的方法是将空闲块组织为某种形式的显式空闲链表。</p><p>如下图，我们用一个双向链表组织空闲块，为了节省空间，我们将前驱指针pred和后继指针succ放在空闲块的主体当中。双向链表使得首次适配的时间从块总数的线性时间减少到了空闲块总数的线性时间。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/33.png?raw=true" alt="image"></p><p>在释放分配块时，有两种方式，分别为：</p><ul><li><strong>后进先出</strong>LIFO顺序维护链表：将新释放的块放在链表的开始处，加上边界标记后能快速合并完成并放置。<br>-<strong> 按照地址顺序维护链表</strong>：这种方式使得每个块的地址都小于它后继的地址。释放一个块比较麻烦，但是首次适配有更高的内存利用率。</li></ul><p>显式空闲链表的需要存储前向和后向指针，这会限制最小块的大小，从而增加内存碎片。</p><h4 id="6-2-分离的空闲链表"><a href="#6-2-分离的空闲链表" class="headerlink" title="6.2 分离的空闲链表"></a>6.2 分离的空闲链表</h4><p>为了减少分配时间，人们想出了另一种叫做<strong>分离存储</strong>的方法，主要是通过维护多个空闲链表，其中每个链表中的块有大致相等的大小。也即是分配器维护一个空闲链表数组，然后每个空闲链表中的空闲块按照大小进行升序排序。<strong>简单分离存储</strong>中采用的方式是每个空闲链中的空闲块大小一样，而<strong>分离适配</strong>方式的每个空闲链表中的块大小却不一样，这样适配时需要在空闲链表中进行匹配。</p><p>当有一个分配请求时，我们检查相应的空闲链表。如果链表非空，那么就分配其中第一块的全部。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，然后将这些块链接起来形成新的空闲链表。类型vector中的free list。</p><p>要释放一个块，分配器只需要简单地将这个块插入到相应的空闲链表的头部。</p><h3 id="7、垃圾收集"><a href="#7、垃圾收集" class="headerlink" title="7、垃圾收集"></a>7、垃圾收集</h3><p>在编写C程序时，一般只能显式地分配与释放堆中的内存（malloc()与free()），程序员不仅需要分配内存，还需要负责内存的释放。但如果能自动回收是不是更好呢？</p><p><strong>垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块</strong>。这些块被称为垃圾，自动回收堆存储的过程叫做垃圾收集。接下来讨论一种垃圾收集算法——Mark&amp;Sweep法，可以称为标记清除法。</p><h4 id="7-1-垃圾收集器垃圾组织"><a href="#7-1-垃圾收集器垃圾组织" class="headerlink" title="7.1 垃圾收集器垃圾组织"></a>7.1 垃圾收集器垃圾组织</h4><p>垃圾器将内存视为一张有向可达图，组织如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/34.png?raw=true" alt="image"></p><p>垃圾收集器一般采用以下两种（之一）的策略来判断一块堆内存是否为垃圾内存：</p><ul><li><p>引用计数器：在数据的物理空间中添加一个计数器，当有其他数据与其相关时（引用），该计数器加一，反之则减一。通过定期检查计数器的值，只要为0则认为是垃圾内存，可以释放它所占用的已分配块。使用引用计数器，实现简单直接，但缺点也很明显，它无法回收循环引用的两个对象（假设有对象A与对象B，它们2个互相引用，但实际上对象A与对象B都已经是没用的对象了）。</p></li><li><p>可达性分析：垃圾收集器将堆内存视为一张有向图，然后选出一组根节点（例如，在Java中一般为类加载器、全局变量、运行时常量池中的引用类型变量等），根节点必须是足够“活跃“的对象。然后计算从根节点集合出发的可达路径，只要从根节点出发不可达的节点，都视为垃圾内存。</p></li></ul><h4 id="7-2-Mark-amp-Sweep垃圾收集器"><a href="#7-2-Mark-amp-Sweep垃圾收集器" class="headerlink" title="7.2 Mark&amp;Sweep垃圾收集器"></a>7.2 Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。标记-清除算法实现简单，但它的效率不高，而且会产生许多内存碎片。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/35.png?raw=true" alt="image"></p><p>再介绍两种垃圾收集器进行回收的算法：</p><ul><li><p>复制：将程序所拥有的内存空间划分为大小相等的两块，每次都只使用其中的一块。当这一块的内存用完了，就把还存活着的对象复制到另一块内存上，然后将已使用过的内存空间进行清理。这种方法不必考虑内存碎片问题，但内存利用率很低。这个比例不是绝对的，像HotSpot虚拟机为了避免浪费，将内存划分为Eden空间与两个Survivor空间，每次都只使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一个Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例为8：1，只有10%的内存空间会被闲置浪费。</p></li><li><p>分代：分代算法根据对象的存活周期的不同将内存划分为多块，这样就可以对不同的年代采用不同的回收算法。一般分为新生代与老年代，新生代存放的是存活率较低的对象，可以采用复制算法；老年代存放的是存活率较高的对象，如果使用复制算法，那么内存空间会不够用，所以必须使用标记-清除或标记-整理算法。</p></li></ul><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本节主要讨论动态内存的分配与垃圾回收，主要是大概了解常见的内存管理方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然可以mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当需要额外的虚拟内存时，用&lt;strong&gt;动态内存分配器&lt;/strong&gt;更方便，也有更好的可移植性。&lt;/p&gt;
&lt;p&gt;动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。&lt;/p&gt;
&lt;p&gt;分配器有两种基本风格，&lt;strong&gt;显式分配器&lt;/strong&gt;要求应用显式释放分配的块，而&lt;strong&gt;隐式分配器&lt;/strong&gt;(&lt;strong&gt;也叫做垃圾收集器&lt;/strong&gt;)则要求分配器检查不再使用的块并释放。本文将对显示分配器和隐式分配器做更深入的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《TCP-IP详解卷1》第3章 IP：网际协议</title>
    <link href="http://WenDeng.github.io/2019/05/23/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC3%E7%AB%A0%20IP%EF%BC%9A%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/"/>
    <id>http://WenDeng.github.io/2019/05/23/网络协议/《TCP-IP详解卷1》第3章 IP：网际协议/</id>
    <published>2019-05-23T09:29:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。但是<strong>IP提供不可靠、无连接的数据报传送服务</strong>。</p><p>不可靠在于它不能保证IP数据报能成功到达目的地，仅提供最好的传输服务。IP在传输服务时出现错误(如，路由器的缓冲区用完了)，直接丢弃该数据报，然后通过ICMP消息给信源端。任何可靠性都必须由上层如TCP来提供。</p><p>无连接意味着IP不维护任何关于后续数据报的状态信息，每个数据报的处理都是独立的，可以不按顺序接收。不同的数据报都要独立地进行路由选择，可能选择不同的路线。</p><p>在本章，我们将简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。还要介绍两个有用的命令：ifconfig和netstat。<br><a id="more"></a></p><h3 id="1、IP首部"><a href="#1、IP首部" class="headerlink" title="1、IP首部"></a>1、IP首部</h3><p>IP数据报的格式如下图所示。普通的IP首部长为20个字节，除非含有选项字段。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/37.png?raw=true" alt="image"></p><p>IP的数据存储中，最高位在左边，记为0 bit；最低位在右边，记为31 bit。传输时则先0-7bit，最后24-31bit。也就是从高位到低位进行传输，这种传输顺序叫做Big endian字节序，由于TCP/IP首部的二进制整数也是这种传输顺序，因此也叫做网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</p><ul><li>(1) 目前版本协议号是4，因此IP有时也称作IPv4。</li><li>(2) 首部长度指的是首部占32bit字的数目，因此首部最长为60个字节(15*4)。普通IP数据报（没有任何选择项）字段的值是5。</li><li>(3) 服务类型(TOS):包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。现在大多数的TCP/IP实现都不支持TOS特性，</li><li>(4) 总字段长度是指整个IP数据报的长度，以字节为单位。所以IP数据报最长可达65535字节。尽管最长可传输65535字节的IP数据报，但是大多数的链路层都会对它进行分片。<strong>主机限制用户数据报长度为512字节，小于576字节</strong>。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容。</li><li>(5) 标识字段唯一的标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。<br>(6)TTL(Time to live)：生存时间字段设置了数据报可以经过的最多路由器数。通常为32或64。一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li><li>(7) 首部检验和字段是根据IP首部计算的校验和码。方法：对首部中每个16bit进行二进制反码求和。结果存在检验和字段中。</li><li>(8) 每一份IP数据报都包含源IP地址和目的IP地址。</li><li>(9) 最后一个字段是任选项，是数据报中的一个可变长的可选信息。选项字段一直都是以32bit作为界限，在必要的时候插入值为0的填充字节。</li></ul><h3 id="2、IP路由选择"><a href="#2、IP路由选择" class="headerlink" title="2、IP路由选择"></a>2、IP路由选择</h3><p>IP路由过程中，如果目的主机与源主机直接相连或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。</p><p>IP层在内存中有一个路由表。当收到一份数据报并进行发送时，都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果是，数据报就被送到由<strong>IP首部协议字段</strong>所指定的 协议模块进行处理，如果不是，则对数据包进行路由或者丢弃。</p><p>路由表中包含以下几项信息：</p><ul><li>(1) 目的IP地址；</li><li>(2) 下一站(下一跳)路由器(next-hop-router)的IP地址，或者有直接连接的网络IP地址。</li><li>(3) 标识。其中一个标识指明目的IP地址是网络地址还是主机地址，另一个标识指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li><li>(4) 为数据报的传输指定一个网络接口。</li></ul><p>IP路由选择主要完成以下功能</p><ul><li>(1) 搜索路由表，寻找能与<strong>目的IP地址</strong>完全匹配的表目；如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li><li>(2) 搜索路由表，寻找能与<strong>目的网络号</strong>相匹配的表目；如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li><li>(3) 搜索路由表，寻找<strong>默认路由表的表目</strong>。如果找到，则把报文发送给该表目指定的下一站路由器。</li></ul><p>为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模，比如Internet上的路由器有只有几千个表目，而不会是超过100万个表目。</p><p>IP数据包在路由时，需要注意以下几点：<br> (1) 数据报中的目的IP地址始终不发生任何变化。<br> (2) 每个链路层可能具有不同的数据帧首部，数据帧中的目的MAC地址始终指的是下一站结点的MAC地址。</p><h3 id="3、子网寻址"><a href="#3、子网寻址" class="headerlink" title="3、子网寻址"></a>3、子网寻址</h3><p> 现在所有的主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。样做的原因是因为A类和B类地址为主机号分配了太多的空间，事实上，在一个网络中人们并不安排这么多的主机。例如，这里有一个B类网络地址（140.252..），在剩下的16bit中，8bit用于子网号，8bit用于主机号。这样就允许25 4个子网，每个子网可以有254台主机(0或全1的主机号都是无效的，因此我们把总数减去2)。</p><p>子网对外部路由器来说隐藏了内部网络组织的细节，对于外部来说只需要一个IP地址即可，这样能极大地缩减路由表的规模，对于内部来说各个子网又互相透明，体会不到划分的存在。</p><h3 id="4、子网掩码"><a href="#4、子网掩码" class="headerlink" title="4、子网掩码"></a>4、子网掩码</h3><p> 主机在引导时进行的部分配置之一是指定主机的IP地址。除了IP地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号，而这是在引导过程中通过子网掩码来确定的。这个掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p><p> 子网掩码却经常用十六进制来表示，特别是当界限不是一个字节时，因为子网掩码是一个比特掩码。给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的地址（本子网、其他子网、其他网络）。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/38.png?raw=true" alt="image"></p><p> 如果知道本机的IP地址，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。比较时由网络号到子网号到主机号。</p><h3 id="5、特殊情况的IP地址"><a href="#5、特殊情况的IP地址" class="headerlink" title="5、特殊情况的IP地址"></a>5、特殊情况的IP地址</h3><p>下图介绍7个特殊的IP地址，在这个图中，0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。</p><p> <img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/39.png?raw=true" alt="image"></p><p>表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。表中的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。</p><h3 id="6、ifconfig命令"><a href="#6、ifconfig命令" class="headerlink" title="6、ifconfig命令"></a>6、ifconfig命令</h3><p>到目前为止，我们已经讨论了链路层和IP层，现在可以介绍TCP/IP对网络接口进行配置和查询的命令了。ifconfig命令一般在引导时运行，以配置主机上的每个接口。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">root</span>@<span class="selector-tag">DESKTOP-QI6PGJM</span>:/<span class="selector-tag">mnt</span>/<span class="selector-tag">d</span>/<span class="selector-tag">wsl_workspace</span>/<span class="selector-tag">MyCode_GitHub</span># <span class="selector-tag">ifconfig</span> <span class="selector-tag">-a</span></span><br><span class="line"><span class="selector-tag">eth0</span>      <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Ethernet</span>  <span class="selector-tag">HWaddr</span> <span class="selector-tag">40</span><span class="selector-pseudo">:8d</span><span class="selector-pseudo">:5c</span><span class="selector-pseudo">:0e</span><span class="selector-pseudo">:35</span><span class="selector-pseudo">:c9</span></span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:172.16.10.38</span>  <span class="selector-tag">Bcast</span><span class="selector-pseudo">:172.16.255.255</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.255.0.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-tag">fe80</span><span class="selector-pseudo">::50d0</span><span class="selector-pseudo">:c0b7</span><span class="selector-pseudo">:e553</span><span class="selector-pseudo">:b163</span>/<span class="selector-tag">64</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Unknown</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">BROADCAST</span> <span class="selector-tag">RUNNING</span> <span class="selector-tag">MULTICAST</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">lo</span>        <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Local</span> <span class="selector-tag">Loopback</span></span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:127.0.0.1</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.0.0.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-pseudo">::1</span>/<span class="selector-tag">128</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Unknown</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">LOOPBACK</span> <span class="selector-tag">RUNNING</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:0</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:0</span> (<span class="number">0.0</span> B)</span><br></pre></td></tr></table></figure></p><p>环回接口被认为是一个网络接口。它是一个A类地址，没有进行子网划分。</p><p>ifconfig命令一般支持TCP/IP以外的其他协议族，而且有很多参数。关于这些细节可以查看系统说明书。</p><h3 id="7、netstat命令"><a href="#7、netstat命令" class="headerlink" title="7、netstat命令"></a>7、netstat命令</h3><p>netstat命令也提供系统上的接口信息。-i参数将打印出接口信息，-n参数则打印出IP地址，而不是主机名字。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-QI6PGJM:/mnt/d/wsl_workspace/MyCode_GitHub# netstat -i</span><br><span class="line">Kernel<span class="built_in"> Interface </span>table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">eth1       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">eth2       1500 0         0      0      0 0             0      0      0      0 BMRU</span><br><span class="line">lo         1500 0         0      0      0 0             0      0      0      0 LRU</span><br><span class="line"></span><br><span class="line">root@DESKTOP-QI6PGJM:/mnt/d/wsl_workspace/MyCode_GitHub# netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local<span class="built_in"> Address </span>          Foreign<span class="built_in"> Address </span>        State</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags      <span class="built_in"> Type </span>      State         I-Node   Path</span><br></pre></td></tr></table></figure><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本章开始描述了IP首部的格式，并简要讨论了首部中的各个字段。我们还介绍了IP路由选择，并指出主机的路由选择可以非常简单：如果目的主机在直接相连的网络上，那么就把数据报直接传给目的主机，否则传给默认路由器。</p><p>在进行路由选择决策时，主机和路由器都使用路由表。在表中有三种类型的路由：特定主机型、特定网络型和默认路由型。路由表中的表目具有一定的优先级。在选择路由时，主机路由优先于网络路由，最后在没有其他可选路由存在时才选择默认路由。</p><p>IP路由选择是通过逐跳来实现的。数据报在各站的传输过程中目的IP地址始终不变，但是封装和目的链路层地址在每一站都可以改变。大多数的主机和许多路由器对于非本地网络的数据报都使用默认的下一站路由器。</p><p>A类和B类地址一般都要进行子网划分。用于子网号的比特数通过子网掩码来指定子网的划分缩小了Internet路由表的规模，因为许多网络经常可以通过单个表目就可以访问了。接口和网络的有关信息通过ifconfig和netstat命令可以获得，包括接口的IP地址、子网掩码、广播地址以及MTU等。</p><p>在本章的最后，我们对Internet协议族潜在的改进建议—下一代IP进行了讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。但是&lt;strong&gt;IP提供不可靠、无连接的数据报传送服务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不可靠在于它不能保证IP数据报能成功到达目的地，仅提供最好的传输服务。IP在传输服务时出现错误(如，路由器的缓冲区用完了)，直接丢弃该数据报，然后通过ICMP消息给信源端。任何可靠性都必须由上层如TCP来提供。&lt;/p&gt;
&lt;p&gt;无连接意味着IP不维护任何关于后续数据报的状态信息，每个数据报的处理都是独立的，可以不按顺序接收。不同的数据报都要独立地进行路由选择，可能选择不同的路线。&lt;/p&gt;
&lt;p&gt;在本章，我们将简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。还要介绍两个有用的命令：ifconfig和netstat。&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://WenDeng.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="TCP/IP协议" scheme="http://WenDeng.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》常见问题总结</title>
    <link href="http://WenDeng.github.io/2019/05/23/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://WenDeng.github.io/2019/05/23/c++基础/《STL源码剖析》常见问题总结/</id>
    <published>2019-05-23T04:38:05.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>《STL源码剖析》在学习完了之后也总结完了，但是感觉还是有些不太明白的地方，查了一些资料，总结了一下别人面试常遇到的问题，算是复习巩固，也是为了之后的找工作准备。</p><a id="more"></a><h3 id="一、关于容器的一些问题"><a href="#一、关于容器的一些问题" class="headerlink" title="一、关于容器的一些问题"></a>一、关于容器的一些问题</h3><h4 id="1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？"><a href="#1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？" class="headerlink" title="1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？"></a>1、当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？是不是线程安全的？</h4><ul><li>如果vector内存用完了，会以当前size大小重新申请2*size的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。</li><li><p>一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap，这样，但其实这些内存也只是放到内存池，并不能被外部使用。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">type</span>&gt; v;</span><br><span class="line"><span class="comment">//.... 这里添加许多元素给v</span></span><br><span class="line"><span class="comment">//.... 这里删除v中的许多元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">type</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"><span class="comment">//此时v的容量已经尽可能的符合其当前包含的元素数量</span></span><br><span class="line"><span class="comment">//对于string则可能像下面这样</span></span><br><span class="line"><span class="keyword">string</span>(s).<span class="built_in">swap</span>(s);</span><br></pre></td></tr></table></figure></li><li><p>关于线程安全，引用《effective stl》的第十二条：当涉及 STL容器和线程安全性时，你可以指望一个 STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望 STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。<strong>必须自己去写多线程安全措施</strong>。</p></li></ul><h4 id="2、写多读少应该用什么容器？"><a href="#2、写多读少应该用什么容器？" class="headerlink" title="2、写多读少应该用什么容器？"></a>2、写多读少应该用什么容器？</h4><p>关于容器的使用，可以总结以下几条规律：</p><ul><li>（1）如果需要高效的随机存取，不在乎插入和删除的效率，使用vector； </li><li>（2）如果需要大量的插入和删除元素，不关心随机存取的效率，使用list； </li><li>（3）如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque； </li><li>（4）如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap； </li><li>（5）如果打算查找一个元素是否存在于某集合中并且有序，唯一存在的情况使用set，不唯一存在的情况使用multiset。</li></ul><p>这里应该选用链表，链表的插入操作时常数时间复杂度，访问操作是O(n)，是最适合写多读少的容器。</p><h4 id="3、vector每次insert或erase之后，以前保存的iterator会不会失效？"><a href="#3、vector每次insert或erase之后，以前保存的iterator会不会失效？" class="headerlink" title="3、vector每次insert或erase之后，以前保存的iterator会不会失效？"></a>3、vector每次insert或erase之后，以前保存的iterator会不会失效？</h4><p>理论上会失效，理论上每次insert或者erase之后，所有的迭代器就重新计算的，所以都可以看作会失效，<strong>原则上是不能使用过期的内存</strong>，实际是否失效，需要分情况讨论：</p><p>（1）  insert时，假设insert位置在p，分两种情况：  </p><ul><li>(a) 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效</li><li>(b) 容器重新分配了内存，那么所有的迭代器都无效。</li></ul><p>（2）  erase时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置（如果之前p在尾巴上，则p指向无效尾end），p之后的迭代器都无效。</p><h4 id="4、-auto-ptr可以做vector的元素呢？为什么？"><a href="#4、-auto-ptr可以做vector的元素呢？为什么？" class="headerlink" title="4、 auto_ptr可以做vector的元素呢？为什么？"></a>4、 auto_ptr可以做vector的元素呢？为什么？</h4><p>不能。因为STL的标准容器规定它所容纳的元素必须是可以拷贝构造和可被转移赋值的。而auto_ptr不能，可以用shared_ptr智能指针代替。</p><h4 id="5、为何map和set的插入删除效率比用其他序列容器高？"><a href="#5、为何map和set的插入删除效率比用其他序列容器高？" class="headerlink" title="5、为何map和set的插入删除效率比用其他序列容器高？"></a>5、为何map和set的插入删除效率比用其他序列容器高？</h4><p>map和set容器的底层都是由RB-tree实现，各个节点间相互独立，由指针将其组织起来形成树结构。因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了；删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><h4 id="6、为何map和set不能像vector一样有个reserve函数来预分配数据？"><a href="#6、为何map和set不能像vector一样有个reserve函数来预分配数据？" class="headerlink" title="6、为何map和set不能像vector一样有个reserve函数来预分配数据？"></a>6、为何map和set不能像vector一样有个reserve函数来预分配数据？</h4><p>map和set内部存储的已经不是元素本身了，而是包含元素的节点。也就是说map内部使用的Alloc并不是map声明的时候从参数中传入的Alloc。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Alloc&gt; intmap;</span><br></pre></td></tr></table></figure></p><p>这时候在intmap中使用的allocator并不是Alloc, 而是通过了转换的Alloc，具体转换的方法时在内部通过<br>Alloc::rebind重新定义了新的节点分配器，详细的实现参看彻底学习STL中的Allocator。<br>其实你就记住一点，<strong>在map和set里面的分配器已经发生了变化，reserve方法你就不要奢望了</strong>。</p><h4 id="7、-当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？"><a href="#7、-当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？" class="headerlink" title="7、 当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？"></a>7、 当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？</h4><p>算一下就知道了，首先你得知道map和set的底层都是红黑树，红黑树的搜索近似于二分查找，二分查找呢，平均时间复杂度是O(log2n),这里简写成logn:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">log</span><span class="params">(<span class="number">10000</span>)</span></span> = <span class="number">13.3</span></span><br><span class="line"><span class="function"><span class="title">log</span><span class="params">(<span class="number">20000</span>)</span></span> = <span class="number">14.3</span></span><br></pre></td></tr></table></figure></p><p>可以看到，当数据量增大一倍的时候，搜索次数只不过多了1次,增长速度很慢。</p><h4 id="8、为何map和set中每次insert之后，以前保存的iterator不会失效？"><a href="#8、为何map和set中每次insert之后，以前保存的iterator不会失效？" class="headerlink" title="8、为何map和set中每次insert之后，以前保存的iterator不会失效？"></a>8、为何map和set中每次insert之后，以前保存的iterator不会失效？</h4><p>map和set中iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。</p><p>相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：<strong>不要使用过期的iterator</strong>。</p><h4 id="9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？"><a href="#9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？" class="headerlink" title="9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？"></a>9、map是怎么实现的？查找的复杂度是多少？能不能边遍历边删除？</h4><ul><li>map用红黑实现。</li><li>用红黑树的效率为O(logn)</li><li>map不可以边遍历边插入，map不像vector，它在对容器执行erase操作后不会返回后一个元素的迭代器，所以不能遍历地往后删除。</li></ul><h4 id="10、-hash-map和map的区别在哪里？"><a href="#10、-hash-map和map的区别在哪里？" class="headerlink" title="10、 hash_map和map的区别在哪里？"></a>10、 hash_map和map的区别在哪里？</h4><p>hash_map底层是散列的所以理论上操作的平均复杂度是常数时间，map底层是红黑树，理论上平均复杂度是O(logn)。</p><p>选用map还是hash_map，<strong>关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间</strong>。如果查询次数比较少看中单个效率，那么更偏向于选择map，这是因为map的每一次查询时间基本稳定，此时如果用hash_map可能会因为碰撞而导致O(N)的时间复杂度。如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。</p><h3 id="二、关于迭代器的一些问题"><a href="#二、关于迭代器的一些问题" class="headerlink" title="二、关于迭代器的一些问题"></a>二、关于迭代器的一些问题</h3><h4 id="1、-traits技术原理及应用"><a href="#1、-traits技术原理及应用" class="headerlink" title="1、 traits技术原理及应用"></a>1、 traits技术原理及应用</h4><p>traits技术原理主要为：<strong>模板参数推导机制+内嵌类型定义+模板偏特化</strong>。</p><p>在STL算法中用到迭代器时，会用到迭代器所指之物的型别，假设算法要设定返回值类型，以迭代器所指之物为型别，但是C++只支持sizeof()、并未<br>支持typeof()，即使typeid()，也只能获得型别名称，不能拿来声明变量，所以这里就要用到作为”特性萃取机“的traits技术。为了解决原生指针问题，引入了萃取层模板偏特化。</p><h3 id="三、关于算法的一些问题"><a href="#三、关于算法的一些问题" class="headerlink" title="三、关于算法的一些问题"></a>三、关于算法的一些问题</h3><h4 id="1、快排算法的枢轴位置是怎么选择的？"><a href="#1、快排算法的枢轴位置是怎么选择的？" class="headerlink" title="1、快排算法的枢轴位置是怎么选择的？"></a>1、快排算法的枢轴位置是怎么选择的？</h4><p>三点中值法，取整个序列的头、尾、中央三个位置的元素，以其中值作为枢轴。函数栈达到一定层数后会选择插入排序避免递归过多。</p><h4 id="2、简单说一下next-permutation和partition的实现？"><a href="#2、简单说一下next-permutation和partition的实现？" class="headerlink" title="2、简单说一下next_permutation和partition的实现？"></a>2、简单说一下next_permutation和partition的实现？</h4><ul><li><p>（1）next_permutation（下一个排列）<br>首先，从最尾端开始往前寻找两个相邻元素，另第一个元素为i，第二个元素为ii，且满足i&lt;ii。找到这样一组相邻元素后，再从尾端开始往前检验，找出第一个大于i的元素j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求“下一个”排列组合。</p></li><li><p>（2）partition<br>令头端迭代器first向尾部移动，尾部迭代器last向头部移动。当first所指的值大于或等于枢轴时就停下来，当last所指的值小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果first仍然在last左边，就将连着元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。如果发现两个迭代器交错了，表示整个序列已经调整完毕。</p></li></ul><h3 id="四、关于内存配置的一些问题"><a href="#四、关于内存配置的一些问题" class="headerlink" title="四、关于内存配置的一些问题"></a>四、关于内存配置的一些问题</h3><h4 id="1、stl对于小内存块请求与释放怎么处理的？"><a href="#1、stl对于小内存块请求与释放怎么处理的？" class="headerlink" title="1、stl对于小内存块请求与释放怎么处理的？"></a>1、stl对于小内存块请求与释放怎么处理的？</h4><p>STL考虑到小型内存区块的碎片问题，设计了<strong>双层级配置器</strong>，第一级配置直接使用malloc()和free()；第二级配置器则视情况采用不同的策略，当配置区大于128bytes时，直接调用第一级配置器；当配置区块小于128bytes时，便不借助第一级配置器，而使用一个memory pool来实现。究竟是使用第一级配置器还是第二级配置器，由一个宏定义来控制。<strong>SGI STL中默认使用第二级配置器</strong>。 </p><p>二级配置器会<strong>将任何小额区块的内存需求量上调至8的倍数</strong>，并且在它内部会维护16个free-list， 各自管理大小分别为8， 16，24，…，128bytes的小额区块，这样当有小额内存配置需求时，直接从对应的free list中拔出对应大小的内存(8的倍数)；当客户端归还内存时，将根据归还内存块的大小，将需要归还的内存插入到对应free list的最顶端。  </p><p>有点主要体现在：</p><ul><li>1）小对象的快速分配和释放。当一次性预先分配好一块固定大小的内存池后，对小于128字节的小块内存分配和释放的操作只是一些基本的指针操作，相比于直接调用malloc/free，开销小。  </li><li>2）避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间，而且会给OS的内存管理造成压力。  </li><li>3）尽可能最大化内存的利用率。当内存池尚有的空闲区域不足以分配所需的大小时，分配算法会将其链入到对应的空闲列表中，然后会尝试从空闲列表中寻找是否有合适大小的区域，  </li></ul><p>但是，这种内存分配器局限于STL容器中使用，并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中，而STL容器是知道它所需分配的对象大小的，比如上述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stl::<span class="built_in">vector</span> <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure></p><p>array是知道它需要分配的对象大小为sizeof(int)。一个通用的内存分配器是不需要知道待释放内存的大小的，类似于free(p)。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《STL源码剖析》在学习完了之后也总结完了，但是感觉还是有些不太明白的地方，查了一些资料，总结了一下别人面试常遇到的问题，算是复习巩固，也是为了之后的找工作准备。&lt;/p&gt;
    
    </summary>
    
      <category term="C++基础" scheme="http://WenDeng.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="STL源码" scheme="http://WenDeng.github.io/tags/STL%E6%BA%90%E7%A0%81/"/>
    
      <category term="面试" scheme="http://WenDeng.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>5.限制条件求和</title>
    <link href="http://WenDeng.github.io/2019/05/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%B1%82%E5%92%8C/"/>
    <id>http://WenDeng.github.io/2019/05/23/算法与数据结构/5.求和/</id>
    <published>2019-05-23T04:02:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>开一下脑洞 </p><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><a id="more"></a></p><h3 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h3><h4 id="（1）常规解法"><a href="#（1）常规解法" class="headerlink" title="（1）常规解法"></a>（1）常规解法</h4><p>这个题《剑指offer》提出了四种解法，分别如下：</p><ul><li>函数指针: 指针数组指向两个函数，!!n进行下标选择      </li><li>模板： 指定参数和不指定参数</li><li>构造函数： 构造函数每次一个静态变量+k，构造n个对象</li><li>虚函数: 父子类同一个方法，分别做累加和返回0，基类对象指针数组选择对应的虚函数进行求值</li></ul><h4 id="（2）有意思的解法"><a href="#（2）有意思的解法" class="headerlink" title="（2）有意思的解法"></a>（2）有意思的解法</h4><ul><li><p>pow函数：直接用pow函数进行求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">pow</span>(n,<span class="number">2</span>)+n)&gt;&gt;<span class="number">1</span>;<span class="comment">//直接求结果n(n+1)/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>判断条件求解：通过隐式调用条件判断进行求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>)); <span class="comment">//这里隐式调用了条件判断，不为0就递归</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>等价替换：用一些等价操作来进行替换，从而实现转换操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span>  <span class="comment">//等价于求n(n+1)/2 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];  <span class="comment">//等价于求n(n+1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>; <span class="comment">//等价于上述结果除2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常：用异常来作为作为结束条件</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Sum_Solution(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>(n);<span class="comment">//递归求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span>(<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>%n; <span class="comment">//n为0时出现异常</span></span><br><span class="line">            <span class="keyword">return</span> n+<span class="keyword">sum</span>(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">//捕获异常并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开一下脑洞 &lt;/p&gt;
&lt;p&gt;求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://WenDeng.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="思维扩散" scheme="http://WenDeng.github.io/tags/%E6%80%9D%E7%BB%B4%E6%89%A9%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>《TCP-IP详解卷1》第2章 链路层</title>
    <link href="http://WenDeng.github.io/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC2%E7%AB%A0%20%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://WenDeng.github.io/2019/05/22/网络协议/《TCP-IP详解卷1》第2章 链路层/</id>
    <published>2019-05-22T11:29:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>在TCP/IP协议族中，链路层主要有三个目的：</p><ul><li>（1）为IP模块发送和接收IP数据报；   </li><li>（2）为ARP模块发送ARP请求和接收ARP应答；</li><li>（3）为RARP发送RARP请求和接收RARP应答。</li></ul><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p><p>本节我们将详细讨论以太网链路层协议，两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。对MTU（最大传输单元）进行了介绍，这个概念在本书的后面章节中将多次遇到。我们还讨论了如何为串行线路选择MTU。<br><a id="more"></a></p><h3 id="1、以太网和IEEE-802封装"><a href="#1、以太网和IEEE-802封装" class="headerlink" title="1、以太网和IEEE 802封装"></a>1、以太网和IEEE 802封装</h3><p>以太网是指数字设备公司、英特尔公司（Intel Corp）和 Xerox 公司在1982年联合公布的一个标准；<strong>它是当今TCP/IP采用的主要的局域网技术</strong>。它采用一种称作CSMA/CD的媒体接入方法，其意思是带冲突检测的载波侦听多路接入。它的速率为10Mb/s，地址为48bit。</p><p>802是IEEE（电子电气工程师协会）802委员会公布的一个稍有不同的标准集合。其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网络。</p><p>在TCP/IP世界中，<strong>以太网IP数据报的封装是在RFC894中定义的，IEEE 802网络的IP数据报封装是在RFC1042中定义的</strong>。RFC要求主机必须支持以太网格式的封装，默认也是以太网格式。下图显示了两种不同形式的封装格式：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/34.png?raw=true" alt="image"></p><p>两种帧格式都采用48 bit（6字节）的目的地址和源地址。这就是我们在本书中所称的硬件地址。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。接下来的2个字节在两种帧格式中互不相同。在802标准定义的帧格式中，长度字段是指它后续数据的字节长度，但不包括CRC检验码。CRC字段用于帧内后续字节差错的循环冗余码检验（检验和）。</p><p>在以太网帧格式中，类型字段之后就是数据；而在802帧格式中，跟随在后面的是3字节的802.2LLC和5字节的802.2SNAP。目的服务访问点DSAP和源服务访问点SSAP的值都设为0xaa。Ctrl字段的值设为3。随后的3个字节org code都置为0。</p><p><strong>802.3标准定义的帧和以太网的帧都有最小长度要求</strong>。802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充字节。</p><blockquote><p>从以太网的封装格式可以看出，我们需要一种协议来正确提取IP数据报的信息，所以引入了接下来两节将要讨论的问题。</p></blockquote><h3 id="2、SLIP：串行线路IP"><a href="#2、SLIP：串行线路IP" class="headerlink" title="2、SLIP：串行线路IP"></a>2、SLIP：串行线路IP</h3><p>SLIP的全称是Serial Line IP；它是一种在串行线路上对IP数据报进行封装的简单形式，在RFC 1055中有详细描述；<strong>SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet</strong>。</p><p>SLIP协议以以下几条规则定义帧格式：</p><blockquote><ul><li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符；</li><li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它；0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同；</li><li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它;</li></ul></blockquote><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/35.png?raw=true" alt="image"></p><p>SLIP是一种简单的帧封装方法，还有一些不得一提的缺陷,如：</p><ul><li>每一端必须知道对方的IP地址，没有办法把本端的IP地址通知给另一端；</li><li>数据帧中没有类型字段（类似于以太网中的类型字段），如果一条串行线路用于SLIP，那么它不能同时使用其他协议；</li><li>SLIP没有在数据帧中加上检验和，需要上层协议提供某种形式的CRC；</li></ul><h3 id="3、CSLIP：压缩的SLIP"><a href="#3、CSLIP：压缩的SLIP" class="headerlink" title="3、CSLIP：压缩的SLIP"></a>3、CSLIP：压缩的SLIP</h3><p>由于串行线路的速率通常较低，而且通信经常是交互式的，因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节；于是人们提出一个被称作CSLIP（即压缩SLIP）的新协议，它在RFC 1144中被详细描述；</p><p>CSLIP一般能把上面的40个字节压缩到3或5个字节来记录变化部分。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。</p><h3 id="4、PPP：点对点协议"><a href="#4、PPP：点对点协议" class="headerlink" title="4、PPP：点对点协议"></a>4、PPP：点对点协议</h3><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p><ul><li>在串行链路上封装IP数据报。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接;</li><li>建立、配置及测试数据链路的<strong>链路控制协议LCP</strong>。它允许通信双方进行协商，以确定不同的选项;</li><li>针对不同网络层协议的<strong>网络控制协议NCP</strong>体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk;例如，IP NCP允许双方商定是否对报文首部进行压缩;</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/36.png?raw=true" alt="image"></p><p>上图是PPP数据帧的格式。每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</p><p>总的来说，PPP比SLIP具有下面这些优点：</p><ul><li>(1) PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li><li>(2) 每一帧都有循环冗余检验；</li><li>(3) 通信双方可以进行IP地址的动态协商(使用NCP)；</li><li>(4) 与CSLIP类似，对TCP和IP报文首部进行压缩；</li><li>(5) 链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li></ul><blockquote><p>尽管PPP比SLIP有更多的优点，但是现在的SLIP用户仍然比PPP用户多。随着产品越来越多，产家也开始逐渐支持PPP，因此最终PPP应该取代SLIP。</p></blockquote><h3 id="5、环回接口"><a href="#5、环回接口" class="headerlink" title="5、环回接口"></a>5、环回接口</h3><p>大多数的产品都支持环回接口，以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。<strong>多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现</strong>。其主要实现原理就是将IP数据报通过内核的IP输出函数放到IP输入队列中，从而进行输入处理。</p><p>需要注意以下几个关键点：</p><ul><li>传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。</li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。</li><li>任何传给该主机IP地址的数据均送到环回接口。</li></ul><h3 id="6、最大传输单元MTU"><a href="#6、最大传输单元MTU" class="headerlink" title="6、最大传输单元MTU"></a>6、最大传输单元MTU</h3><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。<strong>链路层的这个特性称作MTU，最大传输单元</strong>。</p><p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU。</p><h3 id="7、路径MTU"><a href="#7、路径MTU" class="headerlink" title="7、路径MTU"></a>7、路径MTU</h3><p>如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作<strong>路径MTU</strong>。</p><p>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。RFC1191描述了怎么样确定MTU。</p><h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>本章讨论了Internet协议族中的最底层协议，链路层协议。我们比较了以太网和IEEE802.2/802.3的<strong>链路层封装格式</strong>，以及SLIP和PPP<strong>链路层协议</strong>。由于SLIP和PPP经常用于低速的链路，二者都提供了压缩不常变化的公共字段的方法。这使交互性能得到提高。</p><p>大多数的实现都提供环回接口。访问这个接口可以通过特殊的环回地址，一般为127.0.0.1。也可以通过发送IP数据报给主机所拥有的任一IP地址。当环回数据回到上层的协议栈中时，它已经过传输层和IP层完整的处理过程。</p><p>我们描述了很多链路都具有的一个重要特性，MTU，相关的一个概念是路径MTU。根据典型的串行线路MTU，对SLIP和CSLIP链路的传输时延进行了计算。本章的内容只覆盖了当今TCP/IP所采用的部分数据链路公共技术。TCP/IP成功的原因之一是它几乎能在任何数据链路技术上运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在TCP/IP协议族中，链路层主要有三个目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）为IP模块发送和接收IP数据报；   &lt;/li&gt;
&lt;li&gt;（2）为ARP模块发送ARP请求和接收ARP应答；&lt;/li&gt;
&lt;li&gt;（3）为RARP发送RARP请求和接收RARP应答。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。&lt;/p&gt;
&lt;p&gt;本节我们将详细讨论以太网链路层协议，两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。对MTU（最大传输单元）进行了介绍，这个概念在本书的后面章节中将多次遇到。我们还讨论了如何为串行线路选择MTU。&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://WenDeng.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="TCP/IP协议" scheme="http://WenDeng.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》第7章 仿函数（函数对象）和配接器</title>
    <link href="http://WenDeng.github.io/2019/05/22/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC7%E7%AB%A0%20%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89%E5%92%8C%E9%85%8D%E6%8E%A5%E5%99%A8/"/>
    <id>http://WenDeng.github.io/2019/05/22/c++基础/《STL源码剖析》第7章 仿函数（函数对象）和配接器/</id>
    <published>2019-05-22T10:50:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的仿函数(functor)，是通过重载()运算符模拟函数形为的类。因此，这里需要明确两点：</p><ul><li>1 仿函数不是函数，它是个类； </li><li>2 仿函数重载了()运算符，使得它的对你可以像函数那样子调用。 </li></ul><p>《Design Patterns》一书提到23个最普及的设计模式，其中对adapter样式的定义如下：<strong>将一个class的接口转换为另一个class 的接口，使原本因接口不兼容而不能合作的classes，可以一起运作</strong>。</p><a id="more"></a><h3 id="1、仿函数"><a href="#1、仿函数" class="headerlink" title="1、仿函数"></a>1、仿函数</h3><p>仿函数是早期的命名，C++标准规定所采用的新名称是函数对象。<strong>函数对象，如其名字一样是指一种具有函数特质的对象</strong>。调用者可以像函数一样的使用这些对象，但必须重载operator()，先产生类对象的一个匿名对象，再调用相应的函数。</p><p>例如在很多STL算法中，都可以看到，我们可以将一个方法作为模板内的参数传入到算法实现中，例如sort的时候我们可以根据我们传入的自定义的compare函数来进行比较排序。解决办法是使用函数指针，或者是将这个“操作”设计为一个所谓的仿函数，再用这个仿函数生成一个对象，并用这个对象作为算法的一个参数。</p><p><strong>那为什么STL不使用函数指针而使用仿函数呢？</strong><br>这主要是因为函数指针不能满足STL对抽象性的要求，<strong>无法和STL的其他组件搭配</strong>以产生更加灵活的效果。</p><h3 id="2、仿函数的可配接性"><a href="#2、仿函数的可配接性" class="headerlink" title="2、仿函数的可配接性"></a>2、仿函数的可配接性</h3><p>仿函数灵活性的关键就在于仿函数。<br>STL仿函数应该有能力被函数适配器修饰，就像积木一样串接，然而，为了拥有配接能力，每个仿函数都必须定义自己的<strong>函数参数类型和返回值类型</strong>，就像迭代器如果要融入整个STL大家庭，也必须按照规定定义自己的5个相应的类型一样。下面主要讲解一元函数和二元函数的基本的相关设计。</p><h4 id="2-1-unary-function"><a href="#2-1-unary-function" class="headerlink" title="2.1 unary_function"></a>2.1 unary_function</h4><p>用来呈现一元函数的参数类型和返回值类型，使用者实现对应的一元仿函数时只需继承这个类并进行事项即可。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="type">class Result&gt; //基类</span></span></span><br><span class="line">Struct unary_function</span><br><span class="line">&#123;</span><br><span class="line">    Typedef Arg argument_type;</span><br><span class="line">    Typedef Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义的一元仿函数可以继承上类来获得类型定义</span></span><br><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Struct negate:<span class="keyword">public</span> unary_function&lt;T,T&gt; <span class="comment">//取反</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span> &#123;<span class="keyword">return</span> –x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-binary-function"><a href="#2-2-binary-function" class="headerlink" title="2.2 binary_function"></a>2.2 binary_function</h4><p>用来呈现二元函数的第一个参数类型、第二个参数类型和返回值类型。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="type">class Arg2</span>, <span class="type">class Result&gt;</span></span></span><br><span class="line">Struct binary_function</span><br><span class="line">&#123;</span><br><span class="line">    Typedef Arg1 first_argument_type;</span><br><span class="line">    Typedef Arg2 second_argument_type;</span><br><span class="line">    Typedef Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Struct plus: <span class="keyword">public</span> binary_function&lt;T,T,T&gt;  <span class="comment">//用法示例，加运算</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)<span class="keyword">const</span> &#123;<span class="keyword">return</span> x+y ;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="3、几种仿函数"><a href="#3、几种仿函数" class="headerlink" title="3、几种仿函数"></a>3、几种仿函数</h3><ul><li><p>算术类仿函数<br>用于算术运算，包括加法：plus<t>，减法：minus<t>，乘法：multiplies<t>，除法：divides<t>，取模：modulus<t>，取反：negate<t>。</t></t></t></t></t></t></p></li><li><p>关系类仿函数<br>用于进行关系运算，包括等于：equal_to<t>，不等于：not_equal_to<t>，大于：greater<t>，大于等于：greater_equal<t>，小于：less<t>，小于等于：less_equal<t>。</t></t></t></t></t></t></p></li><li><p>逻辑类仿函数<br>提供几种逻辑运算，包括逻辑运算and：logical_and<t>，逻辑运算or：logical_or<t>，逻辑运算not：logical_not<t>。</t></t></t></p></li><li><p>证同(identity)、选择(select)、投射(project)<br>证同用于返回本身；选择用于接受一个pair,返回第一个元素或第二个元素；投射传回第一参数，忽略第二参数或相反。</p></li></ul><p><strong>来看一下他们的运用实例</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//算术类仿函数</span></span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; plusobj;</span><br><span class="line">minus&lt;<span class="keyword">int</span>&gt; minusobj;</span><br><span class="line">multiplies&lt;<span class="keyword">int</span>&gt; mulobj;</span><br><span class="line">divides&lt;<span class="keyword">int</span>&gt; divobj;</span><br><span class="line">modulus&lt;<span class="keyword">int</span>&gt; modobj;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; negobj;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//除下面的使用方式外，还可以用临时对象调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; plusobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minusobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//-2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mulobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//15</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; divobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; modobj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; negobj(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关系类仿函数，不等于：，大于：greater&lt;T&gt;，大于等于：greater_equal&lt;T&gt;，小于：less&lt;T&gt;，小于等于：less_equal&lt;T&gt;。</span></span><br><span class="line">equal_to&lt;<span class="keyword">int</span>&gt; equal_to_obj; </span><br><span class="line">not_equal_to&lt;<span class="keyword">int</span>&gt; not_equal_to_obj;</span><br><span class="line">greater&lt;<span class="keyword">int</span>&gt; greater_obj;</span><br><span class="line">greater_equal&lt;<span class="keyword">int</span>&gt; greater_equal_obj;</span><br><span class="line">less&lt;<span class="keyword">int</span>&gt; less_obj;</span><br><span class="line">less_equal&lt;<span class="keyword">int</span>&gt; less_equal_obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; equal_to_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; not_equal_to_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greater_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greater_equal_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; less_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; less_equal_obj(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑类仿函数</span></span><br><span class="line">logical_and&lt;<span class="keyword">int</span>&gt; logical_and_obj;</span><br><span class="line">logical_or&lt;<span class="keyword">int</span>&gt; logical_or_obj;</span><br><span class="line">logical_not&lt;<span class="keyword">int</span>&gt; logical_not_obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_and_obj(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_or_obj(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; logical_not_obj(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、配接器"><a href="#4、配接器" class="headerlink" title="4、配接器"></a>4、配接器</h3><p>配接器（Adapter）在STL组件的灵活组合运用功能上，<strong>扮演着轴承、转换器的角色</strong>，即将一个class的接口转换为另一个class的接口，使原本因接口不兼容而不能合作的classes，可以一起运作，它事实上<strong>是一种设计模式</strong>。</p><p>STL 主要提供如下三种配接器：</p><ul><li>（1）改变仿函数（functors）接口，称之为function adapter</li><li>（2）改变容器（containers）接口，称之位container adapter</li><li>（3）改变迭代器（iterators）接口者，称之为iterator adapter</li></ul><h4 id="4-1-容器配接器container-adapter"><a href="#4-1-容器配接器container-adapter" class="headerlink" title="4.1 容器配接器container adapter"></a>4.1 容器配接器container adapter</h4><p>STL 提供的两个容器queue和stack，其实都不过是一种配接器，是对deque （双端队列）接口的修饰而成就自己的容器风貌。queue和stack底层都是由deque构成的，它们封住所有deque对外接口，只开发符合对应原则的几个函数，故它们是适配器，是一个作用于容器之上的适配器。</p><p>如果按照该标准衡量其他容器的话，序列式容器的 set 和 map 其实是对其内部所维护的RB-tree接口的改造。</p><h4 id="4-2-迭代器配接器iterator-adapter"><a href="#4-2-迭代器配接器iterator-adapter" class="headerlink" title="4.2 迭代器配接器iterator adapter"></a>4.2 迭代器配接器iterator adapter</h4><p>STL提供了许多应用于迭代器身上的配接器，包括<strong>insert iterators，reverse iterators，iostream iterators</strong>。</p><p>insert iterators可以将一般迭代器的赋值操作转变为插入操作。此迭代器包括专门从尾端插入操作back_insert_iterator，专门从头端插入操作front_insert_iterator，以及可从任何位置执行插入操作的insert_iterator。因iterator adapters使用接口不是十分直观，STL提供三个相应的函数back_inserter()、front_inserter()、inserter()，从而提高使用时的便利性。</p><p>reverse iterators可以将一般迭代器的行进方向逆转，使原本应该前进的operator++变成了后退操作，使原本应该后退的operator–变成了前进操作。此操作用在“从尾端开始进行”的算法上，有很大的方便性。</p><p>iostream iterators可以将迭代器绑定到某个iostream对象身上。绑定到istream对象身上，为istream_iterator，拥有输入功能；绑定到ostream对象身上，成为ostream_iterator，拥有输出功能。此迭代器用在屏幕输出上，非常方便。</p><h4 id="4-3-functor配接器functor-adapter"><a href="#4-3-functor配接器functor-adapter" class="headerlink" title="4.3 functor配接器functor adapter"></a>4.3 functor配接器functor adapter</h4><p>functor adapters是所有配接器中数量最庞大的一个族群，其配接灵活度是后两者不能及的，可以配接、配接、再配接。其中配接操作包括系结（bind）、否定（negate）、组合（compose）、以及对一般函数或成员函数的修饰（使其成为一个仿函数）。它的价值在于，通过它们之间的绑定、组合、修饰能力，几乎可以无限制地创造出各种可能的表达式（expression），搭配STL算法一起演出。</p><p>由于仿函数就是“将function call操作符重载”的一种class，而任何算法接受一个仿函数时，总是在其演算过程中调用该仿函数的operator()，这使得不具备仿函数之形、却有真函数之实的“一般函数”和“成员函数（member functions）感到为难。<strong>如果”一般函数“和“成员函数”不能纳入复用的体系中，则STL的规划将崩落了一角</strong>。为此，STL提供了为数众多的配接器，使“一般函数”和“成员函数”得以无缝地与其他配接器或算法结合起来。</p><p>所有期望获取配接能力的组件，本身都必须是可配接的，即一元仿函数必须继承自unary_function，二元仿函数必须继承自binary_function，成员函数必须以mem_fun处理过，一般函数必须以ptr_fun处理过。</p><p><strong>一个未经ptr_fun处理过的一般函数，虽然也可以函数指针的形式传给STL算法使用，却无法拥有任何配接能力</strong>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下配接器其实就是把一个一元函数指针包起来；</span></span><br><span class="line"><span class="comment">// 当仿函数被使用时，就调用该函数指针</span></span><br><span class="line">template &lt;class <span class="variable">_Arg</span>, class <span class="variable">_Result</span>&gt;</span><br><span class="line">class pointer_to_unary_function : public unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">  <span class="variable">_Result</span> (*<span class="variable">_M_ptr</span>)(<span class="variable">_Arg</span>);     <span class="comment">// 内部成员，一个函数指针</span></span><br><span class="line">public:</span><br><span class="line">  pointer_to_unary_function() &#123;&#125;</span><br><span class="line">  <span class="comment">// 以下constructor将函数指针记录于内部成员之中</span></span><br><span class="line">  explicit pointer_to_unary_function(<span class="variable">_Result</span> (*<span class="variable">__x</span>)(<span class="variable">_Arg</span>)) : <span class="variable">_M_ptr</span>(<span class="variable">__x</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 通过函数指针执行函数</span></span><br><span class="line">  <span class="variable">_Result</span> operator()(<span class="variable">_Arg</span> <span class="variable">__x</span>) const &#123; return <span class="variable">_M_ptr</span>(<span class="variable">__x</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，使我们能够方便运用pointer_to_unary_function</span></span><br><span class="line">template &lt;class <span class="variable">_Arg</span>, class <span class="variable">_Result</span>&gt;</span><br><span class="line">inline pointer_to_unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt; ptr_fun(<span class="variable">_Result</span> (*<span class="variable">__x</span>)(<span class="variable">_Arg</span>))</span><br><span class="line">&#123;</span><br><span class="line">  return pointer_to_unary_function&lt;<span class="variable">_Arg</span>, <span class="variable">_Result</span>&gt;(<span class="variable">__x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h3><p>本节主要介绍仿函数和配接器这两种思想，二者的主要的目的都是粘合STL的另外三大组件容器、迭代器和算法，理解其意，思而用之，也必能有所收益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓的仿函数(functor)，是通过重载()运算符模拟函数形为的类。因此，这里需要明确两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 仿函数不是函数，它是个类； &lt;/li&gt;
&lt;li&gt;2 仿函数重载了()运算符，使得它的对你可以像函数那样子调用。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《Design Patterns》一书提到23个最普及的设计模式，其中对adapter样式的定义如下：&lt;strong&gt;将一个class的接口转换为另一个class 的接口，使原本因接口不兼容而不能合作的classes，可以一起运作&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C++基础" scheme="http://WenDeng.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="STL源码" scheme="http://WenDeng.github.io/tags/STL%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《TCP-IP详解卷1》第1章 概述</title>
    <link href="http://WenDeng.github.io/2019/05/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%E3%80%8B%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0%20%20/"/>
    <id>http://WenDeng.github.io/2019/05/22/网络协议/《TCP-IP详解卷1》第1章 概述  /</id>
    <published>2019-05-22T09:29:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP起源于60年代末美国政府资助的一个分组交换网络研究项目。到90年代已发展成为计算机之间最常应用的组网形式。它是一个真正的开放系统，因为协议族的定义及其多种实现可以不用花钱或者花很少的钱就可以公开的得到。它成为被称作”全球互联网”或”因特网”的基础，该广域网（WAN）已包含超过100万台遍布世界各地的计算机。<br><a id="more"></a></p><h3 id="1、分层"><a href="#1、分层" class="headerlink" title="1、分层"></a>1、分层</h3><p>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层协议系统，如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/28.png?raw=true" alt="image"></p><p>每一层负责不同的功能：</p><ul><li>链路层：有时也称作数据链路层或网络接口层。通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆的物理接口细节。</li><li>网络层：有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Interner组管理协议）。</li><li>运输层：主要为两台主机上的应用程序提供<strong>端到端</strong>的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</li><li>应用层：负责处理特定的应用程序细节。常见的应用程序如：Telnet远程登录、 FTP文件传输协议、SMTP简单邮件传送协议。</li></ul><h3 id="2、路由器"><a href="#2、路由器" class="headerlink" title="2、路由器"></a>2、路由器</h3><p>人们又把多个网络连在一起形成一个网络的网络，或称作互连网。一个互连网（Internet）就是一组通过相同协议族互连在一起的网络。</p><p>构成互连网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒。路由器的好处是为不同类型的物理网络提供连接：以太网，令牌环网，点对点的链接和FDDI（光纤分布式数据接口）等等。</p><p>注意，历史上这些盒子称作网关（gateway）,<strong>但现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）</strong>。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/29.png?raw=true" alt="image"></p><p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快的把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重发，发送和接受端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p><p>任何具有多个接口的系统，英文都称作是多接口的。一个主机也可以有多个接口，但一般不称做路由器，除非它的功能只是单纯地把分组从一个接口传送到另一个接口。同样，路由器并不一定指那种在互联网中用来转发分组的特殊硬件盒。</p><p>连接网络的另一个途径是使用网桥。<strong>网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连</strong>。网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网。<strong>TCP/IP倾向于使用路由器而不是网桥来连接网络</strong>。</p><h3 id="3、TCP-IP的分层"><a href="#3、TCP-IP的分层" class="headerlink" title="3、TCP/IP的分层"></a>3、TCP/IP的分层</h3><p>在TCP/IP协议族中有很多种协议，下图是TCP/IP协议族中不同层次的协议：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/30.png?raw=true" alt="image"></p><p>TCP和UDP是两种最为著名的运输层协议，二者都是用IP作为网络层协议。</p><p>虽然TCP使用不可靠的IP服务，但它却提供一种可靠的运输层服务。UDP为应用程序发送和接受数据报。一个数据报是指从发送方传输到接收方的一个信息单元。但是与TCP不同的是，UDP是不可靠的，它不能保证数据报能安全无误的到达最终目的。</p><p>ICMP是IP协议的附属协议。IP层用它来与其它主机或路由器交换错误报文和其它重要信息。IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p><p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><h3 id="4、互联网的地址"><a href="#4、互联网的地址" class="headerlink" title="4、互联网的地址"></a>4、互联网的地址</h3><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址具有一定的结构，五类不同的互连网地址格式如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/31.png?raw=true" alt="image"></p><p>这些32位的地址通常写成4个十进制的数，其中每个整数对应一个字节。这种表示方法称作”点分十进制表示法”。</p><h4 id="4-1-A类地址"><a href="#4-1-A类地址" class="headerlink" title="4.1 A类地址"></a>4.1 A类地址</h4><ul><li>⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。   </li><li>⑵ A类地址范围：0.0.0.0 - 127.255.255.255   </li><li>⑶ A类地址中的私有地址和保留地址：              </li><li><ul><li>10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。      </li></ul></li><li><ul><li>127.X.X.X是保留地址，用做循环测试用的。</li></ul></li></ul><h4 id="4-2-B类地址"><a href="#4-2-B类地址" class="headerlink" title="4.2 B类地址"></a>4.2 B类地址</h4><ul><li>⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址,但要扣除全0和全1的主机号。 </li><li>⑵ B类地址范围：128.0.0.0 - 191.255.255.255 </li><li>⑶ B类地址的私有地址和保留地址 </li><li><ul><li>B类网络地址128.0.0.0是不指派的，所以指派的B类最小网络地址是128.1.0.0。</li></ul></li><li><ul><li>169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</li></ul></li></ul><h4 id="4-3-C类地址"><a href="#4-3-C类地址" class="headerlink" title="4.3 C类地址"></a>4.3 C类地址</h4><ul><li>⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个个字节为主机地址。另外第1个字节的前三位固定为110。 </li><li>⑵ C类地址范围：192.0.0.1—223.255.255.254。 </li><li>⑶ C类地址中的私有地址：<br>192.168.X.X是私有地址。</li></ul><h4 id="4-4-D类地址"><a href="#4-4-D类地址" class="headerlink" title="4.4 D类地址"></a>4.4 D类地址</h4><ul><li>⑴ D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110。 </li><li>⑵ D类地址范围：224.0.0.1—239.255.255.254</li></ul><h4 id="4-5-E类地址"><a href="#4-5-E类地址" class="headerlink" title="4.5 E类地址"></a>4.5 E类地址</h4><ul><li>⑴ E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110。 </li><li>⑵ E类地址范围：240.0.0.1—255.255.255.254</li></ul><p>全零0.0.0.0地址对应于当前主机。全“1”的IP地址255.255.255.255是当前子网的广播地址。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255      </p><h3 id="5、域名系统"><a href="#5、域名系统" class="headerlink" title="5、域名系统"></a>5、域名系统</h3><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机。但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p><p>任何一个应用程序都可以调用一个标准的<strong>库函数</strong>来查看给定名字的主机的IP地址。类似地，系统还提供一个逆函数—给定主机的IP地址，查看它所对应的主机名。大多数使用主机名作为参数的应用程序也可以把IP地址作为参数。</p><h3 id="6、封装"><a href="#6、封装" class="headerlink" title="6、封装"></a>6、封装</h3><p>当应用程序使用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当做一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），下图描述了数据进入协议栈时的封装过程：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/32.png?raw=true" alt="image"></p><p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段，IP传给网络接口层的数据单元称作IP数据报。通过以太网传输的比特流称作帧（Frame）。</p><p>UDP数据和TCP数据基本一致。唯一的不同是UDP传给IP的数据单元称作UDP数据报，而且UDP的首部长为8字节。</p><p>IP在首部中存入一个长度为8位的数值，称作协议域。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。TCP和UDP都用一个16位的端口号来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。<br>网络接口分别要发送和接收IP，ARP，RARP数据，因此也必须在以太网的帧首部中加入某种形式的标识，以指明生成数据的网络层协议。</p><h3 id="7、分用"><a href="#7、分用" class="headerlink" title="7、分用"></a>7、分用</h3><p>当目的主机接收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用，如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71/33.png?raw=true" alt="image"></p><p>协议ICMP和IGMP定位一直是一件很棘手的事情。通常我们把它们和IP放在同一层上，因为它们是IP的附属协议。但是在这里，我们又把它们放在IP层的上面，因为ICMP和IGMP报文都被封装在IP数据报中。</p><h3 id="8、客户-服务器模型"><a href="#8、客户-服务器模型" class="headerlink" title="8、客户-服务器模型"></a>8、客户-服务器模型</h3><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供一些特定的服务。</p><p>可以将这种服务分为两种类型：重复型和并发型。重复型服务器阻塞依次完成各个服务；而并发型服务器则通过创建一个新的进程、任务或线程来处理服务，可以同时为多个客户服务。</p><h3 id="9、端口号"><a href="#9、端口号" class="headerlink" title="9、端口号"></a>9、端口号</h3><p>前面已经指出过，TCP和UDP采用16位的端口号来识别应用程序。</p><p>服务器一般都是通过知名端口号来识别的。例如FTP的端口号为21；Telnet的TCP端口号为23；TFTP的端口号为69。任何TCP/IP实现所提供的服务都用知名的1~1023之间的端口号。这些知名端口号由Internet号分配机构（IANA）来管理。</p><h3 id="10、标准化过程"><a href="#10、标准化过程" class="headerlink" title="10、标准化过程"></a>10、标准化过程</h3><p>所有关于Internet的正式标准都以RFC文档出版。另外，大量的RFC并不是正式的标准，出版只是为了提供信息。RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC1122，数字越大说明RFC的内容越新。</p><h3 id="11、互联网"><a href="#11、互联网" class="headerlink" title="11、互联网"></a>11、互联网</h3><p>internet这个词第一个字母是否大写决定了它具有不同的含义。internet意思是用一个共同的协议族把多个网络连接起来。而Internet指的是世界范围内通过TCP/IP互相通信的所有主机集合。Internet是一个internet，但internet不等于Internet。</p><h3 id="12、小结"><a href="#12、小结" class="headerlink" title="12、小结"></a>12、小结</h3><p>TCP/IP协议族分为四层：链路层，网络层，运输层，应用层，每一层各有不同的责任。在TCP/IP中，网络层和运输层之间的区别是最为关键的：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。</p><p>一个互连网是网络的网络。构建互连网的共同基石是路由器，它们在IP层把网络连在一起。第一个字母大写的Internet是指分布在世界各地的大型互连网，其中包括1万多个网络和超过100万台主机。</p><p>在一个互联网上，每个接口都用IP地址来标识。尽管用户习惯使用主机名而不是IP地址。域名系统为主机名和IP地址之间提供动态的映射。端口号用来标识互相通信的应用程序。服务器使用知名端口号，而客户使用临时设定的端口号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP/IP起源于60年代末美国政府资助的一个分组交换网络研究项目。到90年代已发展成为计算机之间最常应用的组网形式。它是一个真正的开放系统，因为协议族的定义及其多种实现可以不用花钱或者花很少的钱就可以公开的得到。它成为被称作”全球互联网”或”因特网”的基础，该广域网（WAN）已包含超过100万台遍布世界各地的计算机。&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://WenDeng.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="TCP/IP协议" scheme="http://WenDeng.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>4.约瑟夫环问题</title>
    <link href="http://WenDeng.github.io/2019/05/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://WenDeng.github.io/2019/05/22/算法与数据结构/4.约瑟夫环问题/</id>
    <published>2019-05-22T02:14:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。人都有求生的欲望，问谁是最后一个死？<br><a id="more"></a></p><h3 id="1、题目：孩子们的游戏（圆圈中最后剩下的数）"><a href="#1、题目：孩子们的游戏（圆圈中最后剩下的数）" class="headerlink" title="1、题目：孩子们的游戏（圆圈中最后剩下的数）"></a>1、题目：孩子们的游戏（圆圈中最后剩下的数）</h3><hr><blockquote><p>题目原链接：<a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p></blockquote><h3 id="2、题目描述"><a href="#2、题目描述" class="headerlink" title="2、题目描述"></a>2、题目描述</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h3 id="3、解题思路"><a href="#3、解题思路" class="headerlink" title="3、解题思路"></a>3、解题思路</h3><h4 id="解法一：循环链表模拟解决"><a href="#解法一：循环链表模拟解决" class="headerlink" title="解法一：循环链表模拟解决"></a>解法一：循环链表模拟解决</h4><p>既然是一个圆圈，我们很自然就能想到用一个环形链表来进行模拟。创建一个共有n个节点的环形链表， 依次遍历链表删除节点第m个节点，然后继续遍历直到链表中只有一个节点为止。需要注意的是，每一次到达链表尾端的时候都将指针调整到指向第一个节点，从而形成环。</p><p>为了能快速实现代码，用标准模板库的std::list实现就是一个很好的选择。这种解决方案没删除一个数需要遍历m次，所以时间复杂度为O(mn),空间复杂度为O(n)。实现代码如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> LastRemaining_Solution(<span class="built_in">int</span> n, <span class="built_in">int</span> m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span> ||n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        list&lt;<span class="built_in">int</span>&gt; <span class="keyword">number</span>;</span><br><span class="line">        <span class="built_in">int</span> i,cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        for(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">number</span>.push_back(i);</span><br><span class="line">        list&lt;<span class="built_in">int</span>&gt;::iterator iter=<span class="keyword">number</span>.begin();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">number</span>.<span class="built_in">size</span>()<span class="comment">!=1)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==m-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">number</span>.erase(iter++);</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> iter++,cnt++;</span><br><span class="line">            <span class="keyword">if</span>(iter==<span class="keyword">number</span>.<span class="keyword">end</span>()) iter=<span class="keyword">number</span>.begin(); //调整</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">number</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="解法二：数学分析、寻找规律"><a href="#解法二：数学分析、寻找规律" class="headerlink" title="解法二：数学分析、寻找规律"></a>解法二：数学分析、寻找规律</h4><p>假设现在有6个人，计数为3，则：<br><strong>（1）第一次删除</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编号： <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">计数： <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以看出，第一次选中去掉第3个人，编号2。</p><p><strong>（2）第二次删除</strong><br>剩下的人从新编号：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原编号：    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">第一次编号：<span class="number">3</span> <span class="number">4</span> X <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>  =&gt;  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">计数：                      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>可以看出，第二次选中去掉新编号中的第3个人，新编号为2，同时也知道原编号为5。</p><p><strong>（3）第5（n-1）次删除</strong><br>到第5次删除的时候后，将只剩下一个数，即是我们要求的数：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原编号：    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">第一次编号：<span class="number">3</span> <span class="number">4</span> X <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line">第二次编号：<span class="number">0</span> <span class="number">1</span> X <span class="number">0</span> <span class="number">2</span> X </span><br><span class="line">第三次编号：<span class="number">1</span> <span class="number">2</span> X X <span class="number">0</span> X </span><br><span class="line">第四次编号：<span class="number">1</span> X X X <span class="number">0</span> X =&gt; <span class="number">0</span> <span class="number">1</span></span><br><span class="line">计数：                  (<span class="number">0</span>)<span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>可以看出第5次删除选中了第4次编号的第1个人，编号为0，对应的原编号为4。</p><p>从上面的关系中，我们可以看出，每一次的新编号和上次的编号之间存在映射关系：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_number=(old_number-m)%上次编号总人数    </span><br><span class="line">=&gt; old_number=(new_number+m)%上次编号总人数</span><br></pre></td></tr></table></figure></p><p><strong>由于最后只剩下一个人，其new_number明显应该为0，我们可以=&gt;其第四次编号为1=&gt;其第三次编号为1=&gt;其第二次编号为0=&gt;其第一次编号为3=&gt;原编号为0</strong>。故最后剩下的人为第1个，编号为0。</p><p>实现代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//考虑异常情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;<span class="comment">//最后剩下的数新编号为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result=(result+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。人都有求生的欲望，问谁是最后一个死？&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://WenDeng.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="约瑟夫环问题" scheme="http://WenDeng.github.io/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>第9章 虚拟内存之Linux内存系统</title>
    <link href="http://WenDeng.github.io/2019/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8BLinux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
    <id>http://WenDeng.github.io/2019/05/22/操作系统/第9章 虚拟内存之Linux内存系统/</id>
    <published>2019-05-21T16:32:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>本节按照书籍实例，用一个实际系统的案例研究来总结虚拟内存的讨论，这是一个运行于Linux的Inter Core i7。需要注意的是，虽然我们说64位系统，而且处理器体系也允许64位的虚拟地址空间，但是<strong>实际上，Core i7现在只是支持48位（256TB）虚拟地址空间和52位（4PB）物理地址空间，兼容支持32位（4GB）地址空间</strong>。</p><a id="more"></a><h3 id="1、Core-i7-内存系统结构"><a href="#1、Core-i7-内存系统结构" class="headerlink" title="1、Core i7 内存系统结构"></a>1、Core i7 内存系统结构</h3><p>Core i7的内存系统的结构如下：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/21.png?raw=true" alt></p><p>由图可知：</p><ul><li>处理器包括4个核、所有核共享L3高速缓存和DDR3内存控制器。</li><li>每个核包含一个层次结构的TLB、一个层次结构的指令高速缓存，以及一组快速的点到点链路，这种QuickPath技术用于与其他核和外部I/O桥直接通信。</li><li>TLB是虚拟寻址的，四路组相联。L1、L2和L3都是物理寻址，分别位8、8和16路组相联。</li><li>Linux使用的是4KB的页。</li></ul><h3 id="2、Core-i7-地址翻译过程"><a href="#2、Core-i7-地址翻译过程" class="headerlink" title="2、Core i7 地址翻译过程"></a>2、Core i7 地址翻译过程</h3><p>翻译过程如图9-22：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/22.png?raw=true" alt></p><p>由图可知Core i7的地址翻译采用了TLB、高速缓存、多级页表等机制，需要注意的是：</p><ul><li>Core i7采用四级页表层次结构。同时每个进程都有它自己的页表层次结构。</li><li>进程运行时，虽然允许页表换进换出，但是与分配了的页相关联的页表都是驻留在内存中的。</li><li><strong>CR3控制器</strong>指向第一级页表的起始地址，<strong>CR3的值是每个进程上下文的一部分，每次上下文切换时，CR3的值都会被恢复</strong>。</li></ul><h3 id="3、第四级页表条目"><a href="#3、第四级页表条目" class="headerlink" title="3、第四级页表条目"></a>3、第四级页表条目</h3><p>图9-24给出了第四级页表中条目的格式：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/23.png?raw=true" alt></p><p>注意一下几点：</p><ul><li>PTE（page table entry）有三个权限位，控制对页的访问，分别是R/W控制读写，U/S是否能在用户模式中访问，XD（禁止执行），禁止从某些内存页取指令，防止缓冲区溢出攻击。</li><li>MMU翻译虚拟地址时，还会更新另外两个内核缺页处理程序会用到的位。A位称为引用位，内核用这个引用位来实现它的页替换算法。<strong>D位（修改位/脏位），告诉内核在复制替换页之前是否必须写回牺牲页</strong>。</li></ul><p>图9-25给出Core i7如何使用四级页表来将虚拟地址翻译成物理地址的。36位VPN被划分为四个9位的片，每个片被用作到一个页表的偏移量，CR3寄存器（控制寄存器3）包含L1页表的物理地址。VPN1提供到一个L1 PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供一个到L2 PTE的偏移量，以此类推。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/24.png?raw=true" alt></p><p><strong>优化地址翻译</strong><br>当CPU需要翻译个虚拟地址时，它就发送一VPN到MMU,发送VPO到高速L1缓存。当MMU向TLB请求一个页表条目时，L1高速缓存正忙着利用VPO位查找对应的组，并读取这个组里的8个标记和相应的数据字。然后等MMU拿到PPN后直接就可以和8个标记进行匹配，决定是否取出其中的值。</p><h3 id="4、Linux虚拟内存系统"><a href="#4、Linux虚拟内存系统" class="headerlink" title="4、Linux虚拟内存系统"></a>4、Linux虚拟内存系统</h3><p>本节主要是了解一个实际的操作系统如何组织虚拟内存和处理缺页。</p><p>Linux为每个进程维护了一个单独的虚拟地址空间如图9-26：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/25.png?raw=true" alt></p><p><strong>进程地址空间分为内核虚拟内存和进程虚拟内存</strong>。</p><ul><li><strong>进程虚拟内存</strong>包括进程的代码和数据段、堆和共享库以及栈段。</li><li><strong>内核虚拟内存</strong>包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构，有趣的是，linux也将一组连续的虚拟页面（大小等于DRAM）映射到相应的一组连续的物理页面，为内核提供了便利的方法来访问物理内存中的任何特定位置</li><li><strong>内核虚拟内存</strong>的其他区域包含每个进程都不相同的数据，比如说页表和内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</li></ul><h4 id="4-1-linux虚拟内存区域"><a href="#4-1-linux虚拟内存区域" class="headerlink" title="4.1 linux虚拟内存区域"></a>4.1 linux虚拟内存区域</h4><p>Linux将虚拟内存组织成一些区域（也叫做段）的集合。一个区域（area）就是已经存在着的（已分配的）虚拟内存的连续片。例如，代码段，数据段，堆，共享库段，以及用户栈都是不同的区域。</p><p>每个存在虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在，并且不能被进程引用。区域的概念很重要，因为它允许虚拟地址空间有间隙。内核不用记录那些不存在的虚拟页，而这样的页也不占用内存、磁盘或者内存本身中的任何额外资源。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/26.png?raw=true" alt></p><p>如上图，内核为系统中的每个进程维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID，指向用户栈的指针，可执行目标文件的名字，以及程序计数器）。</p><p>任务结构中的一个条目指向mm_struct,它描述了虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向第一级页表（页全局目录）的基址，而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。</p><h4 id="4-2-linux缺页异常处理"><a href="#4-2-linux缺页异常处理" class="headerlink" title="4.2 linux缺页异常处理"></a>4.2 linux缺页异常处理</h4><p>假设MMU在试图翻译莫格虚拟地址A时，触发了一个缺页，这个异常导致控制转移到内核的缺页处理程序，进行如下处理：</p><ul><li>（1）判断虚拟地址A是合法的吗？是在某个区域结构定义的区域内吗？缺页处理程序搜索区域结构链表（在链表中构建树来查找），如果不合法，触发一个段错误，终止进程。对应图中情况1</li><li>（2）试图进行的内存访问是否合法？权限对吗？对应图中情况2</li><li>（3）如果是对合法虚拟地址的合法操作，那么就选择一个牺牲页面，如果这个牺牲页面被修改过，就将它交换出去，换入新的页面并更新页表。</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/27.png?raw=true" alt></p><h3 id="5、内存映射"><a href="#5、内存映射" class="headerlink" title="5、内存映射"></a>5、内存映射</h3><p> <strong>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射</strong>。虚拟内存区域可以映射到两种类型的对象中的一种：</p><ul><li><p>Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行的目标文件。文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以<strong>这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面</strong>。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</p></li><li><p>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页面表，将该页面标记为是驻留在内存中的。<strong>注意在磁盘和内存之间并没有实际的数据传送</strong>。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</p></li></ul><p>无论哪种情况下，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。<strong>交换文件</strong>也叫作交换空间或者交换区域。需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p><h3 id="6、再看共享对象"><a href="#6、再看共享对象" class="headerlink" title="6、再看共享对象"></a>6、再看共享对象</h3><p>通过内存映射，一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私用对象。</p><h4 id="6-1-共享对象"><a href="#6-1-共享对象" class="headerlink" title="6.1 共享对象"></a>6.1 共享对象</h4><p>一个进程将共享对象映射到它的虚拟空间的一个区域内，那么这个进程对这个区域的所有写操作，对于那些也把这个共享对象映射到它们虚拟空间内的进程来说，都是可见的。这些变化也都会反映在磁盘的原始对象中，多个进程通过将内存映射和将页表条目指向相同的物理页面实现贡献对象，此时<strong>物理内存中只需要存放共享对象的一个副本</strong>。</p><h4 id="6-2-私有对象写时复制（COW）"><a href="#6-2-私有对象写时复制（COW）" class="headerlink" title="6.2 私有对象写时复制（COW）"></a>6.2 私有对象写时复制（COW）</h4><p>私有对象采用的是写时复制(copy on write)，一个私有对象开始生命周期的方式基本和共享对象一样，在物理内存上只保留一份副本。</p><p>对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。</p><p>一个进程试图写私有区域内的某个页面，那<strong>么这个写操作就会触发一个保护故障</strong>，故障处理程序会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新副本，然后恢复这个页面的可写权限，如下图所示。之后重新执行这个写指令，则写操作可以正常执行。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/28.png?raw=true" alt></p><p><strong>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分的使用了稀有的物理存储器</strong>。</p><h3 id="7、再看fork函数"><a href="#7、再看fork函数" class="headerlink" title="7、再看fork函数"></a>7、再看fork函数</h3><p>fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的？</p><p>当fork函数被当前进程调用时，内核为新进程创建了各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页表都标记为只读，并将两个进程中的区域结构都标记为私有(设置vm_flags)的写时拷贝。</p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中任一个后来进行写操作时，写时拷贝机制就会创建新页表，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h3 id="8、再看execve函数"><a href="#8、再看execve函数" class="headerlink" title="8、再看execve函数"></a>8、再看execve函数</h3><p>假设运行在当前进程中的程序执行了如下的调用：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">execve("a.out",</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">);</span></span><br></pre></td></tr></table></figure></p><p>execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li>映射私有区域。为新程序的文本、数据、bss（映射到匿名文件）和栈区域创建新的区域结构。所有这些新的区域都是私有的，写时拷贝的。</li><li>映射共享区域。如果a.out程序与共享对象或目标链接，比如标准库，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域中。</li><li>设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><h3 id="9、使用mmap函数的用户级内存映射"><a href="#9、使用mmap函数的用户级内存映射" class="headerlink" title="9、使用mmap函数的用户级内存映射"></a>9、使用mmap函数的用户级内存映射</h3><p>mmap函数为我们在进程的虚拟空间开辟一块新的虚拟内存，可以将一个对象（如文件）映射到这块新的虚拟内存，所以操作新的虚拟内存就是操作这个文件，下面我将介绍mmap函数的运用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>各个参数的意义如下：</p><ul><li>start表示新的虚拟内存从这个地址开始，一般来说取NULL，那么将有内核来分配。</li><li>length表示新的虚拟内存的大小。</li><li>prot表示这块新的虚拟内存的访问权限：<br>PROT_EXEC:可执行<br>PROT_READ:可读<br>PROT_WRITE:可写<br>PROT_NONE:无法访问</li><li>flags标识被映射对象匿名对象、私有对象或共享对象。</li></ul><p>eg:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufp=Mmap(<span class="literal">NULL</span>,size,PROT_READ,MAP_PRIVATE<span class="string">|MAP_ANON,0,0);</span></span><br></pre></td></tr></table></figure></p><p>表示让内核创建一个新的包含size字节的只读、私有、请求二进制0的虚拟内存区域。如果调用成功，那么bufp包含新区域的地址。</p><p>munmap用于删除虚拟内存的区域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节按照书籍实例，用一个实际系统的案例研究来总结虚拟内存的讨论，这是一个运行于Linux的Inter Core i7。需要注意的是，虽然我们说64位系统，而且处理器体系也允许64位的虚拟地址空间，但是&lt;strong&gt;实际上，Core i7现在只是支持48位（256TB）虚拟地址空间和52位（4PB）物理地址空间，兼容支持32位（4GB）地址空间&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第9章 虚拟内存</title>
    <link href="http://WenDeng.github.io/2019/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://WenDeng.github.io/2019/05/21/操作系统/第9章 虚拟内存/</id>
    <published>2019-05-21T15:14:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>为了更有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟内存</strong>(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的俺没交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟地址内存提供了三个重要的能力:</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li><li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ul><a id="more"></a><h3 id="1、物理和虚拟地址"><a href="#1、物理和虚拟地址" class="headerlink" title="1、物理和虚拟地址"></a>1、物理和虚拟地址</h3><p>计算机系统的<strong>主存</strong>被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一<strong>地物理地址</strong>(Physical Address, PA)。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，以此类推。给这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>。</p><p>早期的PC使用物理地址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。然而现代处理器使用的是一种称为<strong>虚拟寻址</strong>的寻址形式。如下图：</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/7.png?raw=true" alt></p><p>使用虚拟寻址，CPU通过生成一个<strong>虚拟地址</strong>(Virtual Address, VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做<strong>内存管理单元</strong>(Memory Management Unit， MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h3 id="2、地址空间"><a href="#2、地址空间" class="headerlink" title="2、地址空间"></a>2、地址空间</h3><p>在一个带虚拟内存的系统中，CPU从一个有N=2^n个地址的地址空间中生成虚拟地址，这个地址空间被称为<strong>虚拟地址空间</strong>。一个地址空间的大小由表示表示最大地址所需要的位数来描述，可以把前面这个由N个虚拟地址组成的虚拟空间叫做一个<strong>n位地址空间</strong>。现代系统通常支持32位或者64位虚拟地址空间。</p><p>一个系统还有一个物理地址空间，内存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><h3 id="3、虚拟内存作为缓存的工具"><a href="#3、虚拟内存作为缓存的工具" class="headerlink" title="3、虚拟内存作为缓存的工具"></a>3、虚拟内存作为缓存的工具</h3><p> <strong>概念上</strong>而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一地虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其它缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。</p><p> VM系统通过将虚拟内存分割为称为<strong>虚拟页</strong>(Virtual Page， VP)的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^p字节。类似地，物理内存被分割为<strong>物理页</strong>(Physical Page，PP)，大小也为P字节(物理页也被称为页帧)。</p><p>在任意时刻，虚拟页面的集合都分为三个不想交的子集:</p><ul><li>未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的： 未缓存在物理内存中的已分配页。</li></ul><h4 id="3-1-DRAM缓存的组织结构"><a href="#3-1-DRAM缓存的组织结构" class="headerlink" title="3.1 DRAM缓存的组织结构"></a>3.1 DRAM缓存的组织结构</h4><p>术语SRAM缓存用来表示位于CPU和主存之间的的L1、L2和L3高速缓存，DRAM用来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p><p>在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。回想一下，DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100 000多倍。一次DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵的多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的。而且，从磁盘的第一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节慢大约100 000倍。（后续字节被缓存在主存中）</p><p> 因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。因为大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。同时不命中时的替换策略也很重要，故与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更加精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是写直达。</p><h4 id="3-2-页表"><a href="#3-2-页表" class="headerlink" title="3.2 页表"></a>3.2 页表</h4><p>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。</p><p> 这些功能是由软硬件联合提供的，包括<strong>操作系统软件</strong>、<strong>MMU(内存管理单元)中的地址翻译硬件</strong>和一个存放在物理内存中叫做<strong>页表</strong>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读 取页表。操作系统负责维护页表内容，以及在磁盘与DRAM之间来回传送页。</p><p> 下图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目</strong>(Page Table Entry， PTE)的数组。虚拟地址空间中的每个页中一个固定偏移量处都有一个PTE。假设每个PTE都由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始地址。如果没有设置有效位，那么一个空地址表示这个虚拟页还未分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/8.png?raw=true" alt></p><p>上图展示了一个有8个虚拟页和4个物理页的系统的页表。四个虚拟页(VP1、VP2、VP4和VP7)当前被缓存在DRAM中。两个页(VP0和VP5)还未被分配，而剩下的页(VP3和VP6)已经被分配了，但是当前还未被缓存。</p><h4 id="3-3-页命中"><a href="#3-3-页命中" class="headerlink" title="3.3 页命中"></a>3.3 页命中</h4><p>考虑一下当CPU想要读包含在VP2中的虚拟内存的一个字时会发生什么，VP2被缓存在DRAM中。使用地址翻译技术，地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存中的了。所以它使用PTE中的物理内存地址(该地址指向PP1中缓存页的起始位置)，构造出这个字的物理地址。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/9.png?raw=true" alt></p><h4 id="3-4-缺页"><a href="#3-4-缺页" class="headerlink" title="3.4 缺页"></a>3.4 缺页</h4><p>在虚拟内存的习惯说法中，缓存不命中称为<strong>缺页</strong>。下图展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/10.png?raw=true" alt></p><p>接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。<strong>当异常处理程序返回时，它会重新启动导致缺页的指令</strong>，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。下图展示了在缺页之后我们的示例页表的状态。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/11.png?raw=true" alt></p><h4 id="3-5-分配页面"><a href="#3-5-分配页面" class="headerlink" title="3.5 分配页面"></a>3.5 分配页面</h4><p>当我们调用malloc等分配一个新的虚拟页VP5时，主要是在磁盘上创建空间并更新PTE5，使它指向这个新创建的页面。</p><h4 id="3-6-又是局部性救了我们"><a href="#3-6-又是局部性救了我们" class="headerlink" title="3.6 又是局部性救了我们"></a>3.6 又是局部性救了我们</h4><p>虚拟内存能工作好，主要归功于<strong>局部性</strong>。尽管在整个运行过程中程序引用的不同的页面的总数可能会超过物理内存总的大小，但是局部性原则保证了在任意时刻，程序趋向于在一个较小的<strong>活动页面</strong>集合上工作。这个集合叫做工作集合或者常驻集合。</p><p>有时程序可能不会表现出良好的时间局部性。如果工作集的大小超过了物理内存的大小，那么程序将产生一种不幸的状态，叫做<strong>抖动</strong>，这时页面将会不断换入换出，程序就会很慢，我们也该想想是不时设计出了问题，并尝试解决抖动。</p><blockquote><p>内存抖动最常见的例子应该就是数组的按行访问和按列访问了，按行访问明显会好一点。</p></blockquote><h3 id="4、虚拟内存作为内存管理的工具"><a href="#4、虚拟内存作为内存管理的工具" class="headerlink" title="4、虚拟内存作为内存管理的工具"></a>4、虚拟内存作为内存管理的工具</h3><p>实际上，操作系统为每一个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间，而且多个虚拟页面也可以映射到同一个物理页面上。</p><p><strong>按需页面调度</strong>和<strong>独立的虚拟地址空间</strong>的结合，对系统内存的使用和管理造成了深远的影响。VM简化了加载和链接、代码和数据的共享，以及应用程序的内存分配：</p><ul><li><p>简化链接<br>独立地址空间允许每个进程的内存映像使用相同的基本格式。例如在64位x86-64平台上，代码段总是从虚拟地址0x400000开始。数据段跟在代码段后，中间夹杂着对齐空白。栈占据用户进程地址空间的最高部分0x7fffffff，并向下增长。<strong>这样的一致性极大地简化了链接器的设计和实现，运行链接器生成完全连接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的</strong>。</p></li><li><p>简化加载<br>把目标文件（可执行文件和共享对象文件）中的.text和.data加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把他们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。然而，<strong>加载器从不从磁盘复制任何数据到内存中</strong>，而在每个页被初次引用时，或CPU取指令时，或一条正在执行的指令引用一个内存位置时，虚拟内存系统会按需自动调入数据页。</p></li><li><p>简化共享<br>一般情况下，<strong>每个进程都有自己私有的代码、数据、堆、以及栈区域，是不和其他进程共享的</strong>。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。在部分情况下，进程间还是需要共享代码和数据的，例如每个C程序都会调用C标准库中的程序（printf）、都需要调用相同的内核代码。<strong>操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和C标准库的副本</strong>。</p></li><li><p>简化内存分配<br>当运行在用户进程的程序要求额外的堆空间时（如调用malloc），操作系统分配k个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的k个任意的物理页面。<strong>由于页表的存在，操作系统没必要分配k个连续的物理页面，页面可随机地分散在物理内存中</strong>。</p></li></ul><h3 id="5、虚拟内存作为内存保护的工具"><a href="#5、虚拟内存作为内存保护的工具" class="headerlink" title="5、虚拟内存作为内存保护的工具"></a>5、虚拟内存作为内存保护的工具</h3><p>可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。比如每个PTE中已经添加了三个许可位，SUP位表示进程能否必须运行在内核模式才能访问该页，READ位和WRITE位控制对页面的读和写访问。</p><p>如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核的异常处理程序。Linux shell一般将这种异常报告为“段错误segmentation fault”。</p><h3 id="6-地址翻译"><a href="#6-地址翻译" class="headerlink" title="6 地址翻译"></a>6 地址翻译</h3><p>形式上来说，地址翻译是一个N元素的虚拟地址空间(VAS)的元素和一个M元素的物理地址空间(PAS)中元素之间的映射，</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/12.png?raw=true" alt></p><p>这里</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/13.png?raw=true" alt></p><p>下图展示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器(Page Table Base Register, PTRB)指向当前页表。<strong>n位的虚拟地址包含两个部分</strong>:一个p位的<strong>虚拟页面偏移</strong>(Virtual Page Offset, VPO)和一个(n-p)位的<strong>虚拟页号</strong>(Virtual Page Number， VPN)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE 0，VPN1选择PTE 1，以此类推。将页表条目中物理页号(Physical Page Number，PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/14.png?raw=true" alt></p><p>下面来讨论一下页面命中和不命中的处理过程。页面命中完全由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。<br><strong>当页面命中时，CPU硬件执行步骤如下</strong>：</p><ul><li>(1)、处理器生成一个虚拟地址，并把它传给MMU</li><li>(2)、MMU生成PTE地址，并从高速缓存/主存请求得到它（这一步是因为页表是在内存中）</li><li>(3)、高速缓存/主存向MMU返回PTE</li><li>(4)、MMU构造物理地址，并把它传送给高速缓存/主存</li><li>(5)、高速缓存/主存返回所请求的数据给处理器</li></ul><p><strong>缺页时，硬盘和操作系统内核协作完成如下</strong>：</p><ul><li>(1)、处理器生成一个虚拟地址，并把它传给MMU</li><li>(2)、MMU生成PTE地址，并从高速缓存/主存请求得到它（这一步是因为页表是在内存中）</li><li>(3)、高速缓存/主存向MMU返回PTE</li><li>(4)、PTE有效位是0，MMU出发一次异常，传递CPU中的控制到操作系统内核中的<strong>缺页异常处理程序</strong>。</li><li>(5)、缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到硬盘。</li><li>(6)、缺页异常处理程序页面调入新的页面，并更新内存中的PTE。</li><li>(7)、缺页异常处理程序返回到原来的进程中，再次执行指令，这次就会命中。</li></ul><h4 id="6-1-结合高速缓存和虚拟内存"><a href="#6-1-结合高速缓存和虚拟内存" class="headerlink" title="6.1 结合高速缓存和虚拟内存"></a>6.1 结合高速缓存和虚拟内存</h4><p>在任何既使用虚拟内存又使用SRAM高速缓存的系统中，都有因该使用虚拟地址还是物理地址来访问SRAM高速缓存的问题。大多数的系统都选择物理寻址，使用物理寻址，就可以将页表（条目）也加载到高速缓存并能像访问其他存储块一样访问。而且高速缓存也无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。 </p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/15.png?raw=true" alt></p><p>处理器（虚拟内存地址）——————&gt;MMU——————&gt;高速缓存——————&gt;内存。</p><h4 id="6-2-利用TLB加速地址翻译"><a href="#6-2-利用TLB加速地址翻译" class="headerlink" title="6.2 利用TLB加速地址翻译"></a>6.2 利用TLB加速地址翻译</h4><p>为了降低从内存取PTE的开销，许多系统在MMU中引入了一个关于PTE的小的缓存，称为<strong>翻译后备缓冲器</strong>（TLB，快表）。</p><p>TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由PTE组成的块。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/16.png?raw=true" alt></p><p>如果TLB命中，则取出对应的PTE并生成物理地址并访问高速缓存/主存获取请求的数据，如果不命中，则到高速缓存/内存中去取PTE，并放到TLB中，可能会覆盖。<br><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/17.png?raw=true" alt></p><h4 id="6-3-多级页表"><a href="#6-3-多级页表" class="headerlink" title="6.3 多级页表"></a>6.3 多级页表</h4><p>为什么要使用多级页表？假设有一个32位的地址空间，每个页4KB，那么需要2^20个PTE来进行表示，又如果每条PTE占4Byte，那么总的需要4M的内存空间来存储页表。而这只是32位地址情况，如果是64位就又会复杂很多。</p><p>假设一个上述32位虚拟地址空间有如下形式：内存的前2K个页面分配给了代码和数据，接下来6K个页面未分配，再接下来的1023个也未分配，接下来的1个页面分配给了用户栈。下图展示了如何为虚拟空间构造一个两级也表层次结构:</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/19.png?raw=true" alt></p><p>多级页表从两个方面减少了内存要求：</p><ul><li>如果一级页表中的一个PTE为空，那么对应的二级页表就不存在。这能带来很大的结局，<strong>通常一个4GB的虚拟进程空间的大部分都是未分配的</strong>。</li><li>只有一级页表才需要总是存在主存中。而二级页表只有在需要时才进行创建、页面调入和调出，能极大地减少主存的压力，只有常用的二级页表才需要缓存在主存中。</li></ul><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/20.png?raw=true" alt></p><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h3><p>参考书籍：《深入理解计算机系统》<br>参考链接：<a href="https://blog.csdn.net/longbei9029/article/details/79281273" target="_blank" rel="noopener">https://blog.csdn.net/longbei9029/article/details/79281273</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做&lt;strong&gt;虚拟内存&lt;/strong&gt;(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的俺没交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟地址内存提供了三个重要的能力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/li&gt;
&lt;li&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/li&gt;
&lt;li&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="操作系统" scheme="http://WenDeng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》第6章 算法</title>
    <link href="http://WenDeng.github.io/2019/05/20/c++%E5%9F%BA%E7%A1%80/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%AC6%E7%AB%A0%20%E7%AE%97%E6%B3%95/"/>
    <id>http://WenDeng.github.io/2019/05/20/c++基础/《STL源码剖析》第6章 算法/</id>
    <published>2019-05-20T06:32:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>STL算法部分主要由头文件<algorithm>,<numeric>,<functional>组成。要使用 STL中的算法函数必须包含头文件<algorithm>，对于数值算法须包含<numeric>，<functional>中则定义了一些模板类，用来声明函数对象。</functional></numeric></algorithm></functional></numeric></algorithm></p><a id="more"></a><blockquote><p>大部分内容摘自：<a href="https://www.cnblogs.com/linuxAndMcu/p/10264339.html" target="_blank" rel="noopener">https://www.cnblogs.com/linuxAndMcu/p/10264339.html</a></p></blockquote><h3 id="1、常见的算法种类"><a href="#1、常见的算法种类" class="headerlink" title="1、常见的算法种类"></a>1、常见的算法种类</h3><p>（1）质变与非质变算法：</p><ul><li>质变算法-会改变操作对象的值。所有的STL算法都作用在[first,last)所标示的区间上，在运算过程中改变区间元素值。例如：copy,swap,replace,fill,remove,permulation,partition,sort等。</li><li>非质变算法-不改变操作对象之值。例如：find,search,count,equal,max,min等。</li></ul><p>（2）STL中算法大致分为四类：</p><ul><li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li><li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li><li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li><li>数值算法：对容器内容进行数值计算。</li></ul><p>细致分类可分为13类，由于算法过多，所以不一一做介绍，只选取几个最常用的算法介绍。</p><h3 id="2、SGI-STL中的常见算法"><a href="#2、SGI-STL中的常见算法" class="headerlink" title="2、SGI STL中的常见算法"></a>2、SGI STL中的常见算法</h3><h4 id="2-1-查找算法"><a href="#2-1-查找算法" class="headerlink" title="2.1 查找算法"></a>2.1 查找算法</h4><p>查找算法共13个，包含在<algorithm>头文件中，用来提供元素排序策略，这里只列出一部分算法：</algorithm></p><ul><li>adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。</li><li>count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</li><li>count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。</li><li>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</li><li>equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。</li><li>find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回指向该元素的Iterator。</li><li>find_if: 使用输入的函数代替等于操作符执行find。</li><li>search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。</li><li>search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_find: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 ***/</span></span><br><span class="line">    <span class="comment">//原型： count(_InIt _First, _InIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count(==7): "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count(iv.begin(), iv.end(), <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//统计6的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 ***/</span></span><br><span class="line">    <span class="comment">//原型： count_if(_InIt _First, _InIt _Last, _Pr _Pred)</span></span><br><span class="line">    <span class="comment">//统计小于7的元素的个数 :9个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count_if(&lt;7): "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(iv.begin(), iv.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">7</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** binary_search: 在有序序列中查找value，找到返回true。 ***/</span></span><br><span class="line">    <span class="comment">//原型： bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"binary_search: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binary_search(iv.begin(), iv.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到返回true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 ***/</span></span><br><span class="line">    <span class="comment">//原型： equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; pairIte;  </span><br><span class="line">    pairIte = equal_range(iv.begin(), iv.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairIte.first:"</span> &lt;&lt; *(pairIte.first) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//lowerbound 3   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairIte.second:"</span> &lt;&lt; *(pairIte.second) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//upperbound 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find: "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *find(iv.begin(), iv.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回元素为4的元素的下标位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** find_if: 使用输入的函数代替等于操作符执行find。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find_if: "</span> &lt;&lt; *find_if(iv.begin(), iv.end(), bind2nd(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//返回大于2的第一个元素的位置：3 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列的位置。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)</span></span><br><span class="line">    <span class="comment">//在iv中查找 子序列 2 3 第一次出现的位置的元素   </span></span><br><span class="line">    <span class="keyword">int</span> iarr3[<span class="number">3</span>] = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv3(iarr3, iarr3 + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"search: "</span> &lt;&lt; *search(iv.begin(), iv.end(), iv3.begin(), iv3.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** search_n: 在指定范围内查找val出现n次的子序列。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//在iv中查找 2个6 出现的第一个位置的元素   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"search_n: "</span> &lt;&lt; *search_n(iv.begin(), iv.end(), <span class="number">2</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-排序和通用算法"><a href="#2-2-排序和通用算法" class="headerlink" title="2.2 排序和通用算法"></a>2.2 排序和通用算法</h4><p>排序算法共14个，包含在<algorithm>头文件中，用来判断容器中是否包含某个值，这里只列出一部分算法：</algorithm></p><ul><li>merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。</li><li>random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。</li><li>nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。</li><li>reverse: 将指定范围内元素重新反序排序。</li><li>sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。</li><li>stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要注意的技巧</span></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:</span></span><br><span class="line"><span class="comment">//自定义从大到小的比较器，用来改变排序方式</span></span><br><span class="line"><span class="keyword">bool</span> Comp(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr1[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv1(iarr1, iarr1 + <span class="keyword">sizeof</span>(iarr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(iarr1 + <span class="number">4</span>, iarr1 + <span class="number">8</span>); <span class="comment">//4 5 6 6</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** merge: 合并两个有序序列，存放到另一个序列 ***/</span></span><br><span class="line">    <span class="comment">//iv1和iv2合并到iv3中（合并后会自动排序）</span></span><br><span class="line">    merge(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"merge合并后: "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** random_shuffle: 对指定范围内的元素随机调整次序。 ***/</span></span><br><span class="line">    <span class="keyword">int</span> iarr2[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv4(iarr2, iarr2 + <span class="keyword">sizeof</span>(iarr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//打乱顺序  </span></span><br><span class="line">    random_shuffle(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"random_shuffle打乱后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** nth_element: 将范围内的序列重新排序。 ***/</span></span><br><span class="line">    <span class="comment">//将小于iv.begin+5的放到左边   </span></span><br><span class="line">    nth_element(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">begin</span>() + <span class="number">5</span>, iv4.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"nth_element重新排序后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** reverse: 将指定范围内元素重新反序排序。 ***/</span></span><br><span class="line">    reverse(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"reverse翻转后: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** sort: 以升序重新排列指定范围内的元素。 ***/</span></span><br><span class="line">    <span class="comment">//sort(iv4.begin(), iv4.end(), Comp); //也可以使用自定义Comp()函数</span></span><br><span class="line">    sort(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="string">"sort排序（倒序）: "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 ***/</span></span><br><span class="line">    <span class="keyword">int</span> iarr3[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv5(iarr3, iarr3 + <span class="keyword">sizeof</span>(iarr3) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    stable_sort(iv5.<span class="built_in">begin</span>(), iv5.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="string">"stable_sort排序（倒序）: "</span>;</span><br><span class="line">    for_each(iv5.<span class="built_in">begin</span>(), iv5.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-删除和替换算法"><a href="#2-3-删除和替换算法" class="headerlink" title="2.3 删除和替换算法"></a>2.3 删除和替换算法</h4><p>删除和替换算法共15个，包含在<numeric>头文件中，这里只列出一部分算法：</numeric></p><ul><li>copy: 复制序列。</li><li>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。</li><li>remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。</li><li>remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。</li><li>remove_if: 删除指定范围内输入操作结果为true的所有元素。</li><li>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr1[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv1(iarr1, iarr1 + <span class="keyword">sizeof</span>(iarr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** copy: 复制序列 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt copy(_InIt _First, _InIt _Last,_OutIt _Dest)</span></span><br><span class="line">    copy(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"copy(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,_BidIt2 _Dest)</span></span><br><span class="line">    copy_backward(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.rend());</span><br><span class="line">    cout &lt;&lt; <span class="string">"copy_backward(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove: 删除指定范围内所有等于指定元素的元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="built_in">remove</span>(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">//删除元素5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove(iv1): "</span>;</span><br><span class="line">    for_each(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 ***/</span></span><br><span class="line">    <span class="comment">// 原型：  _OutIt remove_copy(_InIt _First, _InIt _Last,_OutIt _Dest, const _Ty&amp; _Val)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(<span class="number">8</span>);</span><br><span class="line">    remove_copy(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>(), <span class="number">4</span>); <span class="comment">//去除4 然后将一个容器的元素复制到另一个容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_copy(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_if: 删除指定范围内输入操作结果为true的所有元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)</span></span><br><span class="line">    remove_if(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">6</span>)); <span class="comment">// 将小于6的元素 "删除"</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_if(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 ***/</span></span><br><span class="line">    <span class="comment">//原型： _OutIt remove_copy_if(_InIt _First, _InIt _Last,_OutIt _Dest, _Pr _Pred)</span></span><br><span class="line">    <span class="comment">// 将iv1中小于6的元素 "删除"后，剩下的元素再复制给iv3</span></span><br><span class="line">    remove_copy_if(iv1.<span class="built_in">begin</span>(), iv1.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">"remove_if(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>replace: 将指定范围内所有等于vold的元素都用vnew代替。</li><li>replace_copy: 与replace类似，不过将结果写入另一个容器。</li><li>replace_if: 将指定范围内所有操作结果为true的元素用新值代替。</li><li>replace_copy_if: 与replace_if，不过将结果写入另一个容器。</li><li>swap: 交换存储在两个对象中的值。</li><li>swap_range: 将指定范围内的元素与另一个序列元素值进行交换。</li><li>unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。</li><li>unique_copy: 与unique类似，不过把结果输出到另一个容器。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //定义了greater&lt;int&gt;()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct <span class="built_in">display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> T&amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace: 将指定范围内所有等于vold的元素都用vnew代替。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： void replace(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)</span></span><br><span class="line">    <span class="comment">//将容器中6 替换为 3   </span></span><br><span class="line">    replace(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace(iv): "</span>;</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//由于_X是static 所以接着 增长</span></span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv:8 10 7 8 3 3 7 8 3 7 8   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_copy: 与replace类似，不过将结果写入另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv2(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//将容器中3 替换为 5，并将结果写入另一个容器。  </span></span><br><span class="line">    replace_copy(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv2:8 10 7 8 5 5 7 8 5 7 8 0（最后y一个残留元素）   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将容器中小于 5 替换为 2   </span></span><br><span class="line">    replace_if(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy(iv): "</span>;</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());   </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv:8 10 7 8 2 5 7 8 2 7 8   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** replace_copy_if: 与replace_if，不过将结果写入另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将容器中小于 5 替换为 2，并将结果写入另一个容器。  </span></span><br><span class="line">    replace_copy_if(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv2.<span class="built_in">begin</span>(), bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(), <span class="number">8</span>), <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"replace_copy_if(iv2): "</span>;</span><br><span class="line">    for_each(iv2.<span class="built_in">begin</span>(), iv2.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">//iv2:9 10 7 8 2 5 7 9 2 7 8 0(最后一个残留元素)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iarr3[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv3(iarr3, iarr3 + <span class="keyword">sizeof</span>(iarr3) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> iarr4[] = &#123; <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, &#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; iv4(iarr4, iarr4 + <span class="keyword">sizeof</span>(iarr4) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** swap: 交换存储在两个对象中的值。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)</span></span><br><span class="line">    <span class="comment">//将两个容器中的第一个元素交换  </span></span><br><span class="line">    swap(*iv3.<span class="built_in">begin</span>(), *iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"swap(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest)</span></span><br><span class="line">    <span class="comment">//将两个容器中的全部元素进行交换  </span></span><br><span class="line">    swap_ranges(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), iv3.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"swap_range(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** unique: 清除序列中相邻的重复元素，和remove类似，它也不能真正删除元素。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) </span></span><br><span class="line">    unique(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"unique(iv3): "</span>;</span><br><span class="line">    for_each(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** unique_copy: 与unique类似，不过把结果输出到另一个容器。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)</span></span><br><span class="line">    unique_copy(iv3.<span class="built_in">begin</span>(), iv3.<span class="built_in">end</span>(), iv4.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">"unique_copy(iv4): "</span>;</span><br><span class="line">    for_each(iv4.<span class="built_in">begin</span>(), iv4.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-排列组合算法"><a href="#2-4-排列组合算法" class="headerlink" title="2.4 排列组合算法"></a>2.4 排列组合算法</h4><p>排列组合算法共2个，包含在<algorithm>头文件中，用来提供计算给定集合按一定顺序的所有可能排列组合，这里全部列出：</algorithm></p><ul><li>next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。重载版本使用自定义的比较操作。</li><li>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp;x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[] = &#123; <span class="number">12</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(iarr, iarr + <span class="keyword">sizeof</span>(iarr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。***/</span></span><br><span class="line">    <span class="comment">// 原型： bool next_permutation(_BidIt _First, _BidIt _Last)</span></span><br><span class="line">    <span class="comment">//生成下一个排列组合（字典序）   </span></span><br><span class="line">    next_permutation(iv.begin(), iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。 ***/</span></span><br><span class="line">    <span class="comment">// 原型： bool prev_permutation(_BidIt _First, _BidIt _Last)</span></span><br><span class="line">    prev_permutation(iv.begin(), iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-数值算法"><a href="#2-5-数值算法" class="headerlink" title="2.5 数值算法"></a>2.5 数值算法</h4><p>数值算法共4个，包含在<numeric>头文件中，分别是：</numeric></p><ul><li>accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。</li><li>partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。</li><li>inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。</li><li>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //数值算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; //定义了ostream_iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(arr, arr + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2(arr, arr + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    temp = accumulate(vec.begin(), vec.end(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate(val = 0): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    temp = accumulate(vec.begin(), vec.end(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate(val = 1): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。</span></span><br><span class="line">    <span class="comment">//这里是：1*1 + 2*2 + 3*3 + 4*4 + 5*5</span></span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">    temp = inner_product(vec.begin(), vec.end(), vec2.begin(), val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"inner_product(val = 0): "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。</span></span><br><span class="line">    <span class="comment">//第一次，1   第二次，1+2  第三次，1+2+3  第四次，1+2+3+4</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; oit(<span class="built_in">cout</span>, <span class="string">" "</span>); <span class="comment">//迭代器绑定到cout上作为输出使用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ostream_iterator: "</span>;</span><br><span class="line">    partial_sum(vec.begin(), vec.end(), oit);<span class="comment">//依次输出前n个数的和</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第一次，1   第二次，1-2  第三次，1-2-3  第四次，1-2-3-4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ostream_iterator(minus): "</span>;</span><br><span class="line">    partial_sum(vec.begin(), vec.end(), oit, minus&lt;<span class="keyword">int</span>&gt;());<span class="comment">//依次输出第一个数减去（除第一个数外到当前数的和）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。</span></span><br><span class="line">    <span class="comment">//第一次，1-0   第二次，2-1  第三次，3-2  第四次，4-3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_difference: "</span>;</span><br><span class="line">    adjacent_difference(vec.begin(), vec.end(), oit); <span class="comment">//输出相邻元素差值 后面-前面</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第一次，1+0   第二次，2+1  第三次，3+2  第四次，4+3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"adjacent_difference(plus): "</span>;</span><br><span class="line">    adjacent_difference(vec.begin(), vec.end(), oit, plus&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//输出相邻元素差值 后面-前面 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、几个算法的具体实现原理"><a href="#3、几个算法的具体实现原理" class="headerlink" title="3、几个算法的具体实现原理"></a>3、几个算法的具体实现原理</h3><h4 id="3-1-next-permutation-的实现"><a href="#3-1-next-permutation-的实现" class="headerlink" title="3.1 next_permutation()的实现"></a>3.1 next_permutation()的实现</h4><p>该算法用于求区间序列的<strong>下一个</strong>排列组合，在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，并且满足*i &lt; *ii。然后再从尾端寻找另一个元素*j，如果满足*i &lt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。</p><p><img src="https://github.com/WenDeng/Picture_markdown/blob/master/picture/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/23.png?raw=true" alt="image"></p><p>代码实现：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class BidirectionalIterator&gt;  </span><br><span class="line">bool next_permutation(BidirectionalIterator <span class="built_in">first</span>, BidirectionalIterator <span class="built_in">last</span>)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">first</span> == <span class="built_in">last</span>)  <span class="built_in">return</span> <span class="literal">false</span>; //空序列  </span><br><span class="line">  </span><br><span class="line">    BidirectionalIterator i = <span class="built_in">first</span>;  </span><br><span class="line">    ++i;  </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="built_in">last</span>)  <span class="built_in">return</span> <span class="literal">false</span>;  //一个元素，没有下一个序列了  </span><br><span class="line">      </span><br><span class="line">    i = <span class="built_in">last</span>;  </span><br><span class="line">    --i;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;  </span><br><span class="line">        BidirectionalIterator ii = i;  //不断往前移动</span><br><span class="line">        --i;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(*i &lt; *ii) //满足条件</span><br><span class="line">        &#123;  </span><br><span class="line">            BidirectionalIterator j = <span class="built_in">last</span>;  </span><br><span class="line">            <span class="keyword">while</span>(!(*i &lt; *--j)); //找到*i&lt;*j的情况  </span><br><span class="line">            iter_swap(i, j);  //进行交换</span><br><span class="line">            <span class="built_in">reverse</span>(ii, <span class="built_in">last</span>);  </span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="built_in">first</span>) </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">reverse</span>(<span class="built_in">first</span>, <span class="built_in">last</span>);  //全逆向，即为最小字典序列，如cba变为abc  </span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-pre-permutation-的实现原理"><a href="#3-2-pre-permutation-的实现原理" class="headerlink" title="3.2 pre_permutation()的实现原理"></a>3.2 pre_permutation()的实现原理</h4><p>该算法用于求区间序列的<strong>上一个</strong>排列组合，在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，直到满足*i &gt; *ii。然后再从尾端寻找另一个元素*j，如果满足*i &gt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出上一个序列了。</p><h4 id="3-3-sort-的实现原理"><a href="#3-3-sort-的实现原理" class="headerlink" title="3.3 sort()的实现原理"></a>3.3 sort()的实现原理</h4><p>STL中的sort并非只是普通的快速排序，<strong>除了对普通的快速排序进行优化，它还结合了插入排序和堆排序</strong>。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾</p><p>Quick Sort中任何一个元素都可以被选做枢轴，比如随机选取，固定选取。但是划分的两端越均匀，执行效率越高；如果其中一段长度为0，那就出现了最坏情况。最理想的选取方法是选取头、尾和中间三个元素中大小处于中间的那个元素作为枢轴。这样可以避免出现最坏情况（<strong>三点中值法</strong>）。</p><h4 id="3-4-partition-的实现原理"><a href="#3-4-partition-的实现原理" class="headerlink" title="3.4 partition()的实现原理"></a>3.4 partition()的实现原理</h4><p>对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last。一元谓词可以用lambda表达式等。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; <span class="built_in">class</span> ForwardIt, <span class="built_in">class</span> UnaryPredicate &gt;</span><br><span class="line">ForwardIt partition( ForwardIt <span class="keyword">first</span>, ForwardIt <span class="keyword">last</span>, UnaryPredicate p );</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL算法部分主要由头文件&lt;algorithm&gt;,&lt;numeric&gt;,&lt;functional&gt;组成。要使用 STL中的算法函数必须包含头文件&lt;algorithm&gt;，对于数值算法须包含&lt;numeric&gt;，&lt;functional&gt;中则定义了一些模板类，用来声明函数对象。&lt;/functional&gt;&lt;/numeric&gt;&lt;/algorithm&gt;&lt;/functional&gt;&lt;/numeric&gt;&lt;/algorithm&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++基础" scheme="http://WenDeng.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="STL源码" scheme="http://WenDeng.github.io/tags/STL%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>c++11特性之列表初始化</title>
    <link href="http://WenDeng.github.io/2019/05/19/c++%E5%9F%BA%E7%A1%80/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://WenDeng.github.io/2019/05/19/c++基础/c++11列表初始化/</id>
    <published>2019-05-19T08:20:12.000Z</published>
    <updated>2019-07-29T17:18:54.934Z</updated>
    
    <content type="html"><![CDATA[<p>最近注意到c++11的列表初始化特性，发现还是挺方便的，这里总结一下，以便之后进行使用。<br><a id="more"></a></p><hr><h3 id="1、-C-11的各种初始化方式"><a href="#1、-C-11的各种初始化方式" class="headerlink" title="1、 C++11的各种初始化方式"></a>1、 C++11的各种初始化方式</h3><p>c++11主要提供了如下6种初始化方式：<strong>零初始化、默认初始化、值初始化、直接初始化、拷贝初始化、列表初始化</strong>。<br>几种初始化之间的主要区别如下：</p><ul><li><strong>默认初始化</strong>：如果是一个类，那么调用默认构造函数进行初始化；如果是一个数组，那么每个元素默认初始化；除了前面的情况之外，不进行初始化，其值未定义。</li><li><strong>值初始化</strong>：如果是一个类，那么类的对象进行默认初始化,如果用户没有定义默认构造函数，则会进行零值初始化再进行默认初始化；如果是一个数组，每个元素值初始化，否则进行零初始化。<strong>如果你不想要你的默认构造函数是用户自定义的，那么必须在类的内部声明处使用”=default”，而不是在类外部定义处使用，后者会使得编译器认为用户定义了默认构造函数。</strong></li><li><strong>零初始化</strong>：对于static或者thread_local变量将会在其他类型的初始化之前先初始化。如果T是算数、指针、枚举类型，将会初始化为0；如果是类类型，基类和数据成员会零初始化；如果是数组，数组元素也零初始化。</li></ul><h3 id="2、-几种初始化的实例"><a href="#2、-几种初始化的实例" class="headerlink" title="2、 几种初始化的实例"></a>2、 几种初始化的实例</h3><p>下面给出几种上述初始化方式的实例，从代码上来体现他们的区别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;         <span class="comment">//默认初始化</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;       <span class="comment">//值初始化(C++11)，要求初始化，但没有给出初始值的行为</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">5</span>;     <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l</span><span class="params">()</span></span>;       <span class="comment">//值初始化</span></span><br><span class="line"><span class="keyword">int</span> m&#123;<span class="number">4</span>&#125;;       <span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;       <span class="comment">//默认初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>();     <span class="comment">//值初始化</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>&#123;&#125;;     <span class="comment">//值初始化(C++11)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="string">"dengwen"</span>&#125;; <span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">string</span> str1=str;  <span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure></p><p>只要使用了括号（圆括号或花括号）但没有给出具体初始值，就是值初始化。可以简单理解为括号告诉编译器你希望该对象初始化。</p><p>没有使用括号，就是默认初始化。可以简单理解成，你放任不管，允许编译器使用默认行为。通常这是糟糕的行为，除非你真的懂自己在干什么。</p><h3 id="3、-列表初始化的特殊之处"><a href="#3、-列表初始化的特殊之处" class="headerlink" title="3、 列表初始化的特殊之处"></a>3、 列表初始化的特殊之处</h3><p>在C++11以前，程序员，或者初学者经常会感到疑惑关于怎样去初始化一个变量或者是一个对象。这么多的对象初始化方式，不仅增加了学习成本，也使得代码风格有较大出入，影响了代码的可读性和统一性。</p><p>从C++11开始，对列表初始化（List Initialization）的功能进行了扩充，可以作用于任何类型对象的初始化，至此，列表初始化方式完成了天下大一统。</p><p>花括号列表初始化，作为C++11新标准的一部被加入到了C++中。因为这个原因，c++11提出了统一初始化，下面的做法都是正确的。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:    </span><br><span class="line">    C(int i, int j); </span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int b;   </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">Test </span>t&#123;1,3&#125;; //初始化</span><br><span class="line">t=&#123;2,4&#125;;  //这里可以直接进行赋值，而且是对私有变量....</span><br><span class="line"><span class="keyword">Test </span>*p=new Test&#123;3,5&#125;;  //列表初始化</span><br><span class="line">int *q = new int[3]&#123;1,2,0&#125;;   //数组</span><br></pre></td></tr></table></figure></p><p>此外，C++11列表初始化还可以应用于容器，终于可以摆脱 push_back() 调用了，将C++11提供的列表初始化作为统一的初始化方式，既降低了记忆难度，也提高的代码的统一度。</p><p>需要注意的点：<strong>使用初始化列表来初始化内置类型的变量时，若存在类型转换且具有丢失信息的风险时，编译器将会报错</strong>。</p><p>通过这一点可以看出，列表初始化比原有的初始化方式具有更严格的安全要求。下面是例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>；</span><br><span class="line"><span class="keyword">int</span> a &#123;ld&#125;， b = &#123;ld&#125;;  <span class="comment">// 编译器报错，存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span>(<span class="params">ld</span>), d</span> = ld ;    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近注意到c++11的列表初始化特性，发现还是挺方便的，这里总结一下，以便之后进行使用。&lt;br&gt;
    
    </summary>
    
      <category term="C++基础" scheme="http://WenDeng.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++11特性" scheme="http://WenDeng.github.io/tags/C-11%E7%89%B9%E6%80%A7/"/>
    
      <category term="技术" scheme="http://WenDeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
